<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Debug CCS Flow</title>
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; }
        .step { margin: 20px 0; border: 1px solid #ccc; padding: 15px; }
        .btn { padding: 10px 20px; margin: 5px; cursor: pointer; border: none; border-radius: 4px; background: #3b82f6; color: white; }
        .success { color: #10b981; }
        .error { color: #dc2626; }
        #log { background: #f3f4f6; padding: 10px; font-family: monospace; font-size: 12px; max-height: 300px; overflow-y: auto; }
    </style>
</head>
<body>
    <h1>Debug CCS Flow - Test Complet</h1>
    
    <div class="step">
        <h3>√âtape 1: Simuler Risk Dashboard - Appliquer Strat√©gie CCS</h3>
        <button class="btn" onclick="simulateRiskDashboard()">üéØ Simuler Application Strat√©gie</button>
        <div id="step1Result"></div>
    </div>
    
    <div class="step">
        <h3>√âtape 2: V√©rifier localStorage</h3>
        <button class="btn" onclick="checkLocalStorage()">üîç V√©rifier localStorage</button>
        <div id="step2Result"></div>
    </div>
    
    <div class="step">
        <h3>√âtape 3: Tester fonction syncCCSTargets</h3>
        <button class="btn" onclick="testSyncFunction()">üîÑ Test Sync CCS</button>
        <div id="step3Result"></div>
    </div>
    
    <div class="step">
        <h3>√âtape 4: Simuler rebalance.html - Refresh Strategy</h3>
        <button class="btn" onclick="simulateRebalanceRefresh()">üöÄ Simuler Refresh Dynamic</button>
        <div id="step4Result"></div>
    </div>
    
    <div class="step">
        <h3>Debug Log</h3>
        <div id="log"></div>
    </div>

    <script type="module">
        const log = document.getElementById('log');
        
        function logMsg(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const color = type === 'error' ? '#dc2626' : type === 'success' ? '#10b981' : '#374151';
            log.innerHTML += `<div style="color: ${color}; margin: 2px 0;">[${timestamp}] ${message}</div>`;
            log.scrollTop = log.scrollHeight;
        }

        function updateStep(stepId, message, type = 'info') {
            const element = document.getElementById(stepId);
            const className = type === 'error' ? 'error' : type === 'success' ? 'success' : '';
            element.innerHTML = `<div class="${className}">${message}</div>`;
        }

        // √âtape 1: Simuler l'application d'une strat√©gie dans risk-dashboard.html
        window.simulateRiskDashboard = async function() {
            try {
                logMsg('=== √âTAPE 1: Simulation Risk Dashboard ===');
                logMsg('Importation des modules...');
                
                const { fetchAndComputeCCS } = await import('./static/modules/signals-engine.js');
                const { estimateCyclePosition, blendCCS } = await import('./static/modules/cycle-navigator.js');
                const { proposeTargets, applyTargets } = await import('./static/modules/targets-coordinator.js');
                const { store } = await import('./static/core/risk-dashboard-store.js');
                
                logMsg('Modules import√©s avec succ√®s');
                
                // G√©n√©rer donn√©es CCS
                const ccs = await fetchAndComputeCCS();
                const cycle = estimateCyclePosition();
                const blended = blendCCS(ccs.score, cycle.months, 0.3);
                
                logMsg(`CCS g√©n√©r√©: ${ccs.score.toFixed(1)}`);
                logMsg(`Cycle: ${cycle.phase.phase} (${Math.round(cycle.months)}m)`);
                logMsg(`Blended CCS: ${blended.blendedCCS.toFixed(1)}`);
                
                // Configurer store
                store.set('ccs', ccs);
                store.set('cycle', cycle);
                store.set('cycle.ccsStar', blended.blendedCCS);
                
                // Proposer et appliquer strat√©gie
                const proposal = proposeTargets('blend');
                logMsg(`Strat√©gie propos√©e: ${proposal.strategy}`);
                logMsg(`BTC: ${proposal.targets.BTC?.toFixed(1)}%, ETH: ${proposal.targets.ETH?.toFixed(1)}%`);
                
                await applyTargets(proposal);
                logMsg('Targets appliqu√©s avec succ√®s!');
                
                updateStep('step1Result', '‚úÖ Strat√©gie CCS simul√©e et appliqu√©e avec succ√®s', 'success');
                
            } catch (error) {
                logMsg(`Erreur √©tape 1: ${error.message}`, 'error');
                updateStep('step1Result', `‚ùå Erreur: ${error.message}`, 'error');
            }
        };

        // √âtape 2: V√©rifier localStorage
        window.checkLocalStorage = function() {
            try {
                logMsg('=== √âTAPE 2: V√©rification localStorage ===');
                
                const stored = localStorage.getItem('last_targets');
                if (!stored) {
                    throw new Error('Aucune donn√©e last_targets trouv√©e');
                }
                
                const data = JSON.parse(stored);
                logMsg(`Source: ${data.source}`);
                logMsg(`Strategy: ${data.strategy}`);
                logMsg(`Timestamp: ${data.timestamp}`);
                
                if (data.targets) {
                    Object.entries(data.targets).forEach(([key, value]) => {
                        if (typeof value === 'number') {
                            logMsg(`  ${key}: ${value.toFixed(1)}%`);
                        }
                    });
                }
                
                // V√©rifier l'√¢ge des donn√©es
                const dataAge = Date.now() - new Date(data.timestamp).getTime();
                const ageMinutes = Math.round(dataAge / 60000);
                logMsg(`√Çge des donn√©es: ${ageMinutes} minutes`);
                
                if (data.source === 'risk-dashboard-ccs') {
                    updateStep('step2Result', '‚úÖ Donn√©es localStorage correctes', 'success');
                } else {
                    updateStep('step2Result', `‚ö†Ô∏è Source incorrecte: ${data.source}`, 'error');
                }
                
            } catch (error) {
                logMsg(`Erreur √©tape 2: ${error.message}`, 'error');
                updateStep('step2Result', `‚ùå Erreur: ${error.message}`, 'error');
            }
        };

        // √âtape 3: Tester la fonction syncCCSTargets
        window.testSyncFunction = function() {
            try {
                logMsg('=== √âTAPE 3: Test fonction syncCCSTargets ===');
                
                // Fonction syncCCSTargets copi√©e de rebalance.html
                function syncCCSTargets() {
                    const storedTargets = localStorage.getItem('last_targets');
                    logMsg(`localStorage data found: ${storedTargets ? 'OUI' : 'NON'}`);
                    
                    if (!storedTargets) {
                        return null;
                    }
                    
                    try {
                        const targetsData = JSON.parse(storedTargets);
                        logMsg(`Parsed source: ${targetsData.source}`);
                        
                        if (targetsData.source === 'risk-dashboard-ccs' && targetsData.targets && targetsData.timestamp) {
                            const dataAge = Date.now() - new Date(targetsData.timestamp).getTime();
                            const maxAge = 2 * 60 * 60 * 1000;
                            
                            logMsg(`Data age: ${Math.round(dataAge / 60000)} minutes`);
                            
                            if (dataAge < maxAge) {
                                const cleanTargets = {};
                                Object.entries(targetsData.targets).forEach(([key, value]) => {
                                    if (typeof value === 'number' && key !== 'model_version') {
                                        cleanTargets[key] = value;
                                        logMsg(`Adding ${key}: ${value}%`);
                                    }
                                });
                                
                                return {
                                    targets: cleanTargets,
                                    strategy: targetsData.strategy,
                                    timestamp: targetsData.timestamp
                                };
                            } else {
                                logMsg('Data too old');
                            }
                        } else {
                            logMsg('Invalid data structure or wrong source');
                        }
                    } catch (error) {
                        logMsg(`Error parsing: ${error.message}`, 'error');
                    }
                    
                    return null;
                }
                
                const result = syncCCSTargets();
                
                if (result) {
                    logMsg('syncCCSTargets SUCCESS!');
                    updateStep('step3Result', '‚úÖ Fonction syncCCSTargets fonctionne correctement', 'success');
                } else {
                    updateStep('step3Result', '‚ùå Fonction syncCCSTargets retourne null', 'error');
                }
                
            } catch (error) {
                logMsg(`Erreur √©tape 3: ${error.message}`, 'error');
                updateStep('step3Result', `‚ùå Erreur: ${error.message}`, 'error');
            }
        };

        // √âtape 4: Simuler le refresh dans rebalance.html
        window.simulateRebalanceRefresh = function() {
            try {
                logMsg('=== √âTAPE 4: Simulation Rebalance Refresh ===');
                
                // Simuler la logique de refreshDynamicStrategy
                function syncCCSTargets() {
                    const storedTargets = localStorage.getItem('last_targets');
                    if (!storedTargets) return null;
                    
                    try {
                        const targetsData = JSON.parse(storedTargets);
                        if (targetsData.source === 'risk-dashboard-ccs' && targetsData.targets && targetsData.timestamp) {
                            const dataAge = Date.now() - new Date(targetsData.timestamp).getTime();
                            const maxAge = 2 * 60 * 60 * 1000;
                            
                            if (dataAge < maxAge) {
                                const cleanTargets = {};
                                Object.entries(targetsData.targets).forEach(([key, value]) => {
                                    if (typeof value === 'number' && key !== 'model_version') {
                                        cleanTargets[key] = value;
                                    }
                                });
                                
                                return {
                                    targets: cleanTargets,
                                    strategy: targetsData.strategy,
                                    timestamp: targetsData.timestamp
                                };
                            }
                        }
                    } catch (error) {
                        logMsg(`Sync error: ${error.message}`, 'error');
                    }
                    
                    return null;
                }
                
                const ccsTargets = syncCCSTargets();
                
                if (ccsTargets) {
                    // Simuler l'ajout √† availableStrategies
                    const dynamicStrategy = {
                        name: 'Strategic (Dynamic)',
                        icon: 'üéØ',
                        description: `Targets CCS du Risk Dashboard - ${ccsTargets.strategy}`,
                        risk_level: 'Variable',
                        allocations: ccsTargets.targets,
                        _isDynamic: true,
                        _ccsData: ccsTargets
                    };
                    
                    logMsg('Dynamic strategy created successfully:');
                    logMsg(`  Strategy: ${dynamicStrategy.description}`);
                    Object.entries(dynamicStrategy.allocations).forEach(([asset, pct]) => {
                        logMsg(`  ${asset}: ${pct.toFixed(1)}%`);
                    });
                    
                    updateStep('step4Result', '‚úÖ Strat√©gie dynamique cr√©√©e et pr√™te √† utiliser', 'success');
                } else {
                    logMsg('Aucune donn√©e CCS trouv√©e pour la strat√©gie dynamique');
                    updateStep('step4Result', '‚ùå Pas de donn√©es CCS disponibles', 'error');
                }
                
            } catch (error) {
                logMsg(`Erreur √©tape 4: ${error.message}`, 'error');
                updateStep('step4Result', `‚ùå Erreur: ${error.message}`, 'error');
            }
        };
        
        logMsg('Debug CCS Flow ready. Ex√©cutez les √©tapes dans l\'ordre.');
    </script>
</body>
</html>