<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Debug 11 Groups Test</title>
    <style>
        body { font-family: monospace; margin: 20px; }
        .test-result { margin: 10px 0; padding: 10px; border: 1px solid #ccc; }
        .success { background: #d4edda; }
        .error { background: #f8d7da; }
        .info { background: #d1ecf1; }
        table { border-collapse: collapse; width: 100%; margin: 10px 0; }
        th, td { border: 1px solid #ccc; padding: 8px; text-align: left; }
        th { background: #f8f9fa; }
    </style>
</head>
<body>
    <h1>üß™ Test des 11 Groupes - Strategic Targeting</h1>
    
    <div class="test-result info">
        <strong>Test:</strong> V√©rifier si le syst√®me calcule bien 11 groupes vs si l'affichage filtre les groupes √† 0%
    </div>

    <button onclick="runTest()" style="padding: 10px; background: #007bff; color: white; border: none; cursor: pointer;">
        üöÄ Lancer Test
    </button>
    
    <div id="results"></div>

    <script type="module">
        // Import les modules n√©cessaires (ajust√© pour tests/html_debug/)
        import { proposeTargets, DEFAULT_MACRO_TARGETS } from '../../static/modules/targets-coordinator.js';
        import { getMarketRegime, calculateRiskBudget, allocateRiskyBudget } from '../../static/modules/market-regimes.js';

        window.runTest = async function() {
            const resultsDiv = document.getElementById('results');
            let html = '';

            try {
                html += '<div class="test-result info"><h3>üîç Test 1: DEFAULT_MACRO_TARGETS</h3>';
                html += '<table><tr><th>Groupe</th><th>Allocation (%)</th></tr>';
                
                const allGroups = ['BTC', 'ETH', 'Stablecoins', 'SOL', 'L1/L0 majors', 'L2/Scaling', 'DeFi', 'AI/Data', 'Gaming/NFT', 'Memecoins', 'Others'];
                let foundGroups = 0;
                let totalAllocation = 0;
                
                allGroups.forEach(group => {
                    const allocation = DEFAULT_MACRO_TARGETS[group] || 0;
                    html += `<tr><td>${group}</td><td>${allocation}%</td></tr>`;
                    if (allocation > 0) foundGroups++;
                    totalAllocation += allocation;
                });
                
                html += `</table>`;
                html += `<div><strong>Groupes trouv√©s:</strong> ${foundGroups}/11</div>`;
                html += `<div><strong>Total allocation:</strong> ${totalAllocation}%</div>`;
                html += '</div>';

                // Test 2: G√©n√©ration CCS
                html += '<div class="test-result info"><h3>üîç Test 2: Proposition CCS (score 65)</h3>';
                const ccsProposal = proposeTargets('ccs', { ccsScore: 65 });
                html += '<table><tr><th>Groupe</th><th>Allocation (%)</th></tr>';
                
                let ccsFoundGroups = 0;
                let ccsTotal = 0;
                
                allGroups.forEach(group => {
                    const allocation = ccsProposal.targets[group] || 0;
                    html += `<tr><td>${group}</td><td>${allocation.toFixed(2)}%</td></tr>`;
                    if (allocation > 0) ccsFoundGroups++;
                    ccsTotal += allocation;
                });
                
                html += `</table>`;
                html += `<div><strong>Groupes trouv√©s:</strong> ${ccsFoundGroups}/11</div>`;
                html += `<div><strong>Total allocation:</strong> ${ccsTotal.toFixed(1)}%</div>`;
                html += '</div>';

                // Test 3: Smart allocation
                html += '<div class="test-result info"><h3>üîç Test 3: Smart Allocation avec Market Regimes</h3>';
                const regime = getMarketRegime(55); // Score expansion
                const riskBudget = calculateRiskBudget(55, 60);
                const smartAllocation = allocateRiskyBudget(riskBudget.percentages.risky, regime);
                
                html += '<table><tr><th>Groupe</th><th>Allocation (%)</th></tr>';
                
                let smartFoundGroups = 0;
                let smartTotal = 0;
                
                allGroups.forEach(group => {
                    const allocation = smartAllocation[group] || 0;
                    html += `<tr><td>${group}</td><td>${allocation.toFixed(2)}%</td></tr>`;
                    if (allocation > 0) smartFoundGroups++;
                    smartTotal += allocation;
                });
                
                html += `</table>`;
                html += `<div><strong>Groupes trouv√©s:</strong> ${smartFoundGroups}/11</div>`;
                html += `<div><strong>Total allocation:</strong> ${smartTotal.toFixed(1)}%</div>`;
                html += '</div>';

                // Test 4: Simulation filtrage affichage
                html += '<div class="test-result info"><h3>üîç Test 4: Simulation Filtrage d\'affichage</h3>';
                const mockTargets = {
                    'BTC': 35.2,
                    'ETH': 25.8,
                    'Stablecoins': 20.1,
                    'SOL': 5.2,
                    'L1/L0 majors': 7.3,
                    'L2/Scaling': 3.1,
                    'DeFi': 2.2,
                    'AI/Data': 1.1,
                    'Gaming/NFT': 0.0, // ‚Üê Ce groupe sera-t-il filtr√© ?
                    'Memecoins': 0.0,  // ‚Üê Ce groupe sera-t-il filtr√© ?
                    'Others': 0.0      // ‚Üê Ce groupe sera-t-il filtr√© ?
                };
                
                // Simulation filtrage > 0
                const filteredTargets = Object.entries(mockTargets).filter(([key, value]) => value > 0);
                
                html += `<div><strong>Sans filtre:</strong> ${Object.keys(mockTargets).length} groupes</div>`;
                html += `<div><strong>Avec filtre > 0:</strong> ${filteredTargets.length} groupes</div>`;
                html += `<div style="color: red;"><strong>‚ö†Ô∏è Groupes filtr√©s:</strong> ${Object.entries(mockTargets).filter(([k,v]) => v === 0).map(([k]) => k).join(', ')}</div>`;
                html += '</div>';

                // Conclusion
                if (foundGroups < 11 || ccsFoundGroups < 11 || smartFoundGroups < 11) {
                    html += '<div class="test-result error">';
                    html += '<h3>‚ùå PROBL√àME: Le calcul ne g√©n√®re pas tous les 11 groupes</h3>';
                    html += '<p>Certains groupes manquent dans les calculs backend.</p>';
                    html += '</div>';
                } else {
                    html += '<div class="test-result success">';
                    html += '<h3>‚úÖ Le calcul g√©n√®re bien 11 groupes</h3>';
                    html += '<p>Le probl√®me vient probablement du filtrage d\'affichage qui masque les groupes √† 0%.</p>';
                    html += '</div>';
                }

            } catch (error) {
                html += `<div class="test-result error">`;
                html += `<h3>‚ùå Erreur pendant le test</h3>`;
                html += `<p>${error.message}</p>`;
                html += `<pre>${error.stack}</pre>`;
                html += `</div>`;
            }

            resultsDiv.innerHTML = html;
        };
    </script>
</body>
</html>