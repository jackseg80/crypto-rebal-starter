<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Debug 11 Groups - Fix & Test</title>
    <style>
        body { font-family: monospace; margin: 20px; background: #0f0f23; color: white; }
        .test-result { margin: 10px 0; padding: 10px; border: 1px solid #333; border-radius: 5px; }
        .success { background: #1a472a; border-color: #00ff88; }
        .error { background: #4a1a1a; border-color: #ff4444; }
        .info { background: #1a1a4a; border-color: #00aaff; }
        .warning { background: #4a3a1a; border-color: #ffaa00; }
        table { border-collapse: collapse; width: 100%; margin: 10px 0; }
        th, td { border: 1px solid #444; padding: 8px; text-align: left; }
        th { background: #2a2a2a; }
        button { padding: 10px 20px; margin: 5px; background: #00ff88; color: #000; border: none; border-radius: 5px; cursor: pointer; }
        .group-zero { background: #4a1a1a !important; color: #ff8888; }
        .group-present { background: #1a4a2a !important; color: #88ff88; }
    </style>
</head>
<body>
    <h1>üîß Debug & Fix 11 Groups Problem</h1>
    
    <div class="test-result info">
        <strong>Diagnostic:</strong> Teste chaque module individuellement pour identifier d'o√π vient le probl√®me des groupes manquants
    </div>

    <button onclick="runDiagnostic()" style="background: #ff4444;">ü©∫ Diagnostic Complet</button>
    <button onclick="testDefaultTargets()">üìã Test DEFAULT_MACRO_TARGETS</button>
    <button onclick="testMarketRegimes()">üåä Test Market Regimes</button>
    <button onclick="testProposeTargets()">üéØ Test proposeTargets</button>
    <button onclick="clearResults()">üóëÔ∏è Clear</button>
    
    <div id="results"></div>

    <script type="module">
        // Import avec gestion d'erreur
        let targetsCoordinator, marketRegimes;
        
        try {
            const tc = await import('../../static/modules/targets-coordinator.js');
            targetsCoordinator = tc;
            
            const mr = await import('../../static/modules/market-regimes.js');
            marketRegimes = mr;
            
            log('‚úÖ Modules import√©s avec succ√®s', 'success');
        } catch (error) {
            log(`‚ùå Erreur import: ${error.message}`, 'error');
        }

        const ALL_EXPECTED_GROUPS = ['BTC', 'ETH', 'Stablecoins', 'SOL', 'L1/L0 majors', 'L2/Scaling', 'DeFi', 'AI/Data', 'Gaming/NFT', 'Memecoins', 'Others'];

        function log(message, type = 'info') {
            const div = document.createElement('div');
            div.className = `test-result ${type}`;
            div.innerHTML = `<strong>${new Date().toLocaleTimeString()}</strong> - ${message}`;
            document.getElementById('results').appendChild(div);
            console.log(message);
        }

        function createGroupTable(data, title) {
            let html = `<div class="test-result info"><h3>${title}</h3>`;
            html += '<table><tr><th>Groupe</th><th>Allocation (%)</th><th>Status</th></tr>';
            
            let foundGroups = 0;
            let totalAllocation = 0;
            let missingGroups = [];
            
            ALL_EXPECTED_GROUPS.forEach(group => {
                const allocation = data[group];
                const isPresent = allocation !== undefined;
                const hasValue = allocation > 0;
                
                if (isPresent) foundGroups++;
                else missingGroups.push(group);
                
                totalAllocation += allocation || 0;
                
                const rowClass = !isPresent ? 'group-zero' : (hasValue ? 'group-present' : '');
                const status = !isPresent ? '‚ùå MANQUANT' : (hasValue ? '‚úÖ Pr√©sent' : '‚ö†Ô∏è Z√©ro');
                
                html += `<tr class="${rowClass}"><td>${group}</td><td>${isPresent ? (allocation || 0).toFixed(2) : 'N/A'}</td><td>${status}</td></tr>`;
            });
            
            html += '</table>';
            html += `<div><strong>Groupes trouv√©s:</strong> ${foundGroups}/11</div>`;
            html += `<div><strong>Total allocation:</strong> ${totalAllocation.toFixed(1)}%</div>`;
            
            if (missingGroups.length > 0) {
                html += `<div style="color: #ff4444;"><strong>‚ö†Ô∏è Groupes manquants:</strong> ${missingGroups.join(', ')}</div>`;
            }
            
            html += '</div>';
            return html;
        }

        window.testDefaultTargets = function() {
            if (!targetsCoordinator) {
                log('‚ùå Module targets-coordinator non disponible', 'error');
                return;
            }

            try {
                const defaultTargets = targetsCoordinator.DEFAULT_MACRO_TARGETS;
                document.getElementById('results').innerHTML += createGroupTable(defaultTargets, 'üìã DEFAULT_MACRO_TARGETS');
                
                // Test normalization
                const normalized = targetsCoordinator.normalizeTargets(defaultTargets);
                document.getElementById('results').innerHTML += createGroupTable(normalized, 'üîß Apr√®s normalizeTargets()');
                
                log('‚úÖ Test DEFAULT_MACRO_TARGETS termin√©', 'success');
            } catch (error) {
                log(`‚ùå Erreur test DEFAULT_MACRO_TARGETS: ${error.message}`, 'error');
            }
        };

        window.testMarketRegimes = function() {
            if (!marketRegimes) {
                log('‚ùå Module market-regimes non disponible', 'error');
                return;
            }

            try {
                // Test allocation risky budget
                const regime = marketRegimes.getMarketRegime(55); // Score expansion
                const riskyAllocation = marketRegimes.allocateRiskyBudget(70, regime); // 70% risky
                
                document.getElementById('results').innerHTML += createGroupTable(riskyAllocation, 'üåä allocateRiskyBudget (70% risky)');
                
                log('‚úÖ Test Market Regimes termin√©', 'success');
            } catch (error) {
                log(`‚ùå Erreur test Market Regimes: ${error.message}`, 'error');
            }
        };

        window.testProposeTargets = function() {
            if (!targetsCoordinator) {
                log('‚ùå Module targets-coordinator non disponible', 'error');
                return;
            }

            try {
                // Test diff√©rents modes
                const modes = [
                    { mode: 'macro', options: {} },
                    { mode: 'ccs', options: { ccsScore: 65 } },
                    { mode: 'blend', options: { ccsScore: 65 } }
                ];
                
                modes.forEach(({ mode, options }) => {
                    try {
                        const result = targetsCoordinator.proposeTargets(mode, options);
                        document.getElementById('results').innerHTML += createGroupTable(result.targets, `üéØ proposeTargets('${mode}')`);
                        log(`‚úÖ proposeTargets('${mode}') - Strat√©gie: ${result.strategy}`, 'info');
                    } catch (error) {
                        log(`‚ùå Erreur proposeTargets('${mode}'): ${error.message}`, 'error');
                    }
                });
                
            } catch (error) {
                log(`‚ùå Erreur test proposeTargets: ${error.message}`, 'error');
            }
        };

        window.runDiagnostic = async function() {
            log('ü©∫ Lancement diagnostic complet...', 'info');
            document.getElementById('results').innerHTML = '';
            
            // Test 1: Modules loading
            log('üîç Test 1: Import des modules', 'info');
            if (!targetsCoordinator || !marketRegimes) {
                log('‚ùå PROBL√àME: Modules non charg√©s correctement', 'error');
                return;
            }
            log('‚úÖ Modules charg√©s OK', 'success');
            
            await new Promise(resolve => setTimeout(resolve, 500));
            
            // Test 2: DEFAULT_MACRO_TARGETS
            log('üîç Test 2: DEFAULT_MACRO_TARGETS', 'info');
            testDefaultTargets();
            
            await new Promise(resolve => setTimeout(resolve, 500));
            
            // Test 3: Market Regimes
            log('üîç Test 3: Market Regimes allocation', 'info');
            testMarketRegimes();
            
            await new Promise(resolve => setTimeout(resolve, 500));
            
            // Test 4: proposeTargets
            log('üîç Test 4: proposeTargets function', 'info');
            testProposeTargets();
            
            log('üéâ Diagnostic complet termin√©!', 'success');
        };

        window.clearResults = function() {
            document.getElementById('results').innerHTML = '';
        };

        // Auto-start basic diagnostic
        setTimeout(() => {
            log('üîÑ Auto-diagnostic au chargement...', 'info');
            if (targetsCoordinator && marketRegimes) {
                testDefaultTargets();
            }
        }, 1000);
    </script>
</body>
</html>