<!DOCTYPE html>
<html>
<head>
    <title>üéØ Final CCS Diagnosis - Complete Pipeline Test</title>
    <style>
        body { font-family: monospace; padding: 20px; background: #f5f5f5; }
        .step { background: white; padding: 20px; margin: 15px 0; border-radius: 8px; border-left: 4px solid #3b82f6; }
        .success { border-left-color: #22c55e; }
        .warning { border-left-color: #f59e0b; }
        .error { border-left-color: #ef4444; }
        table { width: 100%; border-collapse: collapse; margin: 10px 0; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background: #f0f0f0; }
        .highlight { background: #fef3c7; font-weight: bold; }
        button { padding: 10px 20px; margin: 5px; border: none; border-radius: 4px; cursor: pointer; background: #3b82f6; color: white; }
    </style>
</head>
<body>
    <h1>üéØ Final CCS Diagnosis - Complete Pipeline Test</h1>
    <p>Test complet du pipeline Risk Dashboard ‚Üí localStorage ‚Üí Rebalance</p>
    
    <button onclick="runCompleteTest()">üöÄ Lancer le test complet</button>
    <button onclick="clearAll()">üßπ Tout nettoyer</button>
    
    <div id="results"></div>
    
    <script type="module">
        import { proposeTargets, generateCCSTargets, applyCycleMultipliers, normalizeTargets, applyTargets, DEFAULT_MACRO_TARGETS } from './static/modules/targets-coordinator.js';
        import { store } from './static/core/risk-dashboard-store.js';
        
        window.runCompleteTest = async function() {
            const resultsDiv = document.getElementById('results');
            let html = '';
            
            try {
                // Valeurs observ√©es par l'utilisateur
                const userObservedInRisk = {
                    'BTC': 32.1,
                    'ETH': 24.2,
                    'Stablecoins': 21.3,
                    'L1/L0 majors': 11.1,
                    'L2/Scaling': 5.6,
                    'DeFi': 3.5,
                    'AI/Data': 2.2,
                    'Others': 0.0
                };
                
                const userObservedInRebalance = {
                    'BTC': 29.4,
                    'ETH': 19.6,
                    'Stablecoins': 29.4,
                    'L1/L0 majors': 7.8,
                    'L2/Scaling': 3.9,
                    'DeFi': 7.8,
                    'AI/Data': 2.0,
                    'Others': 0.0
                };
                
                html += '<div class="step"><h2>üìä √âtape 1: Test generateCCSTargets direct</h2>';
                
                // Test direct du generateCCSTargets
                const directCCS72 = generateCCSTargets(72);
                html += '<table><tr><th>Asset</th><th>CCS(72) Direct</th><th>Risk Observ√©</th><th>Rebalance Observ√©</th></tr>';
                
                Object.keys(userObservedInRisk).forEach(asset => {
                    const direct = directCCS72[asset];
                    const riskObs = userObservedInRisk[asset];
                    const rebalObs = userObservedInRebalance[asset];
                    
                    html += `<tr>
                        <td>${asset}</td>
                        <td>${direct.toFixed(1)}%</td>
                        <td class="${Math.abs(direct - riskObs) < 0.1 ? 'success' : ''}">${riskObs}%</td>
                        <td class="${Math.abs(direct - rebalObs) < 0.1 ? 'success' : ''}">${rebalObs}%</td>
                    </tr>`;
                });
                html += '</table>';
                
                // Analyser quel pattern correspond aux valeurs Rebalance
                const ccsLow = generateCCSTargets(40); // Devrait donner ~30% BTC
                html += '<h3>üîç Test CCS score plus bas (40):</h3>';
                html += `<p>CCS(40) BTC: ${ccsLow.BTC.toFixed(1)}% (cf. Rebalance observ√©: ${userObservedInRebalance.BTC}%)</p>`;
                
                html += '</div>';
                
                // √âtape 2: Simuler le store state et tester proposeTargets
                html += '<div class="step"><h2>‚öôÔ∏è √âtape 2: Simulation compl√®te avec store</h2>';
                
                // Test avec diff√©rentes configurations de store
                const configs = [
                    { name: 'Config 1: CCS=72, blendedCCS=72, no multipliers', ccs: 72, blendedCCS: 72, multipliers: null },
                    { name: 'Config 2: CCS=40, blendedCCS=40, no multipliers', ccs: 40, blendedCCS: 40, multipliers: null },
                    { name: 'Config 3: CCS=72, blendedCCS=72, avec multipliers calcul√©s', ccs: 72, blendedCCS: 72, multipliers: {
                        'BTC': 0.845, 'ETH': 0.864, 'Stablecoins': 1.42, 'L1/L0 majors': 1.01, 'L2/Scaling': 0.933, 'DeFi': 1.17, 'AI/Data': 1.1, 'Others': 1.0
                    }},
                    { name: 'Config 4: CCS=72, blendedCCS=null (fallback)', ccs: 72, blendedCCS: null, multipliers: null }
                ];
                
                const originalGet = store.get;
                const originalSnapshot = store.snapshot;
                
                for (const config of configs) {
                    store.get = function(path) {
                        const mockData = {
                            'ccs.score': config.ccs,
                            'cycle.ccsStar': config.blendedCCS,
                            'cycle.multipliers': config.multipliers,
                            'cycle.weight': 0.3,
                            'cycle.months': 12
                        };
                        return mockData[path];
                    };
                    
                    store.snapshot = function() {
                        return {
                            ccs: { score: config.ccs },
                            cycle: { 
                                ccsStar: config.blendedCCS, 
                                multipliers: config.multipliers, 
                                weight: 0.3,
                                months: 12
                            }
                        };
                    };
                    
                    const proposal = proposeTargets('blend');
                    
                    html += `<h3>${config.name}</h3>`;
                    html += `<p><strong>Strategy:</strong> ${proposal.strategy}</p>`;
                    html += '<table><tr><th>Asset</th><th>Result</th><th>Risk Obs</th><th>Reb Obs</th><th>Match Risk?</th><th>Match Reb?</th></tr>';
                    
                    Object.keys(userObservedInRisk).forEach(asset => {
                        const result = proposal.targets[asset];
                        const riskObs = userObservedInRisk[asset];
                        const rebalObs = userObservedInRebalance[asset];
                        
                        const matchRisk = Math.abs(result - riskObs) < 0.1;
                        const matchReb = Math.abs(result - rebalObs) < 0.1;
                        
                        html += `<tr>
                            <td>${asset}</td>
                            <td>${result.toFixed(1)}%</td>
                            <td>${riskObs}%</td>
                            <td>${rebalObs}%</td>
                            <td class="${matchRisk ? 'success' : ''}">${matchRisk ? '‚úÖ' : '‚ùå'}</td>
                            <td class="${matchReb ? 'success' : ''}">${matchReb ? '‚úÖ' : '‚ùå'}</td>
                        </tr>`;
                    });
                    html += '</table>';
                    
                    // Si on trouve une config qui match, on s'arr√™te
                    const btcMatch = Math.abs(proposal.targets.BTC - userObservedInRisk.BTC) < 0.1;
                    if (btcMatch) {
                        html += '<div class="success">üéØ <strong>Configuration qui produit les valeurs Risk Dashboard trouv√©e!</strong></div>';
                        break;
                    }
                    
                    const rebalMatch = Math.abs(proposal.targets.BTC - userObservedInRebalance.BTC) < 0.1;
                    if (rebalMatch) {
                        html += '<div class="warning">‚ö†Ô∏è <strong>Configuration qui produit les valeurs Rebalance trouv√©e!</strong></div>';
                    }
                }
                
                // Restore store
                store.get = originalGet;
                store.snapshot = originalSnapshot;
                
                html += '</div>';
                
                // √âtape 3: Test du processus de sauvegarde
                html += '<div class="step"><h2>üíæ √âtape 3: Test processus de sauvegarde</h2>';
                html += '<p>Test de la fonction applyTargets avec les valeurs Risk Dashboard</p>';
                
                // Cr√©er un proposal fictif avec les valeurs observ√©es
                const mockProposal = {
                    targets: { ...userObservedInRisk, model_version: 'test-v1' },
                    strategy: 'Blended CCS* (72)',
                    mode: 'blend',
                    confidence: 0.8,
                    timestamp: new Date().toISOString()
                };
                
                // Clear localStorage first
                localStorage.removeItem('last_targets');
                
                // Test applyTargets
                await applyTargets(mockProposal);
                
                // V√©rifier ce qui a √©t√© sauvegard√©
                const saved = localStorage.getItem('last_targets');
                const savedData = saved ? JSON.parse(saved) : null;
                
                if (savedData) {
                    html += '<h3>‚úÖ Donn√©es sauvegard√©es avec succ√®s</h3>';
                    html += '<table><tr><th>Asset</th><th>Avant Save</th><th>Apr√®s Save</th><th>Identique?</th></tr>';
                    
                    Object.keys(userObservedInRisk).forEach(asset => {
                        const before = mockProposal.targets[asset];
                        const after = savedData.targets[asset];
                        const identical = Math.abs(before - after) < 0.001;
                        
                        html += `<tr>
                            <td>${asset}</td>
                            <td>${before.toFixed(3)}%</td>
                            <td class="${identical ? 'success' : 'error'}">${after.toFixed(3)}%</td>
                            <td>${identical ? '‚úÖ' : '‚ùå'}</td>
                        </tr>`;
                    });
                    html += '</table>';
                    
                    html += `<p><strong>Strategy sauvegard√©e:</strong> ${savedData.strategy}</p>`;
                    html += `<p><strong>Source:</strong> ${savedData.source}</p>`;
                } else {
                    html += '<div class="error">‚ùå Aucune donn√©e sauvegard√©e</div>';
                }
                
                html += '</div>';
                
            } catch (error) {
                html += `<div class="step error"><h2>‚ùå Erreur</h2><pre>${error.message}\\n${error.stack}</pre></div>`;
            }
            
            resultsDiv.innerHTML = html;
        };
        
        window.clearAll = function() {
            localStorage.removeItem('last_targets');
            localStorage.removeItem('test_targets');
            document.getElementById('results').innerHTML = '<div class="step">üßπ Toutes les donn√©es de test ont √©t√© effac√©es</div>';
        };
        
    </script>
</body>
</html>