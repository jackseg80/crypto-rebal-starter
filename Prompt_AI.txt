PROMPT AGENT VSCODE (Claude Code / ChatGPT) - Crypto Rebal Starter - TEXTE PUR FUSION

LANGUE: Francais
REPO: https://github.com/jackseg80/crypto-rebal-starter/

===============================================================================
0) MODE D'EMPLOI (SPECIFIQUE AGENT VSCODE)
- Ce fichier est le brief unique pour piloter l'agent dans VSCode (Claude Code ou ChatGPT VSCode).
- Lire ENTIEREMENT puis ouvrir les fichiers cites via la recherche du workspace.
- Toujours proceder par iterations courtes: PLAN -> PETITS PATCHES -> DIFFS -> TESTS -> COMMIT.
- Travailler sur une BRANCHE dediee par tache (ex: feat/taxonomy-unify). Commits atomiques et messages clairs.
- NE PAS reformater massivement le repo ni changer les conventions sans demande explicite.
- Respecter les invariants metiers de la section 5.
- Documenter toute decision non triviale dans README (section "Decisions d'architecture").

===============================================================================
1) CONTEXTE GENERAL (PROJET)
- Probleme: portefeuille crypto disperse (exchanges, wallets, DeFi) difficile a reequilibrer (aliases incoherents, tailles minimales d'ordre, prix heterogenes).
- Objectif V1 (MVP robuste): centraliser les soldes via CoinTracking (CSV/API), normaliser, definir cibles d'allocation par groupes, generer un plan d'achats/ventes, exporter CSV, gerer la taxonomie (groupes + aliases), UI HTML autonome pour piloter l'API.
- Objectif V2: execution semi/auto: d'abord DRY-RUN (journal d'ordres pour 1 exchange), puis connecteurs d'execution reelle (hors V1).
- Public cible: utilisateurs avec beaucoup de coins, multi-plateformes, qui veulent un outil fiable, rapide et transparent.

===============================================================================
2) VISION PRODUIT (V1 -> V2)
- V1 (MVP):
  - API FastAPI pour soldes, plan, export CSV, taxonomie.
  - UI HTML autonome (static/rebalance.html) sans framework lourd.
  - Qualite: perfs, coherence monetaire (somme USD = 0), logs, tests, Docker.
- V2 (Execution):
  - Dry-run pour 1 exchange (ex: Binance) avec journal d'ordres detailles.
  - Plus tard: execution reelle (cles API), orchestration par "lieu" (exchange/wallet).

===============================================================================
3) PERIMETRE ET PRINCIPES
- Source soldes: CoinTracking (CSV ou API getBalance) avec fallback + cache.
- Prix: stables=1.0; sinon prix implicites CoinTracking si dispo; sinon providers externes (fichier local, CoinGecko, Binance) avec cache.
- Taxonomie: mapping alias/symbol -> group (ex: TBTC/WBTC->BTC; WSTETH/RETH->ETH; JUPSOL/JITOSOL->SOL).
- Plan: actions buy/sell par groupe, respect de min_trade_usd, somme(actions.usd)=0, price_used et est_quantity quand possible.
- Securite: cles en .env; CORS par env; CoinTracking en read-only; execution reelle hors V1.

===============================================================================
4) REPO MAP (MINIMAL)
- main.py: API FastAPI.
  Routes clefs:
    GET /healthz
    GET /debug/ctapi
    GET /balances/current
    GET /portfolio/groups
    POST /rebalance/plan
    POST /rebalance/plan.csv
  Fonctions utiles (extraits): get_prices_usd, _try_fetch_prices, _enrich_actions_with_prices, _to_csv, _parse_min_usd
- cointracking_api.py: client CoinTracking (HMAC). Fonctions: _post_api, _post_api_cached, _extract_rows_from_getBalance, _extract_rows_from_groupedBalance, _debug_probe
- cointracking.py: lecture CSV CoinTracking + aggregation. Fonctions: get_current_balances_from_csv, _aggregate_by_symbol, _guess_value_usd, get_demo_balances
- pricing.py: providers de prix (file, coingecko, binance). Fonctions: get_price_usd, get_prices_usd, _from_file, _from_binance, _from_coingecko (stables=1.0, cache TTL)
- taxonomy.py: source de verite taxonomie. Fonctions: load, save, group_for_alias, to_dict (schema: groups_order + aliases)
- taxonomy_endpoints.py: endpoints admin taxonomie (a realigner sur le MEME fichier que taxonomy.py). Fonctions: get_taxonomy, upsert_aliases, delete_alias, bulk_aliases
- rebalance.py: moteur de plan. Fonctions: plan_rebalance, _normalize_targets, _targets_usd, _sell_actions_for_group, _buy_actions_for_group, allocate_proportional, pick_group_for_alias
- static/rebalance.html: UI autonome (selection source, min_usd, prix local/auto, donuts Actuel/Cible, table d'actions, unknown_aliases, export CSV, statut/temps)
- Docs: README.md (demarrage, endpoints, exemples), TODO.md (backlog), rapport_crypto_dashboard_v70_2.html (archive visuelle)
- Exemples CSV: "CoinTracking - Current Balance.csv", "CoinTracking - Balance by Exchange.csv"

===============================================================================
5) ENDPOINTS ET INVARIANTS METIERS
- Endpoints publics V1:
  GET /balances/current?source=cointracking_api|cointracking|stub&min_usd=...
  GET /portfolio/groups?source=...&min_usd=...
  POST /rebalance/plan?source=...&min_usd=...   (payload: targets, primary_symbols, sub_allocation, min_trade_usd)
  POST /rebalance/plan.csv?...                  (colonnes: group,alias,symbol,action,usd,est_quantity,price_used)
- Invariants a respecter partout:
  - Somme(actions.usd) = 0 (achats et ventes s'equilibrent).
  - Aucune action avec |usd| < min_trade_usd.
  - price_used et est_quantity presentes si possible (stables=1.0; sinon implicite CT; sinon provider).
  - Badge meta.source_used coherent avec la source reelle (CSV, API, stub).

===============================================================================
6) DEMARRAGE RAPIDE (DEV)
- Dependances: pip install -r requirements.txt
- .env (exemples):
  CT_API_KEY=...
  CT_API_SECRET=...
  CORS_ORIGINS=http://localhost:8000,http://127.0.0.1:8000
  PRICE_PROVIDER_ORDER=file,coingecko,binance
- Lancer l'API: uvicorn main:app --reload --port 8000
- UI locale: ouvrir static/rebalance.html dans le navigateur (champ URL API si present)
- Tests rapides:
  GET /healthz
  GET /balances/current?source=cointracking_api&min_usd=1
  POST /rebalance/plan?source=cointracking_api&min_usd=1  -> verifier somme USD = 0
  POST /rebalance/plan.csv?... -> verifier colonnes

===============================================================================
7) RESULTATS ATTENDUS (CE QUI EST VOULU)
- Plan fiable (JSON/CSV):
  - Somme(actions.usd)=0; aucune action |usd|<min_trade_usd
  - price_used/est_quantity renseignes quand possible
- Taxonomie unifiee:
  - Un seul fichier JSON (ex: data/taxonomy.json) pour groups_order et aliases
  - Endpoints CRUD + GET /taxonomy/unknown_aliases
  - Reload a chaud sans redemarrer l'API
- UI complete:
  - Generation rapide (afficher ms), badge source_used, export CSV post-plan
  - Unknown aliases gerables en bulk et unitaire
  - Vue par lieu: synthese par exchange/wallet et pre-plan par lieu
- Ops/Qualite:
  - Tests 70-80% coeur, logs clairs, erreurs JSON utiles
  - Dockerfile + compose OK, README a jour

===============================================================================
8) BACKLOG PRIO (A FAIRE MAINTENANT) + DoD
Tache A - Unifier la taxonomie (persistance unique + reload a chaud)
- Actions:
  - Aligner taxonomy_endpoints.py pour utiliser le MEME fichier que taxonomy.py: data/taxonomy.json {groups_order:[], aliases:{}}
  - Ajouter GET /taxonomy/unknown_aliases (scan soldes vs mapping)
  - Reload a chaud en memoire apres POST/DELETE
- DoD:
  - Nouveau mapping ne figure plus en unknown_aliases au prochain /rebalance/plan
  - Un SEUL fichier persistant pour taxonomie

Tache B - Alias Manager (UI dediee)
- Actions:
  - Creer static/alias_manager.html (HTML/JS vanilla, pas de framework lourd)
  - Lister unknown_aliases; ajout/suppression/bulk via endpoints; recherche rapide; feedback clair
- DoD:
  - Creation/mise a jour de 10+ aliases en une passe; rafraichissement sans restart

Tache C - Vue "Par lieu" (exchange/wallet)
- Actions:
  - Backend: GET /portfolio/locations -> {location,total_usd,items:[{symbol,alias,value_usd}]}
  - UI: onglet/section, totaux coherents avec min_usd
- DoD:
  - Somme par lieu = somme des balances filtrees; UX lisible

Tache D - Execution (phase 1: dry-run)
- Actions:
  - POST /execute/dry_run: input = actions (JSON/CSV) + mapping location->exchange + min_trade_usd
  - Sortie: journal clair (pair, side, qty, source du prix, arrondis, tailles min)
- DoD:
  - Aucun appel reseau aux exchanges; log deterministe

Tache E - Qualite (tests, logs, erreurs, Docker)
- Actions:
  - Tests unitaires coeur (rebalance, taxonomy, pricing) + integration endpoints (fixtures CSV)
  - Logging: INFO (source_used, items_count, somme USD), WARN/ERROR CT/pricing
  - Erreurs JSON actionnables (invalid payload, alias manquant, provider indisponible)
  - Dockerfile + docker-compose (service API, volume data/, support .env)
  - README enrichi (captures UI, exemples cURL/PS, Alias Manager, Vue par lieu)

===============================================================================
9) WORKFLOW DE TRAVAIL (AGENT)
- Etape 1: lire README.md et TODO.md; proposer un plan de commits (liste courte, ordonnee)
- Etape 2: creer branche feat/taxonomy-unify; modifier taxonomy_endpoints.py + taxonomy.py; ajouter unknown_aliases; tests rapides
- Etape 3: livrer patchs PETITS et ATOMIQUES; afficher DIFFS; demander confirmation; commit
- Etape 4: ajouter static/alias_manager.html; cabler endpoints; test UI
- Etape 5: implementer /portfolio/locations + section UI
- Etape 6: implementer /execute/dry_run (sans reseau)
- Etape 7: tests, logs, erreurs, Docker, README
- Toujours: pas de refactor massif non demande; garder le scope minimal et controle

===============================================================================
10) CHECKLISTS
- Code:
  - Pas de side-effects surprises; fonctions pures pour logique
  - Caches TTL respectes (balances, prices)
  - Noms clairs; pas d'import circulaire
- Donnees & plan:
  - Somme(actions.usd)=0; min_trade_usd respecte
  - Stables=1.0; price_used/est_quantity presentes si possible
  - meta.source_used correct
- UI:
  - "Telecharger CSV" seulement apres plan OK
  - Unknown aliases: ajout unitaire + bulk OK
  - Vue par lieu: totaux coherents
- Ops:
  - .env utilise; aucun secret commite
  - Docker build/run OK
  - README exact et a jour

===============================================================================
11) VARIABLES & COMMANDES
- .env (exemples):
  CT_API_KEY=...
  CT_API_SECRET=...
  CORS_ORIGINS=http://localhost:8000,http://127.0.0.1:8000
  PRICE_PROVIDER_ORDER=file,coingecko,binance
- API: uvicorn main:app --reload --port 8000
- Tests rapides:
  GET /healthz
  GET /balances/current?source=cointracking_api&min_usd=1
  POST /rebalance/plan?source=cointracking_api&min_usd=1
  POST /rebalance/plan.csv?...

===============================================================================
12) GARDE-FOUS ET STYLE
- Pas d'execution reelle en V1 (dry-run uniquement).
- Secrets uniquement dans .env (ne jamais committer).
- Conserver la terminologie: "coin", "wallet", "exchange".
- Ne pas changer formats ou conventions sans accord explicite.
- Documenter les decisions et compromis (README -> Decisions).

FIN DU PROMPT