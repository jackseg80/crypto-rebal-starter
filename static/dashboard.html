<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>üìä Dashboard - Crypto Rebalancer</title>
    <link rel="stylesheet" href="shared-theme.css">
    <link rel="stylesheet" href="theme-compat.css">
    <script type="module" src="components/nav.js"></script>
    <script type="module" src="components/tooltips.js"></script>
    <script type="module">
        import { initDeepLinks } from './components/deep-links.js';
        // Ancres pour dashboard.html : #overview #crypto #bourse #banque #divers #fx
        initDeepLinks({
            'overview': 'Vue d\'ensemble',
            'crypto': 'Crypto Portfolio',
            'bourse': 'Actions & ETF',
            'banque': 'Comptes bancaires',
            'divers': 'Actifs divers',
            'fx': 'Devises & Changes'
        });
    </script>

    <script src="debug-logger.js"></script>
    <script src="input-validator.js"></script>
    <script src="performance-optimizer.js"></script>
    <script src="global-config.js"></script>
    <script src="appearance.js"></script>
    <script type="module">
        // INTELLIGENT GLOBAL INSIGHT - Using sophisticated unified intelligence
        import { getUnifiedState, deriveRecommendations } from './core/unified-insights-v2.js';
        import { store } from './core/risk-dashboard-store.js';
        
        const colorForScore = (s) => s>70?'var(--danger)':s>=40?'var(--warning)':'var(--success)';
        
        async function refreshGI(){
            try {
                console.debug('üß† Refreshing Global Insight with intelligent analysis...');
                
                // Use sophisticated unified intelligence
                const unifiedState = await getUnifiedState();
                console.debug('‚úÖ Unified state loaded:', {
                    decision_score: unifiedState.decision?.score,
                    cycle_score: unifiedState.cycle?.score,
                    onchain_score: unifiedState.onchain?.score,
                    risk_score: unifiedState.risk?.score
                });
                const recommendations = deriveRecommendations(unifiedState);
                
                // Update Decision Index with confidence
                const scoreEl = document.getElementById('gi-score');
                if (scoreEl) {
                    scoreEl.textContent = unifiedState.decision.score;
                    scoreEl.style.color = colorForScore(unifiedState.decision.score);
                    
                    // Add confidence tooltip if available
                    if (unifiedState.decision.confidence) {
                        scoreEl.title = `Confiance: ${Math.round(unifiedState.decision.confidence * 100)}% | ${unifiedState.decision.reasoning || 'Calcul intelligent'}`;
                    }
                }
                
                // Update component scores with enhanced data
                const cycleEl = document.getElementById('gi-cycle');
                if (cycleEl) {
                    const cycleScore = unifiedState.cycle?.score ?? '--';
                    const cyclePhase = unifiedState.cycle?.phase?.phase;
                    cycleEl.textContent = cycleScore;
                    cycleEl.title = cyclePhase ? `Phase: ${cyclePhase.replace('_', ' ')} | Confiance: ${Math.round((unifiedState.cycle?.confidence || 0) * 100)}%` : '';
                }
                
                const onchainEl = document.getElementById('gi-onchain');
                if (onchainEl) {
                    let onchainScore = unifiedState.onchain?.score;
                    if (onchainScore == null) {
                        const user = localStorage.getItem('activeUser') || 'demo';
                        const lsOn = Number(localStorage.getItem(`risk_score_onchain:${user}`) || localStorage.getItem('risk_score_onchain'));
                        if (Number.isFinite(lsOn)) onchainScore = Math.round(lsOn);
                    }
                    onchainEl.textContent = (onchainScore != null) ? onchainScore : '--';
                    if (unifiedState.onchain?.criticalCount > 0) {
                        onchainEl.title = `${unifiedState.onchain.criticalCount} indicateur(s) critique(s) d√©tect√©(s)`;
                        onchainEl.style.fontWeight = '700';
                    }
                }
                
                const riskEl = document.getElementById('gi-risk');
                if (riskEl) {
                    let riskScore = unifiedState.risk?.score;
                    if (riskScore == null) {
                        const user = localStorage.getItem('activeUser') || 'demo';
                        const lsRisk = Number(localStorage.getItem(`risk_score_risk:${user}`) || localStorage.getItem('risk_score_risk'));
                        if (Number.isFinite(lsRisk)) riskScore = Math.round(lsRisk);
                    }
                    riskEl.textContent = (riskScore != null) ? riskScore : '--';
                    if (unifiedState.risk?.budget?.percentages?.stables) {
                        riskEl.title = `Budget recommand√© - Stables: ${unifiedState.risk.budget.percentages.stables}%`;
                    }
                }
                
                // INTELLIGENT RECOMMENDATIONS from sophisticated modules
                const recoEl = document.getElementById('gi-reco');
                if (recoEl) {
                    if (recommendations.length > 0) {
                        const topReco = recommendations[0];
                        const urgencyIcon = topReco.priority === 'critical' ? 'üö®' : topReco.priority === 'high' ? '‚ö†Ô∏è' : topReco.priority === 'medium' ? 'üí°' : '‚ÑπÔ∏è';
                        recoEl.innerHTML = `${urgencyIcon} ${topReco.title}`;
                        recoEl.title = `${topReco.reason} | Source: ${topReco.source || 'Intelligence unifi√©e'}`;
                        
                        // Color based on priority
                        const priorityColors = {
                            'critical': 'var(--danger)',
                            'high': 'var(--danger)', 
                            'medium': 'var(--warning)',
                            'low': 'var(--info)'
                        };
                        recoEl.style.color = priorityColors[topReco.priority] || 'var(--theme-text)';
                    } else {
                        recoEl.innerHTML = 'üßò Aucune action urgente';
                        recoEl.style.color = 'var(--success)';
                        recoEl.title = 'Tous les modules sont en accord - situation stable';
                    }
                }
                
                console.debug('‚úÖ Global Insight refreshed with:', {
                    decision_score: unifiedState.decision.score,
                    confidence: unifiedState.decision.confidence,
                    recommendations_count: recommendations.length,
                    top_recommendation: recommendations[0]?.title
                });

                // Update the meta badge with governance data
                updateGlobalInsightMeta();

            } catch (error) {
                console.warn('‚ö†Ô∏è Global Insight fallback to simple calculation:', error);
                console.debug('Error details:', error.stack || error);
                
                // Fallback to simple calculation if intelligent system fails
                const st = store.snapshot();
                const blended = st.scores?.blended ?? null;
                const cycle = Math.round(st.cycle?.ccsStar ?? st.cycle?.score ?? 0);
                const onch = st.scores?.onchain ?? null;
                const risk = st.scores?.risk ?? null;
                const score = blended!=null ? Math.round(blended) : Math.round(((cycle||50)*0.5)+((onch??50)*0.3)+((100-(risk??50))*0.2));
                
                const el = document.getElementById('gi-score');
                if (el){ el.textContent = score; el.style.color = colorForScore(score); }
                
                const ec = document.getElementById('gi-cycle'); if (ec) ec.textContent = cycle||'--';
                const eo = document.getElementById('gi-onchain'); if (eo) eo.textContent = onch!=null?Math.round(onch):'--';
                const er = document.getElementById('gi-risk'); if (er) er.textContent = risk!=null?Math.round(risk):'--';
                
                const reco = document.getElementById('gi-reco');
                if (reco){
                    reco.textContent = score>=70 ? '‚ö†Ô∏è All√©ger 10‚Äì20%' : score<=35 ? 'üü¢ DCA prudent' : '‚è∏Ô∏è Neutre / Attente';
                    reco.title = 'Recommandation basique (syst√®me intelligent non disponible)';
                }

                // Update meta badge even in fallback
                updateGlobalInsightMeta();
            }
        }
        
        // SMART LOADING - Load data directly if not available in store
        async function loadUnifiedDataForDashboard() {
            try {
                console.log('üîÑ Loading unified data for dashboard...');
                
                // Import and run the same cache-intelligent loader from analytics-unified
                const { getCurrentCycleMonths, cycleScoreFromMonths, getCyclePhase } = await import('./modules/cycle-navigator.js');
                
                // 1. Cycle data (quick calculation)
                const c = getCurrentCycleMonths();
                const cycleScore = Math.round(cycleScoreFromMonths(c.months));
                const phase = getCyclePhase(c.months);
                store.set('cycle.months', c.months);
                store.set('cycle.score', cycleScore);
                store.set('cycle.phase', phase);
                // Hydrate governance state to prefer backend Decision Engine
                try {
                    await store.syncGovernanceState();
                    await store.syncMLSignals();
                } catch {}
                console.log('‚úÖ Cycle data loaded for dashboard');
                
                // 2. Try to get cached scores from localStorage (from analytics-unified cache)
                const getCachedScore = (key) => {
                    try {
                        const user = localStorage.getItem('activeUser') || 'demo';
                        const ds = (window.globalConfig && window.globalConfig.get('data_source')) || 'unknown';
                        const fullKey = `${key}_${user}_${ds}`;
                        const cached = localStorage.getItem(fullKey) || localStorage.getItem(key);
                        if (!cached) return null;
                        const data = JSON.parse(cached);
                        const age = Date.now() - data.timestamp;
                        // Use cache if less than 15 minutes old
                        if (age < 15 * 60 * 1000) {
                            return data.data;
                        }
                    } catch {}
                    return null;
                };
                
                // Try cached on-chain data
                const cachedOnchain = getCachedScore('analytics_unified_onchain');
                if (cachedOnchain && typeof cachedOnchain.score === 'number') {
                    store.set('scores.onchain', cachedOnchain.score);
                    store.set('scores.onchain_metadata', cachedOnchain.metadata);
                    console.log('‚úÖ On-chain data loaded from cache for dashboard');
                }
                
                // Try cached risk data
                const cachedRisk = getCachedScore('analytics_unified_risk');
                if (cachedRisk && cachedRisk.risk_metrics?.risk_score) {
                    store.set('scores.risk', cachedRisk.risk_metrics.risk_score);
                    store.set('risk.risk_metrics', cachedRisk.risk_metrics); // Full risk metrics for sophisticated analysis
                    console.log('‚úÖ Risk data loaded from cache for dashboard');
                }
                
                // Try cached blended data
                const cachedBlended = getCachedScore('analytics_unified_blended');
                if (cachedBlended && typeof cachedBlended.score === 'number') {
                    store.set('scores.blended', cachedBlended.score);
                    console.log('‚úÖ Blended score loaded from cache for dashboard');
                } else {
                    // Calculate blended if we have component scores
                    const state = store.snapshot();
                    const cycleScore = state.cycle?.score ?? 50;
                    const onchainScore = state.scores?.onchain ?? 50;
                    const riskScore = state.scores?.risk ?? 50;
                    const blended = (cycleScore * 0.50) + (onchainScore * 0.30) + ((100 - riskScore) * 0.20);
                    const blendedScore = Math.round(Math.max(0, Math.min(100, blended)));
                    store.set('scores.blended', blendedScore);
                    console.log('‚úÖ Blended score calculated for dashboard');
                }
                
                // Ensure basic CCS signals data is available for sophisticated modules
                const state = store.snapshot();
                if (!state.ccs?.signals) {
                    store.set('ccs.signals', {
                        fear_greed: { value: 50 },
                        btc_dominance: { value: 57.5 },
                        funding_rate: { value: 0.0001 }
                    });
                    console.log('‚úÖ Basic CCS signals data initialized for dashboard');
                }
                
                console.log('üéØ Dashboard data loading completed');
                refreshGI();
                
            } catch (error) {
                console.error('‚ùå Error loading dashboard data:', error);
                // Fallback to basic calculation
                refreshGI();
            }
        }
        
        function waitForStoreReady() {
            const state = store.snapshot();
            const hasValidData = state.scores?.blended != null || 
                                (state.cycle?.score != null && state.scores?.onchain != null && state.scores?.risk != null);
            
            if (hasValidData) {
                console.log('üéØ Store ready with data, refreshing Global Insight');
                refreshGI();
            } else {
                console.log('‚è≥ No store data, loading directly for dashboard...');
                loadUnifiedDataForDashboard();
            }
        }

        // Update Global Insight meta badge with governance data
        function updateGlobalInsightMeta() {
            try {
                const metaEl = document.getElementById('gi-meta');
                if (!metaEl) return;

                // Get data from store
                const ml = store.get('governance.ml_signals');
                const policy = store.get('governance.active_policy');

                // Format timestamp
                const ts = ml?.timestamp ? new Date(ml.timestamp) : null;
                const timeStr = ts ? ts.toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit', second: '2-digit' }) : '--:--:--';

                // Get contradiction index (0-1 scale, convert to percentage)
                const contradiction = ml?.contradiction_index != null ? Math.round(ml.contradiction_index * 100) : null;

                // Get cap from policy (0-1 scale, convert to percentage)
                const cap = policy?.cap_daily != null ? Math.round(policy.cap_daily * 100) : null;

                // Build badge text
                const badges = [`Updated: ${timeStr}`];
                if (contradiction !== null) badges.push(`Contrad: ${contradiction}%`);
                if (cap !== null) badges.push(`Cap: ${cap}%`);

                metaEl.textContent = badges.join(' ‚Ä¢ ');

                console.debug('üè∑Ô∏è Global Insight meta updated:', {
                    timestamp: timeStr,
                    contradiction,
                    cap,
                    text: metaEl.textContent
                });

            } catch (error) {
                console.warn('Failed to update Global Insight meta:', error);
            }
        }

        document.addEventListener('DOMContentLoaded', ()=>{
            // Subscribe to store changes for reactive updates
            store.subscribe(()=> {
                clearTimeout(window.giRefreshTimer);
                window.giRefreshTimer = setTimeout(() => {
                    refreshGI();
                    updateGlobalInsightMeta();
                }, 300);
            });
            
            // Smart initial load - wait for data to be ready
            setTimeout(waitForStoreReady, 800); // Give time for analytics-unified to start loading
        });
    </script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            background: var(--theme-background);
            color: var(--theme-text);
            font-family: system-ui, -apple-system, 'Segoe UI', Roboto, Arial, sans-serif;
            line-height: 1.6;
            min-height: 100vh;
        }

        .wrap {
            max-width: 95vw;
            margin: 0 auto;
            padding: 20px;
        }

        .dashboard-grid {
            display: grid;
            gap: 20px;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            margin-top: 20px;
        }

        .card {
            background: var(--theme-surface);
            border: 1px solid var(--theme-border);
            border-radius: var(--radius-lg);
            padding: var(--space-xl);
            transition: all var(--transition-normal);
            box-shadow: var(--shadow-sm);
        }

        .card:hover {
            border-color: var(--brand-primary);
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--space-lg);
            padding-bottom: var(--space-md);
            border-bottom: 1px solid var(--theme-border);
        }

        .card-title {
            font-size: 18px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .card-icon {
            font-size: 24px;
        }

        .metric {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 12px 0;
            padding: 8px 0;
        }

        .metric-label {
            color: var(--theme-text-muted);
            font-size: 14px;
        }

        .metric-value {
            font-weight: 600;
            font-size: 16px;
            color: var(--theme-text);
        }

        .status-badge {
            padding: 4px 8px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .status-active {
            background: var(--success-bg);
            color: var(--success);
            border: 1px solid var(--success);
        }

        .status-warning {
            background: var(--warning-bg);
            color: var(--warning);
            border: 1px solid var(--warning);
        }

        .status-error {
            background: var(--danger-bg);
            color: var(--danger);
            border: 1px solid var(--danger);
        }

        .quick-actions {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 12px;
            margin-top: 16px;
        }

        .action-btn {
            background: var(--brand-primary);
            color: white;
            text-decoration: none;
            padding: var(--space-md) var(--space-lg);
            border-radius: var(--radius-md);
            font-weight: 600;
            text-align: center;
            transition: all var(--transition-normal);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: var(--space-sm);
        }

        .action-btn:hover {
            transform: translateY(-1px);
            box-shadow: var(--shadow-lg);
            background: var(--brand-primary-hover);
        }

        .action-btn.secondary {
            background: var(--theme-surface-elevated);
            color: var(--theme-text);
            border: 1px solid var(--theme-border);
        }

        .action-btn.secondary:hover {
            border-color: var(--brand-primary);
            color: var(--brand-primary);
            background: var(--theme-surface-hover);
        }

        /* Container pour graphique Chart.js */
        .portfolio-chart {
            height: 210px;
            position: relative;
            margin: var(--space-lg) 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .portfolio-chart canvas {
            max-height: 100%;
            max-width: 100%;
        }

        .recent-activity {
            max-height: 300px;
            overflow-y: auto;
        }

        .activity-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: var(--space-sm) 0;
            border-bottom: 1px solid var(--theme-border);
        }

        .activity-item:last-child {
            border-bottom: none;
        }

        .activity-desc {
            color: var(--theme-text-muted);
            font-size: 13px;
        }

        .activity-time {
            color: var(--theme-text-muted);
            font-size: 12px;
        }

        .connections-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 12px;
            margin-top: 12px;
        }

        .connection-item {
            text-align: center;
            padding: var(--space-md);
            border-radius: var(--radius-md);
            border: 1px solid var(--theme-border);
            background: var(--theme-surface-elevated);
        }

        .connection-name {
            font-size: 12px;
            margin-bottom: 4px;
            color: var(--theme-text-muted);
        }

        .loading {
            color: var(--theme-text-muted);
            text-align: center;
            padding: var(--space-xl);
        }

        .error {
            color: var(--danger);
            text-align: center;
            padding: var(--space-xl);
            background: var(--danger-bg);
            border: 1px solid var(--danger);
            border-radius: var(--radius-md);
            margin: var(--space-md) 0;
        }

        @media (max-width: 768px) {
            .dashboard-grid {
                grid-template-columns: 1fr;
            }

            .quick-actions {
                grid-template-columns: 1fr;
            }
        }
    </style>


</head>

<body>
    <div class="wrap">
        <div class="dashboard-grid">
            <!-- Global Insight (Unified view) -->
            <div class="card" id="overview" draggable="true"
                data-tooltip="Vue unifi√©e: d√©cision, cycle, on-chain, risque, sentiment"
                data-source="Scores unifi√©s du Risk Dashboard">
                <div class="card-header">
                    <div class="card-title"><span class="card-icon">üß≠</span> Global Insight</div>
                    <a href="analytics-unified.html" class="action-btn secondary" style="padding:4px 8px;font-size:12px;">Ouvrir</a>
                </div>
                <div style="display:flex; justify-content:space-between; align-items:center; gap:12px;">
                    <div>
                        <div style="font-size:.85rem; color: var(--theme-text-muted); font-weight:600;">Decision Index</div>
                        <div id="gi-score" style="font-size:2rem; font-weight:800;">--</div>
                    </div>
                    <div style="text-align:right; font-size:.85rem; color: var(--theme-text-muted);">
                        <div>Cycle: <span id="gi-cycle">--</span></div>
                        <div>On‚ÄëChain: <span id="gi-onchain">--</span></div>
                        <div>Risque: <span id="gi-risk">--</span></div>
                    </div>
                </div>
                <div id="gi-reco" style="margin-top:.5rem; font-size:.9rem; color: var(--theme-text);"></div>
                <div id="gi-meta" style="text-align:center; font-size:11px; color:var(--theme-text-muted); margin-top:8px; padding-top:8px; border-top:1px solid var(--theme-border);"></div>
            </div>

            <!-- Portfolio Overview - Disposition am√©lior√©e pour gagner de la place -->
            <div class="card" id="crypto" draggable="true" style="grid-column: span 2;"
                data-tooltip="Vue d'ensemble compl√®te de votre portefeuille crypto avec r√©partition, m√©triques de performance et graphiques en temps r√©el."
                data-source="API /balances/current + prix CoinGecko/CoinGlass">
                <div class="card-header">
                    <div class="card-title">Portfolio Overview</div>
                    <div style="display:flex;gap:8px;align-items:center;">
                        <span id="portfolio-source-display" style="font-size:11px;color:var(--theme-text-muted);padding:2px 6px;background:var(--theme-bg);border-radius:4px;border:1px solid var(--theme-border);">--</span>
                        <button class="action-btn secondary" style="padding:4px 8px;font-size:12px;"
                            onclick="forceRefreshData()">üîÑ</button>
                        <span class="status-badge status-active" id="portfolio-status">Loading</span>
                    </div>
                </div>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: var(--space-lg);">
                    <!-- Colonne gauche : M√©triques -->
                    <div>
                        <div class="metric">
                            <span class="metric-label">Total Value</span>
                            <span class="metric-value" id="total-value">--</span>
                        </div>

                        <div class="metric">
                            <span class="metric-label">P&L Today</span>
                            <span class="metric-value" id="daily-pnl">--</span>
                        </div>

                        <div class="metric">
                            <span class="metric-label">Assets Count</span>
                            <span class="metric-value" id="assets-count">--</span>
                        </div>
                        <div onclick="togglePortfolioDetails()"
                            style="font-weight: 600; margin-top: var(--space-md); margin-bottom: var(--space-sm); color: var(--theme-text-muted); cursor: pointer; display: flex; align-items: center; gap: var(--space-xs);">
                            <span id="details-arrow">‚ñ∂Ô∏è</span>
                            <span>üìã D√©tails du portfolio</span>
                        </div>

                        <!-- Section portfolio d√©taill√© (cach√©e par d√©faut) -->
                        <div id="portfolio-details" style="display: none;">
                            <table class="data-table">
                                <thead>
                                    <tr>
                                        <th>Coin</th>
                                        <th>Quantit√©</th>
                                        <th>Valeur (USD)</th>
                                        <th>% du portefeuille</th>
                                    </tr>
                                </thead>
                                <tbody id="portfolio-details-body">
                                    <!-- Les lignes sont inject√©es par ton JS -->
                                </tbody>
                            </table>
                        </div>
                    </div>

                    <!-- Colonne droite : Graphique et Breakdown -->
                    <div>
                        <div class="portfolio-chart" id="portfolio-chart">
                            <canvas id="portfolioChartCanvas"></canvas>
                        </div>
                    </div>
                </div>
            </div>


            <!-- Execution Status -->
            <div class="card" id="card-execution" draggable="true"
                data-tooltip="Statut des ex√©cutions automatiques de trades avec historique des performances et volumes trait√©s."
                data-source="API /execution/status + logs internes">
                <div class="card-header">
                    <div class="card-title"><span class="card-icon">üéØ</span>Execution Status</div>
                    <span class="status-badge" id="execution-status">Loading</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Last Execution</span>
                    <span class="metric-value" id="last-execution">--</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Success Rate (24h)</span>
                    <span class="metric-value" id="success-rate">--</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Total Volume (24h)</span>
                    <span class="metric-value" id="volume-24h">--</span>
                </div>
            </div>

            <!-- Exchange Connections -->
            <div class="card" id="card-exchange" draggable="true"
                data-tooltip="√âtat des connexions avec les exchanges (Binance, KuCoin) et v√©rification des API keys."
                data-source="Tests de connectivit√© API en temps r√©el">
                <div class="card-header">
                    <div class="card-title"><span class="card-icon">üîó</span>Exchange Status</div>
                    <a href="monitoring-unified.html" class="status-badge status-active"
                        style="text-decoration:none;">View Details</a>
                </div>
                <div class="connections-grid" id="connections-grid">
                    <div class="loading">Loading connections...</div>
                </div>
            </div>

            <!-- Recent Activity -->
            <div class="card" id="card-activity" draggable="true"
                data-tooltip="Historique des derni√®res op√©rations de trading, rebalancing et √©v√©nements syst√®me."
                data-source="API /execution/history + logs syst√®me">
                <div class="card-header">
                    <div class="card-title"><span class="card-icon">üìã</span>Recent Activity</div>
                    <a href="execution_history.html" class="status-badge status-active"
                        style="text-decoration:none;">View All</a>
                </div>
                <div class="recent-activity" id="recent-activity">
                    <div class="loading">Loading recent activity...</div>
                </div>
            </div>

            <!-- System Health -->
            <div class="card" id="card-health" draggable="true"
                data-tooltip="Surveillance de la sant√© du syst√®me : APIs, fra√Æcheur des donn√©es et validateurs de s√©curit√©."
                data-source="Monitoring interne + tests API">
                <div class="card-header">
                    <div class="card-title"><span class="card-icon">‚ù§Ô∏è</span>System Health</div>
                    <span class="status-badge" id="system-health">Loading</span>
                </div>
                <div class="metric">
                    <span class="metric-label">API Status</span>
                    <span class="metric-value" id="api-status">--</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Data Freshness</span>
                    <span class="metric-value" id="data-freshness">--</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Safety Validator</span>
                    <span class="metric-value" id="safety-status">--</span>
                </div>
            </div>

            <!-- Scores -->
            <div class="card" id="card-scores" draggable="true"
                data-tooltip="Scores de performance et m√©triques calcul√©s par les algorithmes ML pour √©valuer le portefeuille."
                data-source="API /analytics/scores + mod√®les ML">
                <div class="card-header">
                    <div class="card-title">Scores</div>
                    <span class="status-badge" id="scores-status">Loading</span>
                </div>
                <div id="scores-content">
                    <div class="loading">Chargement des scores...</div>
                </div>
            </div>

            <!-- Debug & New Modules -->
            <div class="card" id="card-debug" draggable="true"
                data-tooltip="Acc√®s rapide aux outils de debug et aux nouveaux modules : Analytics, AI, Optimisation et Performance."
                data-source="Liens internes et outils d√©veloppeur">
                <div class="card-header">
                    <div class="card-title"><span class="card-icon">üîß</span>Debug & Nouveaux Modules</div>
                    <a href="debug-menu.html" class="status-badge status-active" style="text-decoration:none;">Menu
                        Complet</a>
                </div>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; padding: 12px;">
                    <a href="analytics-unified.html"
                        style="color: var(--theme-accent); text-decoration: none; padding: 8px; border: 1px solid var(--theme-border); border-radius: 6px; text-align: center; font-size: 0.9em;">
                        üìä Analytics
                    </a>
                    <a href="ai-dashboard.html"
                        style="color: var(--theme-accent); text-decoration: none; padding: 8px; border: 1px solid var(--theme-border); border-radius: 6px; text-align: center; font-size: 0.9em;">
                        ü§ñ AI Dashboard
                    </a>
                    <a href="portfolio-optimization.html"
                        style="color: var(--theme-accent); text-decoration: none; padding: 8px; border: 1px solid var(--theme-border); border-radius: 6px; text-align: center; font-size: 0.9em;">
                        üéØ Optimisation+
                    </a>
                    <a href="/api/performance/cache/stats" target="_blank"
                        style="color: var(--theme-accent); text-decoration: none; padding: 8px; border: 1px solid var(--theme-border); border-radius: 6px; text-align: center; font-size: 0.9em;">
                        ‚ö° Performance
                    </a>
                </div>
                <div
                    style="padding: 8px 12px; font-size: 0.8em; color: var(--theme-text-secondary); border-top: 1px solid var(--theme-border);">
                    4 nouveaux syst√®mes: Performance (4.8x), Multi-actifs (7 classes), Charts interactifs, Optimisation
                    avanc√©e
                </div>
            </div>

        </div>
    </div>

    <script>
        // √âtat global
        let dashboardData = { portfolio: null, connections: null, recentActivity: null, executionStats: null };
        let portfolioChart = null;

        document.addEventListener('DOMContentLoaded', async () => {
            console.debug('üìä Dashboard unifi√© initialis√©');
            // Navigation th√©matique initialis√©e automatiquement

            // Appliquer le th√®me imm√©diatement
            console.debug('Initializing theme for dashboard page...');
            if (window.globalConfig && window.globalConfig.applyTheme) {
                window.globalConfig.applyTheme();
            }
            if (window.applyAppearance) {
                window.applyAppearance();
            }
            console.debug('Current theme after dashboard init:', document.documentElement.getAttribute('data-theme'));

            // Configuration Chart.js avec th√®me
            initChartTheme();

            // Initialize data source tracking for cross-tab synchronization
            window.lastKnownDataSource = globalConfig.get('data_source');
            console.debug(`üìä Dashboard initialized with data source: ${window.lastKnownDataSource}`);

            await loadDashboardData();
            setInterval(loadDashboardData, 60000);
            
            // Also check for data source changes more frequently (every 5 seconds)
            setInterval(() => {
                const currentSource = globalConfig.get('data_source');
                if (currentSource && currentSource !== window.lastKnownDataSource) {
                    console.debug(`üîÑ Periodic check: Data source changed from ${window.lastKnownDataSource} to ${currentSource}`);
                    window.lastKnownDataSource = currentSource;
                    loadDashboardData();
                }
            }, 5000);

            // √âcouter les changements de th√®me et source pour synchronisation cross-tab
            window.addEventListener('storage', function (e) {
                const expectedKey = (window.globalConfig?.getStorageKey && window.globalConfig.getStorageKey()) || 'crypto_rebal_settings_v1';
                if (e.key === expectedKey) {
                    console.debug('Settings changed in another tab, checking for theme and data source changes...');
                    
                    // Check if data source changed
                    const currentSource = globalConfig.get('data_source');
                    const previousSource = window.lastKnownDataSource;
                    
                    if (currentSource && currentSource !== previousSource) {
                        console.debug(`üîÑ Data source changed from ${previousSource} to ${currentSource}, reloading dashboard...`);
                        console.debug('üîÑ Storage event triggered data source change - forcing portfolio refresh...');
                        window.lastKnownDataSource = currentSource;
                        
                        // Clear portfolio chart cache on source change
                        if (window.portfolioChart) {
                            window.portfolioChart.destroy();
                            window.portfolioChart = null;
                        }
                        
                        loadDashboardData();
                    }
                    
                    // Apply theme changes
                    setTimeout(() => {
                        if (window.globalConfig && window.globalConfig.applyTheme) {
                            window.globalConfig.applyTheme();
                        }
                        if (window.applyAppearance) {
                            window.applyAppearance();
                        }
                        // Refaire le th√®me des graphiques aussi
                        initChartTheme();
                    }, 100);
                }
            });

            window.addEventListener('dataSourceChanged', (event) => {
                console.debug(`üîÑ Source chang√©e: ${event.detail.oldSource} ‚Üí ${event.detail.newSource}`);
                console.debug('üîÑ Forcing complete portfolio refresh due to data source change...');
                
                // Clear portfolio cache when source changes
                if (window.portfolioChart) {
                    window.portfolioChart.destroy();
                    window.portfolioChart = null;
                }
                
                // Update the known source immediately
                window.lastKnownDataSource = event.detail.newSource;
                
                // Force complete reload of dashboard data
                loadDashboardData();
            });

            // Reformat values when display currency changes
            window.addEventListener('configChanged', (ev) => {
                try {
                    const key = ev?.detail?.key;
                    if (key === 'display_currency') {
                        console.debug('üí± Display currency changed, re-rendering amounts...');
                        const cur = (window.globalConfig && window.globalConfig.get('display_currency')) || 'USD';
                        const maybeRender = () => {
                          if (dashboardData && dashboardData.portfolio) {
                              updatePortfolioDisplay(dashboardData.portfolio);
                          }
                          if (dashboardData && dashboardData.recentActivity) {
                              updateRecentActivity(dashboardData.recentActivity);
                          }
                          if (dashboardData && dashboardData.executionStats) {
                              updateExecutionStatus(dashboardData.executionStats);
                          }
                        };
                        if (window.currencyManager && cur !== 'USD') {
                          window.currencyManager.ensureRate(cur).then(maybeRender).catch(maybeRender);
                        } else {
                          maybeRender();
                        }
                    }
                } catch (e) {
                    console.warn('Currency change re-render failed:', e);
                }
                // Update meta badge (Updated / Contrad / Cap)
                updateGlobalInsightMeta();
            });

            // Also re-render when async rate fetch completes
            window.addEventListener('currencyRateUpdated', () => {
                try {
                    if (dashboardData && dashboardData.portfolio) updatePortfolioDisplay(dashboardData.portfolio);
                    if (dashboardData && dashboardData.recentActivity) updateRecentActivity(dashboardData.recentActivity);
                    if (dashboardData && dashboardData.executionStats) updateExecutionStatus(dashboardData.executionStats);
                } catch (e) { console.warn('Re-render on rate update failed:', e); }
            });
        });

        async function loadDashboardData() {
            try {
                // Clear any potential cached data
                const currentTimestamp = Date.now();
                console.debug(`üîÑ loadDashboardData called at ${currentTimestamp} with source: ${globalConfig.get('data_source')}`);
                
                // Charger d'abord les groupes depuis alias-manager
                await loadAssetGroups();

                const [portfolioData, connectionsData, historyData, executionStatus, scoresData] = await Promise.allSettled([
                    loadPortfolioData(), loadConnectionsStatus(), loadRecentHistory(), loadExecutionStatus(), loadScoresData()
                ]);
                const portfolioResult = portfolioData.status === 'fulfilled' ? portfolioData.value : null;
                console.debug('üìä About to update portfolio display with:', {
                    hasData: !!portfolioResult,
                    totalValue: portfolioResult?.metrics?.total_value_usd,
                    assetCount: portfolioResult?.metrics?.asset_count
                });
                // Store for re-rendering on currency change
                dashboardData.portfolio = portfolioResult;
                dashboardData.connections = connectionsData.status === 'fulfilled' ? connectionsData.value : null;
                dashboardData.recentActivity = historyData.status === 'fulfilled' ? historyData.value : null;
                dashboardData.executionStats = executionStatus.status === 'fulfilled' ? executionStatus.value : null;

                await updatePortfolioDisplay(dashboardData.portfolio);
                updateConnectionsDisplay(dashboardData.connections);
                updateRecentActivity(dashboardData.recentActivity);
                updateExecutionStatus(dashboardData.executionStats);
                updateScoresDisplay(scoresData.status === 'fulfilled' ? scoresData.value : null);
                updateSystemHealth();

                console.debug('‚úÖ Dashboard data loaded successfully');
            } catch (e) {
                log.error('Erreur chargement dashboard:', e);
                showError('Impossible de charger les donn√©es du dashboard. V√©rifiez votre connexion.');
                showError('Erreur lors du chargement des donn√©es');
            }
        }

        async function loadPortfolioData() {
            try {
                const currentSource = globalConfig.get('data_source');
                console.debug(`üìä Loading REAL portfolio data with source: ${currentSource}`);
                return await loadRealCSVPortfolioData();
            } catch (e) {
                log.error('Erreur portfolio CSV non disponible:', e);
                showError('Fichier CSV du portfolio non accessible.');
                return null; // Pas de fallback hardcod√©
            }
        }

        // Fallback function to load CSV directly when API is not available
        async function loadDirectCSV() {
            const configuredSource = globalConfig.get('data_source');
            console.debug(`üìÑ Loading CSV files directly for source: ${configuredSource}`);

            // Only use direct CSV access for cointracking source
            if (configuredSource === 'cointracking') {
                const csvFiles = [
                    'data/raw/CoinTracking - Current Balance.csv',
                    'data/raw/CoinTracking - Balance by Exchange - 26.08.2025.csv'
                ];

                for (const csvFile of csvFiles) {
                    try {
                        console.log(`üìÑ Attempting to load: ${csvFile}`);
                        const response = await fetch(csvFile);
                        if (response.ok) {
                            const csvText = await response.text();
                            console.log(`‚úÖ Successfully loaded ${csvFile} (${csvText.length} characters)`);
                            return {
                                success: true,
                                csvText: csvText,
                                source: 'csv_direct',
                                file: csvFile
                            };
                        }
                    } catch (fileError) {
                        console.log(`‚ö†Ô∏è Could not load ${csvFile}:`, fileError.message);
                    }
                }
            } else {
                // For stub sources or others, create fallback stub data
                console.debug(`üìä Creating fallback stub data for source: ${configuredSource}`);
                return createStubBalanceData(configuredSource);
            }

            return {
                success: false,
                error: `No data accessible for source: ${configuredSource}`,
                source: configuredSource
            };
        }

        // Create fallback stub data based on configured source
        function createStubBalanceData(source) {
            const stubData = {
                stub_conservative: [
                    { symbol: 'BTC', balance: 0.5, value_usd: 50000, price_change_percentage_24h: 2.1 },
                    { symbol: 'ETH', balance: 5, value_usd: 20000, price_change_percentage_24h: 1.8 },
                    { symbol: 'USDC', balance: 10000, value_usd: 10000, price_change_percentage_24h: 0.1 }
                ],
                stub_balanced: [
                    { symbol: 'BTC', balance: 1.5, value_usd: 150000, price_change_percentage_24h: -1.2 },
                    { symbol: 'ETH', balance: 10, value_usd: 40000, price_change_percentage_24h: -2.5 },
                    { symbol: 'SOL', balance: 100, value_usd: 15000, price_change_percentage_24h: 3.2 },
                    { symbol: 'LINK', balance: 500, value_usd: 12000, price_change_percentage_24h: 1.5 },
                    { symbol: 'USDT', balance: 8000, value_usd: 8000, price_change_percentage_24h: 0.0 }
                ],
                stub_shitcoins: [
                    { symbol: 'DOGE', balance: 100000, value_usd: 20000, price_change_percentage_24h: 15.2 },
                    { symbol: 'SHIB', balance: 50000000, value_usd: 15000, price_change_percentage_24h: -8.5 },
                    { symbol: 'PEPE', balance: 1000000000, value_usd: 10000, price_change_percentage_24h: 25.7 },
                    { symbol: 'BONK', balance: 2000000, value_usd: 5000, price_change_percentage_24h: -12.3 }
                ]
            };

            const balances = stubData[source] || stubData['stub_balanced'];

            return {
                success: true,
                data: { items: balances, source_used: source + '_fallback' },
                source: source + '_fallback'
            };
        }

        async function loadRealCSVPortfolioData() {
            console.debug('üîÑ Loading portfolio data using configured source...');
            const currentSource = globalConfig.get('data_source');
            console.debug(`üìä Using data source: ${currentSource}`);

            // Update source display (show cointracking_csv when using CSV files)
            const sourceDisplay = document.getElementById('portfolio-source-display');
            if (sourceDisplay) {
                let displaySource = currentSource || 'Unknown';
                if (displaySource === 'cointracking') displaySource = 'cointracking_csv';
                sourceDisplay.textContent = displaySource;
            }

            console.debug('üì° About to call window.loadBalanceData()...');
            let balanceResult;

            try {
                balanceResult = await window.loadBalanceData();
                console.debug('üìä Balance result received:', {
                    success: balanceResult?.success,
                    source: balanceResult?.source,
                    hasData: !!balanceResult?.data,
                    hasCsvText: !!balanceResult?.csvText,
                    dataItemsCount: balanceResult?.data?.items?.length || 0
                });
            } catch (error) {
                console.warn('üìä API not available, trying direct CSV access...', error.message);
                // Fallback: try direct CSV access since API is not available
                balanceResult = await loadDirectCSV();
            }

            if (!balanceResult || !balanceResult.success) {
                const msg = balanceResult?.error || 'Failed to load balance data';
                log.error(msg);
                throw new Error(msg);
            }

            let balances;

            if (balanceResult.csvText) {
                // Source CSV locale
                const csvText = balanceResult.csvText;
                balances = parseCSVBalancesAuto(csvText, { thresholdUSD: (window.globalConfig?.get('min_usd_threshold')) ?? 1.0 });
            } else if (balanceResult.data && Array.isArray(balanceResult.data.items)) {
                // Source API
                balances = balanceResult.data.items.map(item => ({
                    symbol: item.symbol,
                    balance: item.balance,
                    value_usd: item.value_usd
                }));
            } else {
                throw new Error('Invalid data format received');
            }

            const totalValue = balances.reduce((sum, it) => sum + (parseFloat(it.value_usd) || 0), 0);
            const assetCount = balances.length;

            console.debug(`‚úÖ REAL data loaded: ${assetCount} assets, total: $${totalValue.toFixed(2)}`);
            console.debug('üìä Final portfolio metrics calculated:', {
                source: currentSource,
                totalValue: totalValue,
                assetCount: assetCount,
                sampleAssets: balances.slice(0, 5).map(b => `${b.symbol}: $${b.value_usd}`)
            });

            return {
                ok: true,
                metrics: {
                    total_value_usd: totalValue,
                    asset_count: assetCount,
                    last_updated: new Date().toISOString()
                },
                performance: {
                    performance_available: true,
                    current_value_usd: totalValue,
                    absolute_change_usd: 0 // TODO: Calculer √† partir de donn√©es r√©elles
                },
                balances: {
                    items: balances,
                    total_count: balances.length,
                    timestamp: new Date().toISOString()
                }
            };
        }


        async function loadConnectionsStatus() {
            try {
                return { binance: { name: "Binance", connected: true }, kraken: { name: "Kraken", connected: true }, coinbase: { name: "Coinbase", connected: false } };
            } catch (e) { log.error('Erreur connexions:', e); return null; }
        }


        async function loadRecentHistory() {
            try {
                return {
                    sessions: [
                        { exchange: "Binance", total_orders: 3, successful_orders: 3, total_volume_usd: 1250.50, timestamp: new Date(Date.now() - 3600000).toISOString() },
                        { exchange: "Kraken", total_orders: 2, successful_orders: 2, total_volume_usd: 890.25, timestamp: new Date(Date.now() - 7200000).toISOString() }
                    ]
                };
            } catch (e) { log.error('Erreur historique:', e); return null; }
        }

        async function loadExecutionStatus() {
            try {
                return { recent_24h: { total_orders: 5, success_rate: 96.5, total_volume: 2140.75 } };
            } catch (e) { log.error('Erreur statut ex√©cution:', e); return null; }
        }

        // Charger les donn√©es de score depuis le risk dashboard
        async function loadScoresData() {
            try {
                console.debug('üìä Loading scores data...');

                // Essayer de r√©cup√©rer les scores depuis localStorage (stock√©s par risk-dashboard)
                const __user = localStorage.getItem('activeUser') || 'demo';
                const get = (k) => localStorage.getItem(`${k}:${__user}`) || localStorage.getItem(k);
                const scores = {
                    onchain: get('risk_score_onchain'),
                    risk: get('risk_score_risk'),
                    blended: get('risk_score_blended'),
                    ccs: get('risk_score_ccs'),
                    timestamp: get('risk_score_timestamp')
                };

                // V√©rifier si au moins un score est disponible et r√©cent (moins de 5 minutes)
                let hasValidScores = false;
                const result = {};

                if (scores.timestamp) {
                    const age = Date.now() - parseInt(scores.timestamp);
                    // Accepter les scores jusqu'√† 12 heures, marquer "stale" plus tard si besoin
                    if (age < 12 * 60 * 60 * 1000) { // 12 heures
                        result.timestamp = parseInt(scores.timestamp);

                        // Ajouter chaque score disponible
                        if (scores.onchain && scores.onchain !== '') {
                            result.onchain = parseFloat(scores.onchain);
                            hasValidScores = true;
                        }
                        if (scores.risk && scores.risk !== '') {
                            result.risk = parseFloat(scores.risk);
                            hasValidScores = true;
                        }
                        if (scores.blended && scores.blended !== '') {
                            result.blended = parseFloat(scores.blended);
                            hasValidScores = true;
                        }
                        if (scores.ccs && scores.ccs !== '') {
                            result.ccs = parseFloat(scores.ccs);
                            hasValidScores = true;
                        }
                    }
                }

                if (hasValidScores) {
                    console.debug('‚úÖ Scores loaded from localStorage:', result);
                    return result;
                }

                // Fallback: utiliser le cache persistant du risk-dashboard (12h TTL)
                try {
                    const cached = localStorage.getItem('risk_scores_cache');
                    if (cached) {
                        const entry = JSON.parse(cached);
                        const data = entry?.data || {};
                        const ts = entry?.timestamp;
                        const out = {};
                        if (typeof data.onchainScore === 'number') out.onchain = data.onchainScore;
                        if (typeof data.riskScore === 'number') out.risk = data.riskScore;
                        if (typeof data.blendedScore === 'number') out.blended = data.blendedScore;
                        if (typeof data.ccsScore === 'number') out.ccs = data.ccsScore;
                        if (typeof ts === 'number') out.timestamp = ts;
                        if (Object.keys(out).length > 0) {
                            console.debug('‚úÖ Scores loaded from persistent cache:', out);
                            return out;
                        }
                    }
                } catch (cacheErr) {
                    console.warn('Failed to read persistent risk scores cache:', cacheErr);
                }

                // Si pas de scores disponibles, retourner null
                console.debug('‚ö†Ô∏è No scores available (localStorage or cache)');
                return null;

            } catch (e) {
                log.error('Erreur chargement scores:', e);
                return null;
            }
        }

        async function updatePortfolioDisplay(data) {
            console.debug('üìä updatePortfolioDisplay called with:', {
                hasData: !!data,
                isOk: data?.ok,
                totalValue: data?.metrics?.total_value_usd,
                assetCount: data?.metrics?.asset_count
            });
            
            if (!data || !data.ok) {
                console.debug('‚ùå Portfolio data invalid or missing, showing error');
                document.getElementById('total-value').textContent = 'Erreur';
                document.getElementById('daily-pnl').textContent = 'Erreur';
                const st = document.getElementById('portfolio-status');
                st.className = 'status-badge status-error'; st.textContent = 'Erreur';
                return;
            }
            const { metrics, performance } = data;

            document.getElementById('total-value').textContent = formatUSD(metrics.total_value_usd || 0);

            const dailyPnl = performance?.absolute_change_usd || 0;
            const pnlEl = document.getElementById('daily-pnl');
            pnlEl.textContent = formatUSD(dailyPnl);
            pnlEl.style.color = dailyPnl >= 0 ? 'var(--success)' : 'var(--danger)';

            document.getElementById('assets-count').textContent = metrics.asset_count || 0;
            
            console.debug('‚úÖ Portfolio display updated:', {
                totalValueDisplayed: document.getElementById('total-value').textContent,
                assetsCountDisplayed: document.getElementById('assets-count').textContent,
                sourceDisplayed: document.getElementById('portfolio-source-display')?.textContent
            });

            const statusEl = document.getElementById('portfolio-status');
            if ((metrics.total_value_usd || 0) > 0) { statusEl.className = 'status-badge status-active'; statusEl.textContent = 'Actif'; }
            else { statusEl.className = 'status-badge status-warning'; statusEl.textContent = 'Vide'; }

            log.debug('About to call updatePortfolioChart with:', data.balances);
            await updatePortfolioChart(data.balances);
            // N'appeler le breakdown que si le conteneur est pr√©sent dans le DOM
            if (document.getElementById('breakdown-list')) {
                updatePortfolioBreakdown(data.balances);
            }
        }
        function updateConnectionsDisplay(data) {
            const container = document.getElementById('connections-grid');
            if (!data) { container.innerHTML = '<div class="error">Erreur de chargement</div>'; return; }

            const html = Object.values(data).map(conn => {
                const cls = conn.connected ? 'status-active' : 'status-error';
                const txt = conn.connected ? 'Online' : 'Offline';
                return `
          <div class="connection-item">
            <div class="connection-name">${conn.name}</div>
            <div class="status-badge ${cls}">${txt}</div>
          </div>`;
            }).join('');
            container.innerHTML = html;
        }

        function updateRecentActivity(data) {
            const container = document.getElementById('recent-activity');
            if (!data || !data.sessions || data.sessions.length === 0) {
                container.innerHTML = `
          <div class="activity-item">
            <div>
              <div>Aucune activit√© r√©cente</div>
              <div class="activity-desc">Les sessions d'ex√©cution appara√Ætront ici</div>
            </div>
            <div class="activity-time">--</div>
          </div>`;
                return;
            }
            const html = data.sessions.slice(0, 5).map(s => `
        <div class="activity-item">
          <div>
            <div>${s.total_orders || 0} ordres sur ${s.exchange || 'Exchange'}</div>
            <div class="activity-desc">${s.successful_orders || 0} r√©ussis, ${formatUSD(s.total_volume_usd || 0)} volume</div>
          </div>
          <div class="activity-time">${formatTimeAgo(s.timestamp)}</div>
        </div>`).join('');
            container.innerHTML = html;
        }

        function updateExecutionStatus(data) {
            if (!data || !data.recent_24h) {
                document.getElementById('last-execution').textContent = 'Aucune';
                document.getElementById('success-rate').textContent = '--';
                document.getElementById('volume-24h').textContent = '$0.00';
                const st = document.getElementById('execution-status'); st.className = 'status-badge status-warning'; st.textContent = 'En attente';
                return;
            }
            document.getElementById('last-execution').textContent = data.recent_24h?.total_orders > 0 ? 'R√©cent' : 'Aucune';
            const sr = data.recent_24h?.success_rate;
            document.getElementById('success-rate').textContent = (sr !== undefined) ? sr.toFixed(1) + '%' : '--';
            document.getElementById('volume-24h').textContent = formatUSD(data.recent_24h?.total_volume || 0);

            const st = document.getElementById('execution-status');
            if (sr >= 95) { st.className = 'status-badge status-active'; st.textContent = 'Excellent'; }
            else if (sr >= 90) { st.className = 'status-badge status-warning'; st.textContent = 'Bon'; }
            else if (sr !== undefined) { st.className = 'status-badge status-error'; st.textContent = '√Ä am√©liorer'; }
            else { st.className = 'status-badge status-warning'; st.textContent = 'En attente'; }
        }

        function updateSystemHealth() {
            document.getElementById('api-status').textContent = 'Online';
            document.getElementById('data-freshness').textContent = 'R√©cente';
            document.getElementById('safety-status').textContent = 'Actif';
            const st = document.getElementById('system-health'); st.className = 'status-badge status-active'; st.textContent = 'Healthy';
        }

        // Mettre √† jour l'affichage des scores
        function updateScoresDisplay(scoresData) {
            const container = document.getElementById('scores-content');
            const statusEl = document.getElementById('scores-status');

            if (!scoresData) {
                // Aucun score disponible - afficher message avec lien vers risk-dashboard
                container.innerHTML = `
                    <div style="text-align: center; padding: var(--space-lg); color: var(--theme-text-muted);">
                        <div style="font-size: 2rem; margin-bottom: var(--space-md);">üìä</div>
                        <div style="margin-bottom: var(--space-md);">Aucun score de risque disponible</div>
                        <a href="risk-dashboard.html"
                           style="display: inline-block; background: var(--brand-primary); color: white;
                                  padding: var(--space-sm) var(--space-md); border-radius: var(--radius-md);
                                  text-decoration: none; font-weight: 600;">
                            üìà Voir Risk Analytics
                        </a>
                    </div>
                `;
                if (statusEl) {
                    statusEl.className = 'status-badge status-warning';
                    statusEl.textContent = 'Donn√©es manquantes';
                }
                return;
            }

            // Scores disponibles - afficher les valeurs disponibles
            const { onchain, risk, blended, ccs, timestamp } = scoresData;
            const STALE_MINUTES = 30; // au-del√†: afficher l'√©tiquette Cache
            const ageMin = timestamp ? Math.round((Date.now() - timestamp) / 60000) : null;
            const isStale = ageMin != null && ageMin >= STALE_MINUTES;

            // D√©terminer les couleurs en fonction des scores (rouge >70, orange 40-70, vert <40)
            const getScoreColor = (score) => {
                if (score > 70) return 'var(--danger)';
                if (score >= 40) return 'var(--warning)';
                return 'var(--success)';
            };

            const getScoreLabel = (score) => {
                if (score > 70) return '√âlev√©';
                if (score >= 40) return 'Moyen';
                return 'Faible';
            };

            let scoresHTML = '';

            // Afficher chaque score disponible
            if (blended !== undefined && blended !== null) {
                scoresHTML += `
                    <div class="metric" style="margin: 6px 0;">
                        <span class="metric-label">‚öñÔ∏è Score Strat√©gique</span>
                        <span class="metric-value" style="color: ${getScoreColor(blended)};">
                            ${Math.round(blended)}/100
                            <span style="font-size: 0.8em; color: var(--theme-text-muted);">(${getScoreLabel(blended)})</span>
                        </span>
                    </div>
                `;
            }

            if (ccs !== undefined && ccs !== null) {
                scoresHTML += `
                    <div class="metric" style="margin: 6px 0;">
                        <span class="metric-label">üìä CCS Score</span>
                        <span class="metric-value" style="color: ${getScoreColor(ccs)};">
                            ${Math.round(ccs)}/100
                            <span style="font-size: 0.8em; color: var(--theme-text-muted);">(${getScoreLabel(ccs)})</span>
                        </span>
                    </div>
                `;
            }

            if (onchain !== undefined && onchain !== null) {
                scoresHTML += `
                    <div class="metric" style="margin: 6px 0;">
                        <span class="metric-label">üîó On-Chain</span>
                        <span class="metric-value" style="color: ${getScoreColor(onchain)};">
                            ${Math.round(onchain)}/100
                            <span style="font-size: 0.8em; color: var(--theme-text-muted);">(${getScoreLabel(onchain)})</span>
                        </span>
                    </div>
                `;
            }

            if (risk !== undefined && risk !== null) {
                scoresHTML += `
                    <div class="metric" style="margin: 6px 0;">
                        <span class="metric-label">üõ°Ô∏è Risk</span>
                        <span class="metric-value" style="color: ${getScoreColor(risk)};">
                            ${Math.round(risk)}/100
                            <span style="font-size: 0.8em; color: var(--theme-text-muted);">(${getScoreLabel(risk)})</span>
                        </span>
                    </div>
                `;
            }

            // Message pour les scores manquants
            if (scoresHTML === '') {
                scoresHTML = `
                    <div style="text-align: center; color: var(--theme-text-muted); padding: var(--space-md);">
                        <div>üìä Aucun score disponible</div>
                        <div style="font-size: 0.9em; margin-top: var(--space-xs);">
                            Visitez le risk dashboard pour g√©n√©rer des scores
                        </div>
                    </div>
                `;
            }

            container.innerHTML = `
                <div style="display: grid; gap: 2px;">
                    ${scoresHTML}
                    
                    <!-- Timestamp -->
                    ${timestamp ? `
                    <div style="text-align: center; font-size: 0.8em; color: var(--theme-text-muted); margin-top: 6px;">
                        Mis √† jour: ${new Date(timestamp).toLocaleTimeString()}${isStale ? ` ¬∑ <span class=\"status-badge status-warning\">Cache</span>` : ''}
                    </div>
                    ` : ''}

                    <!-- Lien vers risk dashboard -->
                    <div style="text-align: center; margin-top: 8px;">
                        <a href="risk-dashboard.html"
                           style="color: var(--brand-primary); text-decoration: none; font-size: 0.9em;">
                            üìä Voir d√©tails complets
                        </a>
                    </div>
                </div>
            `;

            if (statusEl) {
                if (isStale) {
                    statusEl.className = 'status-badge status-warning';
                    statusEl.textContent = 'Cache';
                } else {
                    statusEl.className = 'status-badge status-active';
                    statusEl.textContent = '√Ä jour';
                }
            }
        }

        function formatUSD(v) {
            const cur = (window.globalConfig && window.globalConfig.get('display_currency')) || 'USD';
            const rate = (window.currencyManager && window.currencyManager.getRateSync(cur)) || 1;
            if (cur !== 'USD' && (!rate || rate <= 0)) return '‚Äî';
            const val = (v == null || isNaN(v)) ? 0 : (v * rate);
            try {
              // BTC is not a standard ISO code; Intl may throw
              const decimals = (cur === 'BTC') ? 8 : 2;
              const out = new Intl.NumberFormat('fr-FR', { style: 'currency', currency: cur, minimumFractionDigits: decimals, maximumFractionDigits: decimals }).format(val);
              return (cur === 'USD') ? out.replace(/\s?US$/, '') : out;
            } catch (_) {
              const decimals = (cur === 'BTC') ? 8 : 2;
              return `${val.toFixed(decimals)} ${cur}`;
            }
        }
        function formatTimeAgo(ts) {
            if (!ts) return 'N/A';
            const d = new Date(ts), now = new Date(), dm = Math.floor((now - d) / (1000 * 60));
            if (dm < 60) return `${dm}min`;
            if (dm < 1440) return `${Math.floor(dm / 60)}h`;
            return `${Math.floor(dm / 1440)}j`;
        }
        function showError(m) {
            log.error(m);
            // Afficher l'erreur √† l'utilisateur via UI
            const errorDiv = document.getElementById('error-display') || createErrorDisplay();
            errorDiv.textContent = m;
            errorDiv.style.display = 'block';
            setTimeout(() => errorDiv.style.display = 'none', 5000);
        }

        function createErrorDisplay() {
            const div = document.createElement('div');
            div.id = 'error-display';
            div.style.cssText = `
                position: fixed; top: 20px; right: 20px; z-index: 9999;
                background: var(--theme-error, #ff4444); color: white;
                padding: 12px 16px; border-radius: 8px; max-width: 400px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.2); display: none;
            `;
            document.body.appendChild(div);
            return div;
        }

        // Configuration Chart.js avec th√®me adaptatif
        function initChartTheme() {
            if (typeof Chart !== 'undefined') {
                Chart.defaults.color = 'var(--theme-text)';
                Chart.defaults.borderColor = 'var(--theme-border)';
                Chart.defaults.backgroundColor = 'var(--theme-surface)';
                Chart.defaults.plugins.tooltip.backgroundColor = 'var(--theme-surface-elevated)';
                Chart.defaults.plugins.tooltip.titleColor = 'var(--theme-text)';
                Chart.defaults.plugins.tooltip.bodyColor = 'var(--theme-text)';
                Chart.defaults.plugins.tooltip.borderColor = 'var(--theme-border)';
                Chart.defaults.plugins.tooltip.borderWidth = 1;
            }
        }

        // Couleurs pour le graphique portfolio
        const PORTFOLIO_COLORS = [
            '#3b82f6', '#ef4444', '#10b981', '#f59e0b', '#8b5cf6',
            '#06b6d4', '#84cc16', '#f97316', '#ec4899', '#6366f1'
        ];

        // Classification dynamique - sera charg√©e depuis alias-manager
        let ASSET_GROUPS = null;

        // Charger la classification depuis alias-manager
        async function loadAssetGroups() {
            console.debug('üîç Loading asset groups...');
            await useFallbackAssetGroups();
        }

        async function useFallbackAssetGroups() {
            const fallbackAliases = {
                'BTC': 'BTC', 'TBTC': 'BTC',
                'ETH': 'ETH', 'WETH': 'ETH', 'STETH': 'ETH', 'WSTETH': 'ETH', 'RETH': 'ETH', 'CBETH': 'ETH',
                'USDC': 'Stablecoins', 'USDT': 'Stablecoins', 'USD': 'Stablecoins', 'DAI': 'Stablecoins',
                'SOL': 'L1/L0 majors', 'SOL2': 'L1/L0 majors',
                'ATOM': 'L1/L0 majors', 'ATOM2': 'L1/L0 majors', 'DOT': 'L1/L0 majors', 'DOT2': 'L1/L0 majors', 'ADA': 'L1/L0 majors',
                'AVAX': 'L1/L0 majors', 'NEAR': 'L1/L0 majors', 'LINK': 'L1/L0 majors', 'XRP': 'L1/L0 majors',
                'BCH': 'L1/L0 majors', 'XLM': 'L1/L0 majors', 'LTC': 'L1/L0 majors', 'SUI3': 'L1/L0 majors',
                'BNB': 'Exchange Tokens', 'BGB': 'Exchange Tokens', 'CHSB': 'Exchange Tokens',
                'AAVE': 'DeFi', 'JUPSOL': 'DeFi', 'JITOSOL': 'DeFi', 'FET': 'DeFi',
                'DOGE': 'Memecoins', 'XMR': 'Privacy', 'TRX': 'L1/L0 majors',
                'IMO': 'Others', 'VVV3': 'Others', 'TAO6': 'Others', 'OTHERS': 'Others'
            };

            ASSET_GROUPS = {};
            Object.entries(fallbackAliases).forEach(([asset, group]) => {
                if (!ASSET_GROUPS[group]) {
                    ASSET_GROUPS[group] = [];
                }
                ASSET_GROUPS[group].push(asset);
            });

            console.debug('‚úÖ Asset groups loaded:', Object.keys(ASSET_GROUPS));
        }

        // Parser CSV : wrapper auto qui utilise window.parseCSVBalances si dispo, sinon notre local
        function parseCSVBalancesAuto(csvText, { thresholdUSD = 1.0 } = {}) {
            if (typeof window.parseCSVBalances === 'function') {
                return window.parseCSVBalances(csvText);
            }
            return parseCSVBalancesLocal(csvText, { thresholdUSD });
        }

        // Impl√©mentation locale robuste
        function parseCSVBalancesLocal(csvText, { thresholdUSD = 1.0 } = {}) {
            const cleanedText = csvText.replace(/^\ufeff/, '');
            const lines = cleanedText.split(/\r?\n/);
            const balances = [];
            const minThreshold = (window.globalConfig && window.globalConfig.get('min_usd_threshold')) || thresholdUSD || 1.0;

            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;

                try {
                    const columns = parseCSVLineLocal(line);
                    if (columns.length >= 5) {
                        const ticker = columns[0];
                        const norm = s => parseFloat(String(s).replace(/[,\u00A0]/g, ''));
                        const amount = norm(columns[3]);
                        const valueUSD = norm(columns[4]);

                        if (ticker && !isNaN(amount) && !isNaN(valueUSD) && valueUSD >= minThreshold) {
                            balances.push({
                                symbol: ticker.toUpperCase(),
                                balance: amount,
                                value_usd: valueUSD
                            });
                        }
                    }
                } catch (error) {
                    console.warn('Erreur parsing ligne CSV:', error.message);
                }
            }

            return balances;
        }

        function parseCSVLineLocal(line) {
            const result = [];
            let current = '';
            let inQuotes = false;

            for (let i = 0; i < line.length; i++) {
                const char = line[i];

                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === ';' && !inQuotes) {
                    result.push(current.trim().replace(/^"|"$/g, ''));
                    current = '';
                } else {
                    current += char;
                }
            }

            if (current) {
                result.push(current.trim().replace(/^"|"$/g, ''));
            }

            return result;
        }

        function groupAssetsByAliases(items) {
            const groups = new Map();
            const ungrouped = [];

            log.debug('Grouping', items.length, 'assets by aliases');

            // Si ASSET_GROUPS n'est pas encore charg√©, mettre tout dans "Others"
            if (!ASSET_GROUPS) {
                console.warn('‚ö†Ô∏è ASSET_GROUPS not loaded yet, putting all assets in Others');
                const totalValue = items.reduce((sum, item) => sum + parseFloat(item.value_usd || 0), 0);
                return [{
                    label: 'Others',
                    value: totalValue,
                    assets: items.map(item => item.symbol)
                }];
            }

            items.forEach(item => {
                const symbol = (item.symbol || '').toUpperCase();
                let foundGroup = null;

                // Chercher dans quel groupe appartient ce symbol
                for (const [groupName, aliases] of Object.entries(ASSET_GROUPS)) {
                    if (aliases.includes(symbol)) {
                        foundGroup = groupName;
                        break;
                    }
                }

                if (foundGroup) {
                    if (!groups.has(foundGroup)) {
                        groups.set(foundGroup, {
                            label: foundGroup,
                            value: 0,
                            assets: []
                        });
                    }
                    const group = groups.get(foundGroup);
                    group.value += parseFloat(item.value_usd || 0);
                    group.assets.push(symbol);

                    // Debug log for BTC group specifically
                    if (foundGroup === 'BTC') {
                        log.debug('BTC GROUP: Added', symbol, 'value:', item.value_usd.toFixed(2), 'new total:', group.value.toFixed(2));
                    }

                    // Debug log for significant groupings
                    if (item.value_usd > 5000) {
                        log.debug('Grouped', symbol, 'into', foundGroup, '- value:', item.value_usd.toFixed(2));
                    }
                } else {
                    ungrouped.push({
                        label: symbol,
                        value: parseFloat(item.value_usd || 0)
                    });

                    // Debug log for ungrouped assets
                    if (item.value_usd > 1000) {
                        log.debug('UNGROUPED asset:', symbol, '- value:', item.value_usd.toFixed(2));
                    }
                }
            });

            log.debug('Final groups:', groups.size, 'grouped +', ungrouped.length, 'ungrouped');
            const result = [...Array.from(groups.values()), ...ungrouped];

            // Debug final result - especially BTC group
            result.forEach(group => {
                if (group.label === 'BTC') {
                    log.debug('FINAL BTC GROUP: value:', group.value.toFixed(2), 'assets:', group.assets.join(', '));
                } else if (group.value > 1000) {
                    log.debug('Final group:', group.label, '- value:', group.value.toFixed(2));
                    if (group.assets && group.assets.length > 1) {
                        console.debug('  ‚îî‚îÄ Assets:', group.assets.join(', '));
                    }
                }
            });

            return result;
        }

        // Cr√©er ou mettre √† jour le graphique portfolio
        async function updatePortfolioChart(balancesData) {
            log.debug('updatePortfolioChart - balancesData:', balancesData);

            if (!balancesData || !balancesData.items) {
                console.debug('‚ùå No balances data or items');
                document.getElementById('portfolio-chart').innerHTML = '<div style="text-align: center; padding: 20px; color: var(--warning);">‚è≥ Chargement des donn√©es...</div>';
                return;
            }

            // V√©rifier que ASSET_GROUPS est charg√© - forcer le chargement si n√©cessaire
            if (!ASSET_GROUPS) {
                console.debug('‚ùå ASSET_GROUPS not loaded, loading fallback immediately...');
                await useFallbackAssetGroups();
                // Continue avec ASSET_GROUPS maintenant disponible
            }

            let canvas = document.getElementById('portfolioChartCanvas');
            if (!canvas) {
                console.debug('‚ùå Canvas element not found, creating it...');
                // Cr√©er le canvas manquant
                const chartContainer = document.getElementById('portfolio-chart');
                if (chartContainer) {
                    chartContainer.innerHTML = '<canvas id="portfolioChartCanvas"></canvas>';
                    canvas = document.getElementById('portfolioChartCanvas');
                    console.debug('‚úÖ Canvas element created successfully');
                } else {
                    console.debug('‚ùå Portfolio chart container not found');
                    return;
                }
            }

            // V√©rifier que Chart.js est charg√©
            if (typeof Chart === 'undefined') {
                console.debug('‚ùå Chart.js not loaded, trying to reload...');
                document.getElementById('portfolio-chart').innerHTML = '<div style="text-align: center; padding: 20px; color: var(--danger);">‚ùå Chart.js non charg√© - rechargez la page</div>';
                return;
            }

            const ctx = canvas.getContext('2d');
            log.debug('Number of items:', balancesData.items.length);

            // Traiter les donn√©es pour le graphique avec regroupement par aliases
            const items = balancesData.items || [];
            const filteredItems = items.filter(item => parseFloat(item.value_usd || 0) > 0);

            // Regrouper par aliases
            log.debug('Filtered items for chart:', filteredItems.length);
            const groupedData = groupAssetsByAliases(filteredItems);
            log.debug('Grouped data:', groupedData.length, 'groups');

            // Trier par valeur et prendre les top 8
            const sortedData = groupedData
                .sort((a, b) => b.value - a.value)
                .slice(0, 8);

            const labels = sortedData.map(item => item.label);
            const values = sortedData.map(item => item.value);

            // Use real total from ALL assets, not just top 8 groups shown
            const realTotal = groupedData.reduce((sum, item) => sum + item.value, 0);
            const total = realTotal;

            log.debug('Chart data:', { labels, values, total: total.toFixed(2) });

            // Si aucune donn√©e, afficher un message explicatif
            if (labels.length === 0 || total === 0) {
                console.debug('‚ùå No chart data available, showing placeholder');
                document.getElementById('portfolio-chart').innerHTML = `
                    <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 200px; color: var(--theme-text-muted);">
                        <div style="font-size: 2rem; margin-bottom: 12px;">üìä</div>
                        <div style="font-weight: 600; margin-bottom: 4px;">Donn√©es en cours de chargement</div>
                        <div style="font-size: 0.875rem;">Le graphique s'affichera quand les donn√©es seront disponibles</div>
                    </div>
                `;
                return;
            }

            // D√©truire l'ancien graphique s'il existe
            if (portfolioChart) {
                portfolioChart.destroy();
            }

            // Obtenir les couleurs du th√®me actuel
            const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
            const tooltipBg = isDark ? '#374151' : '#f9fafb';
            const tooltipText = isDark ? '#f9fafb' : '#1f2937';
            const tooltipBorder = isDark ? '#6b7280' : '#d1d5db';

            // Cr√©er le nouveau graphique
            portfolioChart = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: labels,
                    datasets: [{
                        data: values,
                        backgroundColor: PORTFOLIO_COLORS.slice(0, values.length),
                        borderColor: isDark ? '#374151' : '#ffffff',
                        borderWidth: 2,
                        hoverBorderWidth: 3
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            backgroundColor: tooltipBg,
                            titleColor: tooltipText,
                            bodyColor: tooltipText,
                            borderColor: tooltipBorder,
                            borderWidth: 1,
                            cornerRadius: 8,
                            padding: 12,
                            callbacks: {
                                label: function (context) {
                                    const value = context.parsed;
                                    const percentage = ((value / total) * 100).toFixed(1);
                                    const groupData = sortedData[context.dataIndex];
                                    let label = `${context.label}: ${formatUSD(value)} (${percentage}%)`;

                                    // Ajouter les assets du groupe si c'est un groupe
                                    if (groupData.assets && groupData.assets.length > 1) {
                                        label += `\nAssets: ${groupData.assets.join(', ')}`;
                                    }

                                    return label;
                                }
                            }
                        }
                    },
                    cutout: '60%',
                    animation: {
                        animateRotate: true,
                        duration: 1000
                    },
                    interaction: {
                        intersect: false,
                        mode: 'point'
                    }
                }
            });
        }

        // Afficher la liste d√©taill√©e des allocations
        function updatePortfolioBreakdown(balancesData) {
            const container = document.getElementById('breakdown-list');
            // Si le conteneur n'existe pas sur cette page, on sort proprement
            if (!container) {
                return;
            }
            if (!balancesData || !balancesData.items) {
                container.innerHTML = '<div style="color: var(--danger);">‚ùå Pas de donn√©es</div>';
                return;
            }

            const items = balancesData.items || [];
            const filteredItems = items.filter(item => parseFloat(item.value_usd || 0) > 0);

            // Regrouper par aliases comme le graphique
            const groupedData = groupAssetsByAliases(filteredItems);
            const sortedData = groupedData.sort((a, b) => b.value - a.value);
            const total = sortedData.reduce((sum, item) => sum + item.value, 0);

            log.debug('updatePortfolioBreakdown - total:', total, 'groups:', sortedData.length);

            const html = sortedData.map((group, index) => {
                const percentage = ((group.value / total) * 100).toFixed(1);
                const assets = group.assets ? ` (${group.assets.join(', ')})` : '';
                return `
                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 4px 0; border-bottom: 1px solid var(--theme-border);">
                        <span style="color: var(--theme-text);">${group.label}${assets}</span>
                        <span style="font-weight: 600; color: var(--theme-text);">${formatUSD(group.value)} (${percentage}%)</span>
                    </div>
                `;
            }).join('');

            container.innerHTML = html + `
                <div style="display: flex; justify-content: space-between; align-items: center; padding: 8px 0; margin-top: 8px; font-weight: 700; border-top: 2px solid var(--theme-border);">
                    <span>TOTAL</span>
                    <span>${formatUSD(total)} (100%)</span>
                </div>
            `;
        }

        // Toggle pour afficher/cacher la table "D√©tails du portfolio"
        function togglePortfolioDetails() {
            const section = document.getElementById('portfolio-details');
            const arrow = document.getElementById('details-arrow');
            if (!section || !arrow) return;
            if (section.style.display === 'none' || section.style.display === '') {
                section.style.display = 'block';
                arrow.textContent = 'üîΩ';
            } else {
                section.style.display = 'none';
                arrow.textContent = '‚ñ∂Ô∏è';
            }
        }

        // Forcer un refresh des donn√©es avec la source actuelle
        async function forceRefreshData() {
            console.debug('üîÑ Force refresh demand√© par utilisateur');
            console.debug('üìä Current source before refresh:', globalConfig.get('data_source'));
            console.debug('üìä Known source before refresh:', window.lastKnownDataSource);
            
            // Clear any potential caches
            if (window.portfolioChart) {
                window.portfolioChart.destroy();
                window.portfolioChart = null;
            }
            
            // Force reload
            await loadDashboardData();
        }

        // Function for debugging - call from browser console
        window.debugPortfolioData = async function() {
            console.group('üîç Portfolio Data Debug');
            
            const currentSource = globalConfig.get('data_source');
            console.log('Current configured source:', currentSource);
            
            console.log('Testing direct API calls...');
            
            // Test stub source
            try {
                const stubResponse = await fetch(`${globalConfig.get('api_base_url')}/balances/current?source=stub&_t=${Date.now()}`);
                const stubData = await stubResponse.json();
                const stubTotal = stubData.items?.reduce((sum, item) => sum + (item.value_usd || 0), 0) || 0;
                console.log('‚úÖ Stub source API response:', {
                    success: stubResponse.ok,
                    itemCount: stubData.items?.length,
                    totalValue: stubTotal
                });
            } catch (e) {
                console.error('‚ùå Stub source failed:', e);
            }
            
            // Test cointracking source
            try {
                const csvResponse = await fetch(`${globalConfig.get('api_base_url')}/balances/current?source=cointracking&_t=${Date.now()}`);
                const csvData = await csvResponse.json();
                const csvTotal = csvData.items?.reduce((sum, item) => sum + (item.value_usd || 0), 0) || 0;
                console.log('‚úÖ CoinTracking source API response:', {
                    success: csvResponse.ok,
                    itemCount: csvData.items?.length,
                    totalValue: csvTotal
                });
            } catch (e) {
                console.error('‚ùå CoinTracking source failed:', e);
            }
            
            // Test current configured source
            console.log(`Testing current configured source: ${currentSource}`);
            try {
                const currentResponse = await window.loadBalanceData();
                console.log('‚úÖ Current source via loadBalanceData():', {
                    success: currentResponse?.success,
                    source: currentResponse?.source,
                    hasData: !!currentResponse?.data,
                    hasCsvText: !!currentResponse?.csvText,
                    dataItemsCount: currentResponse?.data?.items?.length || 0
                });
                
                if (currentResponse?.data?.items) {
                    const total = currentResponse.data.items.reduce((sum, item) => sum + (item.value_usd || 0), 0);
                    console.log('Calculated total from current source:', total);
                }
            } catch (e) {
                console.error('‚ùå Current source failed:', e);
            }
            
            console.groupEnd();
        };


        // ---- Drag & Drop des cartes du dashboard ----
        (function () {
            const GRID_SELECTOR = '.dashboard-grid';
            const STORAGE_KEY = 'dashboard_card_order_v1';

            let dragEl = null;
            let usingHandle = false;

            document.addEventListener('DOMContentLoaded', () => {
                initCardOrdering();
            });

            function initCardOrdering() {
                const grid = document.querySelector(GRID_SELECTOR);
                if (!grid) return;

                // 1) Restaurer l'ordre sauvegard√©
                restoreOrder(grid);

                // 2) Brancher les events
                grid.querySelectorAll('.card[draggable="true"]').forEach(card => {
                    // Si tu veux drag uniquement via l'ent√™te:
                    const handle = card.querySelector('.card-header');
                    if (handle) {
                        handle.setAttribute('data-drag-handle', 'true');
                        handle.style.cursor = 'move';
                        handle.addEventListener('mousedown', () => usingHandle = true);
                        handle.addEventListener('mouseup', () => usingHandle = false);
                        handle.addEventListener('mouseleave', () => usingHandle = false);
                    }

                    card.addEventListener('dragstart', onDragStart);
                    card.addEventListener('dragend', onDragEnd);
                    card.addEventListener('dragover', onDragOver);
                    card.addEventListener('dragleave', onDragLeave);
                    card.addEventListener('drop', onDrop);
                });

                // Permettre le drop partout dans la grille
                grid.addEventListener('dragover', e => e.preventDefault());
                grid.addEventListener('drop', e => {
                    e.preventDefault();
                    clearDropIndicators(grid);
                    saveOrder(grid);
                });
            }

            function onDragStart(e) {
                // Si handle requis : emp√™cher le drag initi√© ailleurs que sur le handle
                const wantsHandle = true; // passe √† false pour autoriser drag partout
                if (wantsHandle) {
                    const isOnHandle = e.target.closest('[data-drag-handle="true"]');
                    if (!isOnHandle && !usingHandle) {
                        e.preventDefault();
                        return;
                    }
                }
                dragEl = e.currentTarget;
                e.dataTransfer.effectAllowed = 'move';
                // Set data (certains navigateurs exigent une data)
                e.dataTransfer.setData('text/plain', dragEl.id || '');
                dragEl.classList.add('dragging');
            }

            function onDragEnd() {
                if (dragEl) dragEl.classList.remove('dragging');
                dragEl = null;
                usingHandle = false;
            }

            function onDragOver(e) {
                e.preventDefault();
                const card = e.currentTarget;
                if (!dragEl || card === dragEl) return;

                // Feedback visuel
                card.classList.add('drop-target');

                // Insertion live : on calcule si on met avant ou apr√®s la carte survol√©e
                const grid = card.parentElement;
                const above = shouldInsertBefore(e, card);
                if (above) grid.insertBefore(dragEl, card);
                else grid.insertBefore(dragEl, card.nextSibling);
            }

            function onDragLeave(e) {
                e.currentTarget.classList.remove('drop-target');
            }

            function onDrop(e) {
                e.preventDefault();
                e.currentTarget.classList.remove('drop-target');
                const grid = e.currentTarget.parentElement;
                saveOrder(grid);
            }

            function shouldInsertBefore(e, targetCard) {
                const rect = targetCard.getBoundingClientRect();
                // Heuristique : si on est sur la moiti√© sup√©rieure, on ins√®re avant
                return (e.clientY - rect.top) < (rect.height / 2);
            }

            function saveOrder(grid) {
                const order = Array.from(grid.querySelectorAll('.card[draggable="true"]')).map(c => c.id);
                try {
                    localStorage.setItem(STORAGE_KEY, JSON.stringify(order));
                } catch { }
            }

            function restoreOrder(grid) {
                let raw = null;
                try { raw = localStorage.getItem(STORAGE_KEY); } catch { }
                if (!raw) return;

                try {
                    const order = JSON.parse(raw);
                    const map = new Map(Array.from(grid.children).map(el => [el.id, el]));
                    order.forEach(id => {
                        const el = map.get(id);
                        if (el) grid.appendChild(el);
                    });
                } catch { }
            }

            function clearDropIndicators(root) {
                root.querySelectorAll('.drop-target').forEach(el => el.classList.remove('drop-target'));
            }
        })();

    </script>

    <script>
        // Keep the Scores tile in sync when risk-dashboard updates localStorage from another tab
        window.addEventListener('storage', function (e) {
            try {
                if (e.key && e.key.startsWith('risk_score_')) {
                    if (typeof loadScoresData === 'function' && typeof updateScoresDisplay === 'function') {
                        loadScoresData()
                            .then(data => updateScoresDisplay(data))
                            .catch(err => console.warn('Failed to refresh scores from storage event:', err));
                    }
                }
            } catch (_) { /* ignore */ }
        });
    </script>

    <script>
        // Also refresh the Scores tile when returning to this tab
        function refreshScoresFromLocalStorage() {
            try {
                if (typeof loadScoresData === 'function' && typeof updateScoresDisplay === 'function') {
                    loadScoresData()
                        .then(data => updateScoresDisplay(data))
                        .catch(err => console.warn('Failed to refresh scores on focus:', err));
                }
            } catch (_) { /* ignore */ }
        }
        window.addEventListener('focus', refreshScoresFromLocalStorage);
        document.addEventListener('visibilitychange', function () {
            if (!document.hidden) refreshScoresFromLocalStorage();
        });
    </script>

</body>

</html>
