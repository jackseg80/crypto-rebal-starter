<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>üìä Dashboard - Crypto Rebalancer</title>
    <link rel="stylesheet" href="shared-theme.css">
    <link rel="stylesheet" href="theme-compat.css">

    <script src="debug-logger.js"></script>
    <script src="input-validator.js"></script>
    <script src="performance-optimizer.js"></script>
    <script src="global-config.js"></script>
    <script src="shared-header.js"></script>
    <script src="appearance.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            background: var(--theme-background);
            color: var(--theme-text);
            font-family: system-ui, -apple-system, 'Segoe UI', Roboto, Arial, sans-serif;
            line-height: 1.6;
            min-height: 100vh;
        }

        .wrap {
            max-width: 95vw;
            margin: 0 auto;
            padding: 20px;
        }

        .dashboard-grid {
            display: grid;
            gap: 20px;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            margin-top: 20px;
        }

        .card {
            background: var(--theme-surface);
            border: 1px solid var(--theme-border);
            border-radius: var(--radius-lg);
            padding: var(--space-xl);
            transition: all var(--transition-normal);
            box-shadow: var(--shadow-sm);
        }

        .card:hover {
            border-color: var(--brand-primary);
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--space-lg);
            padding-bottom: var(--space-md);
            border-bottom: 1px solid var(--theme-border);
        }

        .card-title {
            font-size: 18px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .card-icon {
            font-size: 24px;
        }

        .metric {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 12px 0;
            padding: 8px 0;
        }

        .metric-label {
            color: var(--theme-text-muted);
            font-size: 14px;
        }

        .metric-value {
            font-weight: 600;
            font-size: 16px;
            color: var(--theme-text);
        }

        .status-badge {
            padding: 4px 8px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .status-active {
            background: var(--success-bg);
            color: var(--success);
            border: 1px solid var(--success);
        }

        .status-warning {
            background: var(--warning-bg);
            color: var(--warning);
            border: 1px solid var(--warning);
        }

        .status-error {
            background: var(--danger-bg);
            color: var(--danger);
            border: 1px solid var(--danger);
        }

        .quick-actions {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 12px;
            margin-top: 16px;
        }

        .action-btn {
            background: var(--brand-primary);
            color: white;
            text-decoration: none;
            padding: var(--space-md) var(--space-lg);
            border-radius: var(--radius-md);
            font-weight: 600;
            text-align: center;
            transition: all var(--transition-normal);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: var(--space-sm);
        }

        .action-btn:hover {
            transform: translateY(-1px);
            box-shadow: var(--shadow-lg);
            background: var(--brand-primary-hover);
        }

        .action-btn.secondary {
            background: var(--theme-surface-elevated);
            color: var(--theme-text);
            border: 1px solid var(--theme-border);
        }

        .action-btn.secondary:hover {
            border-color: var(--brand-primary);
            color: var(--brand-primary);
            background: var(--theme-surface-hover);
        }

        /* Container pour graphique Chart.js */
        .portfolio-chart {
            height: 210px;
            position: relative;
            margin: var(--space-lg) 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .portfolio-chart canvas {
            max-height: 100%;
            max-width: 100%;
        }

        .recent-activity {
            max-height: 300px;
            overflow-y: auto;
        }

        .activity-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: var(--space-sm) 0;
            border-bottom: 1px solid var(--theme-border);
        }

        .activity-item:last-child {
            border-bottom: none;
        }

        .activity-desc {
            color: var(--theme-text-muted);
            font-size: 13px;
        }

        .activity-time {
            color: var(--theme-text-muted);
            font-size: 12px;
        }

        .connections-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 12px;
            margin-top: 12px;
        }

        .connection-item {
            text-align: center;
            padding: var(--space-md);
            border-radius: var(--radius-md);
            border: 1px solid var(--theme-border);
            background: var(--theme-surface-elevated);
        }

        .connection-name {
            font-size: 12px;
            margin-bottom: 4px;
            color: var(--theme-text-muted);
        }

        .loading {
            color: var(--theme-text-muted);
            text-align: center;
            padding: var(--space-xl);
        }

        .error {
            color: var(--danger);
            text-align: center;
            padding: var(--space-xl);
            background: var(--danger-bg);
            border: 1px solid var(--danger);
            border-radius: var(--radius-md);
            margin: var(--space-md) 0;
        }

        @media (max-width: 768px) {
            .dashboard-grid {
                grid-template-columns: 1fr;
            }

            .quick-actions {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>

<body>
    <!-- Header inject√© par shared-header.js -->
    <div class="wrap">
        <div class="dashboard-grid">

            <!-- Portfolio Overview - Disposition am√©lior√©e pour gagner de la place -->
            <div class="card" id="card-portfolio" draggable="true" style="grid-column: span 2;">
                <div class="card-header">
                    <div class="card-title"><span class="card-icon">üí∞</span>Portfolio Overview</div>
                    <div style="display:flex;gap:8px;align-items:center;">
                        <button class="action-btn secondary" style="padding:4px 8px;font-size:12px;"
                            onclick="forceRefreshData()">üîÑ</button>
                        <span class="status-badge status-active" id="portfolio-status">Loading</span>
                    </div>
                </div>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: var(--space-lg);">
                    <!-- Colonne gauche : M√©triques -->
                    <div>
                        <div class="metric">
                            <span class="metric-label">Total Value</span>
                            <span class="metric-value" id="total-value">--</span>
                        </div>

                        <div class="metric">
                            <span class="metric-label">P&L Today</span>
                            <span class="metric-value" id="daily-pnl">--</span>
                        </div>

                        <div class="metric">
                            <span class="metric-label">Assets Count</span>
                            <span class="metric-value" id="assets-count">--</span>
                        </div>
                        <div onclick="togglePortfolioDetails()"
                            style="font-weight: 600; margin-top: var(--space-md); margin-bottom: var(--space-sm); color: var(--theme-text-muted); cursor: pointer; display: flex; align-items: center; gap: var(--space-xs);">
                            <span id="details-arrow">‚ñ∂Ô∏è</span>
                            <span>üìã D√©tails du portfolio</span>
                        </div>

                        <!-- Section portfolio d√©taill√© (cach√©e par d√©faut) -->
                        <div id="portfolio-details" style="display: none;">
                            <table class="data-table">
                                <thead>
                                    <tr>
                                        <th>Coin</th>
                                        <th>Quantit√©</th>
                                        <th>Valeur (USD)</th>
                                        <th>% du portefeuille</th>
                                    </tr>
                                </thead>
                                <tbody id="portfolio-details-body">
                                    <!-- Les lignes sont inject√©es par ton JS -->
                                </tbody>
                            </table>
                        </div>
                    </div>

                    <!-- Colonne droite : Graphique et Breakdown -->
                    <div>
                        <div class="portfolio-chart" id="portfolio-chart">
                            <canvas id="portfolioChartCanvas"></canvas>
                        </div>
                    </div>
                </div>
            </div>


            <!-- Execution Status -->
            <div class="card" id="card-execution" draggable="true">
                <div class="card-header">
                    <div class="card-title"><span class="card-icon">üéØ</span>Execution Status</div>
                    <span class="status-badge" id="execution-status">Loading</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Last Execution</span>
                    <span class="metric-value" id="last-execution">--</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Success Rate (24h)</span>
                    <span class="metric-value" id="success-rate">--</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Total Volume (24h)</span>
                    <span class="metric-value" id="volume-24h">--</span>
                </div>
            </div>

            <!-- Exchange Connections -->
            <div class="card" id="card-exchange" draggable="true">
                <div class="card-header">
                    <div class="card-title"><span class="card-icon">üîó</span>Exchange Status</div>
                    <a href="monitoring_advanced.html" class="status-badge status-active"
                        style="text-decoration:none;">View Details</a>
                </div>
                <div class="connections-grid" id="connections-grid">
                    <div class="loading">Loading connections...</div>
                </div>
            </div>

            <!-- Recent Activity -->
            <div class="card" id="card-activity" draggable="true">
                <div class="card-header">
                    <div class="card-title"><span class="card-icon">üìã</span>Recent Activity</div>
                    <a href="execution_history.html" class="status-badge status-active"
                        style="text-decoration:none;">View All</a>
                </div>
                <div class="recent-activity" id="recent-activity">
                    <div class="loading">Loading recent activity...</div>
                </div>
            </div>

            <!-- System Health -->
            <div class="card" id="card-health" draggable="true">
                <div class="card-header">
                    <div class="card-title"><span class="card-icon">‚ù§Ô∏è</span>System Health</div>
                    <span class="status-badge" id="system-health">Loading</span>
                </div>
                <div class="metric">
                    <span class="metric-label">API Status</span>
                    <span class="metric-value" id="api-status">--</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Data Freshness</span>
                    <span class="metric-value" id="data-freshness">--</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Safety Validator</span>
                    <span class="metric-value" id="safety-status">--</span>
                </div>
            </div>

        </div>
    </div>

    <script>
        // √âtat global
        let dashboardData = { portfolio: null, connections: null, recentActivity: null, executionStats: null };
        let portfolioChart = null;

        document.addEventListener('DOMContentLoaded', async () => {
            console.debug('üìä Dashboard unifi√© initialis√©');
            initSharedHeader('dashboard', { showConfigIndicators: true });

            // Appliquer le th√®me imm√©diatement
            console.debug('Initializing theme for dashboard page...');
            if (window.globalConfig && window.globalConfig.applyTheme) {
                window.globalConfig.applyTheme();
            }
            if (window.applyAppearance) {
                window.applyAppearance();
            }
            console.debug('Current theme after dashboard init:', document.documentElement.getAttribute('data-theme'));

            // Configuration Chart.js avec th√®me
            initChartTheme();

            await loadDashboardData();
            setInterval(loadDashboardData, 60000);

            // √âcouter les changements de th√®me pour synchronisation cross-tab
            window.addEventListener('storage', function (e) {
                const expectedKey = (window.globalConfig?.getStorageKey && window.globalConfig.getStorageKey()) || 'crypto_rebal_settings_v1';
                if (e.key === expectedKey) {
                    console.debug('Settings changed in another tab, reapplying theme...');
                    setTimeout(() => {
                        if (window.globalConfig && window.globalConfig.applyTheme) {
                            window.globalConfig.applyTheme();
                        }
                        if (window.applyAppearance) {
                            window.applyAppearance();
                        }
                        // Refaire le th√®me des graphiques aussi
                        initChartTheme();
                    }, 100);
                }
            });

            window.addEventListener('dataSourceChanged', (event) => {
                console.debug(`üîÑ Source chang√©e: ${event.detail.oldSource} ‚Üí ${event.detail.newSource}`);
                loadDashboardData();
            });
        });

        async function loadDashboardData() {
            try {
                // Charger d'abord les groupes depuis alias-manager
                await loadAssetGroups();

                const [portfolioData, connectionsData, historyData, executionStatus] = await Promise.allSettled([
                    loadPortfolioData(), loadConnectionsStatus(), loadRecentHistory(), loadExecutionStatus()
                ]);
                await updatePortfolioDisplay(portfolioData.status === 'fulfilled' ? portfolioData.value : null);
                updateConnectionsDisplay(connectionsData.status === 'fulfilled' ? connectionsData.value : null);
                updateRecentActivity(historyData.status === 'fulfilled' ? historyData.value : null);
                updateExecutionStatus(executionStatus.status === 'fulfilled' ? executionStatus.value : null);
                updateSystemHealth();

                console.debug('‚úÖ Dashboard data loaded successfully');
            } catch (e) {
                log.error('Erreur chargement dashboard:', e);
                showError('Impossible de charger les donn√©es du dashboard. V√©rifiez votre connexion.');
                showError('Erreur lors du chargement des donn√©es');
            }
        }

        async function loadPortfolioData() {
            try {
                console.debug('üìä Loading REAL CSV data for consistency');
                return await loadRealCSVPortfolioData();
            } catch (e) {
                log.error('Erreur portfolio CSV non disponible:', e);
                showError('Fichier CSV du portfolio non accessible.');
                return null; // Pas de fallback hardcod√©
            }
        }

        async function loadRealCSVPortfolioData() {
            console.debug('üîÑ Loading portfolio data using configured source...');
            const balanceResult = await window.loadBalanceData();

            if (!balanceResult || !balanceResult.success) {
                const msg = balanceResult?.error || 'Failed to load balance data';
                log.error(msg);
                throw new Error(msg);
            }

            let balances;

            if (balanceResult.csvText) {
                // Source CSV locale
                const csvText = balanceResult.csvText;
                balances = parseCSVBalancesAuto(csvText, { thresholdUSD: (window.globalConfig?.get('min_usd_threshold')) ?? 1.0 });
            } else if (balanceResult.data && Array.isArray(balanceResult.data.items)) {
                // Source API
                balances = balanceResult.data.items.map(item => ({
                    symbol: item.symbol,
                    balance: item.balance,
                    value_usd: item.value_usd
                }));
            } else {
                throw new Error('Invalid data format received');
            }

            const totalValue = balances.reduce((sum, it) => sum + (parseFloat(it.value_usd) || 0), 0);
            const assetCount = balances.length;

            console.debug(`‚úÖ REAL data loaded: ${assetCount} assets, total: $${totalValue.toFixed(2)}`);

            return {
                ok: true,
                metrics: {
                    total_value_usd: totalValue,
                    asset_count: assetCount,
                    last_updated: new Date().toISOString()
                },
                performance: {
                    performance_available: true,
                    current_value_usd: totalValue,
                    absolute_change_usd: 2547.33 // mock dev
                },
                balances: {
                    items: balances,
                    total_count: balances.length,
                    timestamp: new Date().toISOString()
                }
            };
        }


        async function loadConnectionsStatus() {
            try {
                return { binance: { name: "Binance", connected: true }, kraken: { name: "Kraken", connected: true }, coinbase: { name: "Coinbase", connected: false } };
            } catch (e) { log.error('Erreur connexions:', e); return null; }
        }


        async function loadRecentHistory() {
            try {
                return {
                    sessions: [
                        { exchange: "Binance", total_orders: 3, successful_orders: 3, total_volume_usd: 1250.50, timestamp: new Date(Date.now() - 3600000).toISOString() },
                        { exchange: "Kraken", total_orders: 2, successful_orders: 2, total_volume_usd: 890.25, timestamp: new Date(Date.now() - 7200000).toISOString() }
                    ]
                };
            } catch (e) { log.error('Erreur historique:', e); return null; }
        }

        async function loadExecutionStatus() {
            try {
                return { recent_24h: { total_orders: 5, success_rate: 96.5, total_volume: 2140.75 } };
            } catch (e) { log.error('Erreur statut ex√©cution:', e); return null; }
        }

        async function updatePortfolioDisplay(data) {
            if (!data || !data.ok) {
                document.getElementById('total-value').textContent = 'Erreur';
                document.getElementById('daily-pnl').textContent = 'Erreur';
                const st = document.getElementById('portfolio-status');
                st.className = 'status-badge status-error'; st.textContent = 'Erreur';
                return;
            }
            const { metrics, performance } = data;

            document.getElementById('total-value').textContent = formatUSD(metrics.total_value_usd || 0);

            const dailyPnl = performance?.absolute_change_usd || 0;
            const pnlEl = document.getElementById('daily-pnl');
            pnlEl.textContent = formatUSD(dailyPnl);
            pnlEl.style.color = dailyPnl >= 0 ? 'var(--success)' : 'var(--danger)';

            document.getElementById('assets-count').textContent = metrics.asset_count || 0;

            const statusEl = document.getElementById('portfolio-status');
            if ((metrics.total_value_usd || 0) > 0) { statusEl.className = 'status-badge status-active'; statusEl.textContent = 'Actif'; }
            else { statusEl.className = 'status-badge status-warning'; statusEl.textContent = 'Vide'; }

            log.debug('About to call updatePortfolioChart with:', data.balances);
            await updatePortfolioChart(data.balances);
            // N'appeler le breakdown que si le conteneur est pr√©sent dans le DOM
            if (document.getElementById('breakdown-list')) {
                updatePortfolioBreakdown(data.balances);
            }
        }
        function updateConnectionsDisplay(data) {
            const container = document.getElementById('connections-grid');
            if (!data) { container.innerHTML = '<div class="error">Erreur de chargement</div>'; return; }

            const html = Object.values(data).map(conn => {
                const cls = conn.connected ? 'status-active' : 'status-error';
                const txt = conn.connected ? 'Online' : 'Offline';
                return `
          <div class="connection-item">
            <div class="connection-name">${conn.name}</div>
            <div class="status-badge ${cls}">${txt}</div>
          </div>`;
            }).join('');
            container.innerHTML = html;
        }

        function updateRecentActivity(data) {
            const container = document.getElementById('recent-activity');
            if (!data || !data.sessions || data.sessions.length === 0) {
                container.innerHTML = `
          <div class="activity-item">
            <div>
              <div>Aucune activit√© r√©cente</div>
              <div class="activity-desc">Les sessions d'ex√©cution appara√Ætront ici</div>
            </div>
            <div class="activity-time">--</div>
          </div>`;
                return;
            }
            const html = data.sessions.slice(0, 5).map(s => `
        <div class="activity-item">
          <div>
            <div>${s.total_orders || 0} ordres sur ${s.exchange || 'Exchange'}</div>
            <div class="activity-desc">${s.successful_orders || 0} r√©ussis, ${formatUSD(s.total_volume_usd || 0)} volume</div>
          </div>
          <div class="activity-time">${formatTimeAgo(s.timestamp)}</div>
        </div>`).join('');
            container.innerHTML = html;
        }

        function updateExecutionStatus(data) {
            if (!data || !data.recent_24h) {
                document.getElementById('last-execution').textContent = 'Aucune';
                document.getElementById('success-rate').textContent = '--';
                document.getElementById('volume-24h').textContent = '$0.00';
                const st = document.getElementById('execution-status'); st.className = 'status-badge status-warning'; st.textContent = 'En attente';
                return;
            }
            document.getElementById('last-execution').textContent = data.recent_24h?.total_orders > 0 ? 'R√©cent' : 'Aucune';
            const sr = data.recent_24h?.success_rate;
            document.getElementById('success-rate').textContent = (sr !== undefined) ? sr.toFixed(1) + '%' : '--';
            document.getElementById('volume-24h').textContent = formatUSD(data.recent_24h?.total_volume || 0);

            const st = document.getElementById('execution-status');
            if (sr >= 95) { st.className = 'status-badge status-active'; st.textContent = 'Excellent'; }
            else if (sr >= 90) { st.className = 'status-badge status-warning'; st.textContent = 'Bon'; }
            else if (sr !== undefined) { st.className = 'status-badge status-error'; st.textContent = '√Ä am√©liorer'; }
            else { st.className = 'status-badge status-warning'; st.textContent = 'En attente'; }
        }

        function updateSystemHealth() {
            document.getElementById('api-status').textContent = 'Online';
            document.getElementById('data-freshness').textContent = 'R√©cente';
            document.getElementById('safety-status').textContent = 'Actif';
            const st = document.getElementById('system-health'); st.className = 'status-badge status-active'; st.textContent = 'Healthy';
        }

        function formatUSD(v) {
            if (!v) return '$0.00';
            return new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD', minimumFractionDigits: 2, maximumFractionDigits: 2 }).format(v);
        }
        function formatTimeAgo(ts) {
            if (!ts) return 'N/A';
            const d = new Date(ts), now = new Date(), dm = Math.floor((now - d) / (1000 * 60));
            if (dm < 60) return `${dm}min`;
            if (dm < 1440) return `${Math.floor(dm / 60)}h`;
            return `${Math.floor(dm / 1440)}j`;
        }
        function showError(m) {
            log.error(m);
            // Afficher l'erreur √† l'utilisateur via UI
            const errorDiv = document.getElementById('error-display') || createErrorDisplay();
            errorDiv.textContent = m;
            errorDiv.style.display = 'block';
            setTimeout(() => errorDiv.style.display = 'none', 5000);
        }

        function createErrorDisplay() {
            const div = document.createElement('div');
            div.id = 'error-display';
            div.style.cssText = `
                position: fixed; top: 20px; right: 20px; z-index: 9999;
                background: var(--theme-error, #ff4444); color: white;
                padding: 12px 16px; border-radius: 8px; max-width: 400px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.2); display: none;
            `;
            document.body.appendChild(div);
            return div;
        }

        // Configuration Chart.js avec th√®me adaptatif
        function initChartTheme() {
            if (typeof Chart !== 'undefined') {
                Chart.defaults.color = 'var(--theme-text)';
                Chart.defaults.borderColor = 'var(--theme-border)';
                Chart.defaults.backgroundColor = 'var(--theme-surface)';
                Chart.defaults.plugins.tooltip.backgroundColor = 'var(--theme-surface-elevated)';
                Chart.defaults.plugins.tooltip.titleColor = 'var(--theme-text)';
                Chart.defaults.plugins.tooltip.bodyColor = 'var(--theme-text)';
                Chart.defaults.plugins.tooltip.borderColor = 'var(--theme-border)';
                Chart.defaults.plugins.tooltip.borderWidth = 1;
            }
        }

        // Couleurs pour le graphique portfolio
        const PORTFOLIO_COLORS = [
            '#3b82f6', '#ef4444', '#10b981', '#f59e0b', '#8b5cf6',
            '#06b6d4', '#84cc16', '#f97316', '#ec4899', '#6366f1'
        ];

        // Classification dynamique - sera charg√©e depuis alias-manager
        let ASSET_GROUPS = null;

        // Charger la classification depuis alias-manager
        async function loadAssetGroups() {
            console.debug('üîç Loading asset groups...');
            await useFallbackAssetGroups();
        }

        async function useFallbackAssetGroups() {
            const fallbackAliases = {
                'BTC': 'BTC', 'TBTC': 'BTC',
                'ETH': 'ETH', 'WETH': 'ETH', 'STETH': 'ETH', 'WSTETH': 'ETH', 'RETH': 'ETH', 'CBETH': 'ETH',
                'USDC': 'Stablecoins', 'USDT': 'Stablecoins', 'USD': 'Stablecoins', 'DAI': 'Stablecoins',
                'SOL': 'L1/L0 majors', 'SOL2': 'L1/L0 majors',
                'ATOM': 'L1/L0 majors', 'ATOM2': 'L1/L0 majors', 'DOT': 'L1/L0 majors', 'DOT2': 'L1/L0 majors', 'ADA': 'L1/L0 majors',
                'AVAX': 'L1/L0 majors', 'NEAR': 'L1/L0 majors', 'LINK': 'L1/L0 majors', 'XRP': 'L1/L0 majors',
                'BCH': 'L1/L0 majors', 'XLM': 'L1/L0 majors', 'LTC': 'L1/L0 majors', 'SUI3': 'L1/L0 majors',
                'BNB': 'Exchange Tokens', 'BGB': 'Exchange Tokens', 'CHSB': 'Exchange Tokens',
                'AAVE': 'DeFi', 'JUPSOL': 'DeFi', 'JITOSOL': 'DeFi', 'FET': 'DeFi',
                'DOGE': 'Memecoins', 'XMR': 'Privacy', 'TRX': 'L1/L0 majors',
                'IMO': 'Others', 'VVV3': 'Others', 'TAO6': 'Others', 'OTHERS': 'Others'
            };

            ASSET_GROUPS = {};
            Object.entries(fallbackAliases).forEach(([asset, group]) => {
                if (!ASSET_GROUPS[group]) {
                    ASSET_GROUPS[group] = [];
                }
                ASSET_GROUPS[group].push(asset);
            });

            console.debug('‚úÖ Asset groups loaded:', Object.keys(ASSET_GROUPS));
        }

        // Parser CSV : wrapper auto qui utilise window.parseCSVBalances si dispo, sinon notre local
        function parseCSVBalancesAuto(csvText, { thresholdUSD = 1.0 } = {}) {
            if (typeof window.parseCSVBalances === 'function') {
                return window.parseCSVBalances(csvText);
            }
            return parseCSVBalancesLocal(csvText, { thresholdUSD });
        }

        // Impl√©mentation locale robuste
        function parseCSVBalancesLocal(csvText, { thresholdUSD = 1.0 } = {}) {
            const cleanedText = csvText.replace(/^\ufeff/, '');
            const lines = cleanedText.split(/\r?\n/);
            const balances = [];
            const minThreshold = (window.globalConfig && window.globalConfig.get('min_usd_threshold')) || thresholdUSD || 1.0;

            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;

                try {
                    const columns = parseCSVLineLocal(line);
                    if (columns.length >= 5) {
                        const ticker = columns[0];
                        const norm = s => parseFloat(String(s).replace(/[,\u00A0]/g, ''));
                        const amount = norm(columns[3]);
                        const valueUSD = norm(columns[4]);

                        if (ticker && !isNaN(amount) && !isNaN(valueUSD) && valueUSD >= minThreshold) {
                            balances.push({
                                symbol: ticker.toUpperCase(),
                                balance: amount,
                                value_usd: valueUSD
                            });
                        }
                    }
                } catch (error) {
                    console.warn('Erreur parsing ligne CSV:', error.message);
                }
            }

            return balances;
        }

        function parseCSVLineLocal(line) {
            const result = [];
            let current = '';
            let inQuotes = false;

            for (let i = 0; i < line.length; i++) {
                const char = line[i];

                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === ';' && !inQuotes) {
                    result.push(current.trim().replace(/^"|"$/g, ''));
                    current = '';
                } else {
                    current += char;
                }
            }

            if (current) {
                result.push(current.trim().replace(/^"|"$/g, ''));
            }

            return result;
        }

        function groupAssetsByAliases(items) {
            const groups = new Map();
            const ungrouped = [];

            log.debug('Grouping', items.length, 'assets by aliases');

            // Si ASSET_GROUPS n'est pas encore charg√©, mettre tout dans "Others"
            if (!ASSET_GROUPS) {
                console.warn('‚ö†Ô∏è ASSET_GROUPS not loaded yet, putting all assets in Others');
                const totalValue = items.reduce((sum, item) => sum + parseFloat(item.value_usd || 0), 0);
                return [{
                    label: 'Others',
                    value: totalValue,
                    assets: items.map(item => item.symbol)
                }];
            }

            items.forEach(item => {
                const symbol = (item.symbol || '').toUpperCase();
                let foundGroup = null;

                // Chercher dans quel groupe appartient ce symbol
                for (const [groupName, aliases] of Object.entries(ASSET_GROUPS)) {
                    if (aliases.includes(symbol)) {
                        foundGroup = groupName;
                        break;
                    }
                }

                if (foundGroup) {
                    if (!groups.has(foundGroup)) {
                        groups.set(foundGroup, {
                            label: foundGroup,
                            value: 0,
                            assets: []
                        });
                    }
                    const group = groups.get(foundGroup);
                    group.value += parseFloat(item.value_usd || 0);
                    group.assets.push(symbol);

                    // Debug log for BTC group specifically
                    if (foundGroup === 'BTC') {
                        log.debug('BTC GROUP: Added', symbol, 'value:', item.value_usd.toFixed(2), 'new total:', group.value.toFixed(2));
                    }

                    // Debug log for significant groupings
                    if (item.value_usd > 5000) {
                        log.debug('Grouped', symbol, 'into', foundGroup, '- value:', item.value_usd.toFixed(2));
                    }
                } else {
                    ungrouped.push({
                        label: symbol,
                        value: parseFloat(item.value_usd || 0)
                    });

                    // Debug log for ungrouped assets
                    if (item.value_usd > 1000) {
                        log.debug('UNGROUPED asset:', symbol, '- value:', item.value_usd.toFixed(2));
                    }
                }
            });

            log.debug('Final groups:', groups.size, 'grouped +', ungrouped.length, 'ungrouped');
            const result = [...Array.from(groups.values()), ...ungrouped];

            // Debug final result - especially BTC group
            result.forEach(group => {
                if (group.label === 'BTC') {
                    log.debug('FINAL BTC GROUP: value:', group.value.toFixed(2), 'assets:', group.assets.join(', '));
                } else if (group.value > 1000) {
                    log.debug('Final group:', group.label, '- value:', group.value.toFixed(2));
                    if (group.assets && group.assets.length > 1) {
                        console.debug('  ‚îî‚îÄ Assets:', group.assets.join(', '));
                    }
                }
            });

            return result;
        }

        // Cr√©er ou mettre √† jour le graphique portfolio
        async function updatePortfolioChart(balancesData) {
            log.debug('updatePortfolioChart - balancesData:', balancesData);

            if (!balancesData || !balancesData.items) {
                console.debug('‚ùå No balances data or items');
                document.getElementById('portfolio-chart').innerHTML = '<div style="text-align: center; padding: 20px; color: var(--warning);">‚è≥ Chargement des donn√©es...</div>';
                return;
            }

            // V√©rifier que ASSET_GROUPS est charg√© - forcer le chargement si n√©cessaire
            if (!ASSET_GROUPS) {
                console.debug('‚ùå ASSET_GROUPS not loaded, loading fallback immediately...');
                await useFallbackAssetGroups();
                // Continue avec ASSET_GROUPS maintenant disponible
            }

            let canvas = document.getElementById('portfolioChartCanvas');
            if (!canvas) {
                console.debug('‚ùå Canvas element not found, creating it...');
                // Cr√©er le canvas manquant
                const chartContainer = document.getElementById('portfolio-chart');
                if (chartContainer) {
                    chartContainer.innerHTML = '<canvas id="portfolioChartCanvas"></canvas>';
                    canvas = document.getElementById('portfolioChartCanvas');
                    console.debug('‚úÖ Canvas element created successfully');
                } else {
                    console.debug('‚ùå Portfolio chart container not found');
                    return;
                }
            }

            // V√©rifier que Chart.js est charg√©
            if (typeof Chart === 'undefined') {
                console.debug('‚ùå Chart.js not loaded, trying to reload...');
                document.getElementById('portfolio-chart').innerHTML = '<div style="text-align: center; padding: 20px; color: var(--danger);">‚ùå Chart.js non charg√© - rechargez la page</div>';
                return;
            }

            const ctx = canvas.getContext('2d');
            log.debug('Number of items:', balancesData.items.length);

            // Traiter les donn√©es pour le graphique avec regroupement par aliases
            const items = balancesData.items || [];
            const filteredItems = items.filter(item => parseFloat(item.value_usd || 0) > 0);

            // Regrouper par aliases
            log.debug('Filtered items for chart:', filteredItems.length);
            const groupedData = groupAssetsByAliases(filteredItems);
            log.debug('Grouped data:', groupedData.length, 'groups');

            // Trier par valeur et prendre les top 8
            const sortedData = groupedData
                .sort((a, b) => b.value - a.value)
                .slice(0, 8);

            const labels = sortedData.map(item => item.label);
            const values = sortedData.map(item => item.value);

            // Use real total from ALL assets, not just top 8 groups shown
            const realTotal = groupedData.reduce((sum, item) => sum + item.value, 0);
            const total = realTotal;

            log.debug('Chart data:', { labels, values, total: total.toFixed(2) });

            // Si aucune donn√©e, afficher un message explicatif
            if (labels.length === 0 || total === 0) {
                console.debug('‚ùå No chart data available, showing placeholder');
                document.getElementById('portfolio-chart').innerHTML = `
                    <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 200px; color: var(--theme-text-muted);">
                        <div style="font-size: 2rem; margin-bottom: 12px;">üìä</div>
                        <div style="font-weight: 600; margin-bottom: 4px;">Donn√©es en cours de chargement</div>
                        <div style="font-size: 0.875rem;">Le graphique s'affichera quand les donn√©es seront disponibles</div>
                    </div>
                `;
                return;
            }

            // D√©truire l'ancien graphique s'il existe
            if (portfolioChart) {
                portfolioChart.destroy();
            }

            // Obtenir les couleurs du th√®me actuel
            const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
            const tooltipBg = isDark ? '#374151' : '#f9fafb';
            const tooltipText = isDark ? '#f9fafb' : '#1f2937';
            const tooltipBorder = isDark ? '#6b7280' : '#d1d5db';

            // Cr√©er le nouveau graphique
            portfolioChart = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: labels,
                    datasets: [{
                        data: values,
                        backgroundColor: PORTFOLIO_COLORS.slice(0, values.length),
                        borderColor: isDark ? '#374151' : '#ffffff',
                        borderWidth: 2,
                        hoverBorderWidth: 3
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            backgroundColor: tooltipBg,
                            titleColor: tooltipText,
                            bodyColor: tooltipText,
                            borderColor: tooltipBorder,
                            borderWidth: 1,
                            cornerRadius: 8,
                            padding: 12,
                            callbacks: {
                                label: function (context) {
                                    const value = context.parsed;
                                    const percentage = ((value / total) * 100).toFixed(1);
                                    const groupData = sortedData[context.dataIndex];
                                    let label = `${context.label}: ${formatUSD(value)} (${percentage}%)`;

                                    // Ajouter les assets du groupe si c'est un groupe
                                    if (groupData.assets && groupData.assets.length > 1) {
                                        label += `\nAssets: ${groupData.assets.join(', ')}`;
                                    }

                                    return label;
                                }
                            }
                        }
                    },
                    cutout: '60%',
                    animation: {
                        animateRotate: true,
                        duration: 1000
                    },
                    interaction: {
                        intersect: false,
                        mode: 'point'
                    }
                }
            });
        }

        // Afficher la liste d√©taill√©e des allocations
        function updatePortfolioBreakdown(balancesData) {
            const container = document.getElementById('breakdown-list');
            // Si le conteneur n'existe pas sur cette page, on sort proprement
            if (!container) {
                return;
            }
            if (!balancesData || !balancesData.items) {
                container.innerHTML = '<div style="color: var(--danger);">‚ùå Pas de donn√©es</div>';
                return;
            }

            const items = balancesData.items || [];
            const filteredItems = items.filter(item => parseFloat(item.value_usd || 0) > 0);

            // Regrouper par aliases comme le graphique
            const groupedData = groupAssetsByAliases(filteredItems);
            const sortedData = groupedData.sort((a, b) => b.value - a.value);
            const total = sortedData.reduce((sum, item) => sum + item.value, 0);

            log.debug('updatePortfolioBreakdown - total:', total, 'groups:', sortedData.length);

            const html = sortedData.map((group, index) => {
                const percentage = ((group.value / total) * 100).toFixed(1);
                const assets = group.assets ? ` (${group.assets.join(', ')})` : '';
                return `
                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 4px 0; border-bottom: 1px solid var(--theme-border);">
                        <span style="color: var(--theme-text);">${group.label}${assets}</span>
                        <span style="font-weight: 600; color: var(--theme-text);">${formatUSD(group.value)} (${percentage}%)</span>
                    </div>
                `;
            }).join('');

            container.innerHTML = html + `
                <div style="display: flex; justify-content: space-between; align-items: center; padding: 8px 0; margin-top: 8px; font-weight: 700; border-top: 2px solid var(--theme-border);">
                    <span>TOTAL</span>
                    <span>${formatUSD(total)} (100%)</span>
                </div>
            `;
        }

        // Toggle pour afficher/cacher la table "D√©tails du portfolio"
        function togglePortfolioDetails() {
            const section = document.getElementById('portfolio-details');
            const arrow = document.getElementById('details-arrow');
            if (!section || !arrow) return;
            if (section.style.display === 'none' || section.style.display === '') {
                section.style.display = 'block';
                arrow.textContent = 'üîΩ';
            } else {
                section.style.display = 'none';
                arrow.textContent = '‚ñ∂Ô∏è';
            }
        }

        // Forcer un refresh des donn√©es avec la source actuelle
        async function forceRefreshData() {
            console.debug('üîÑ Force refresh demand√© par utilisateur');
            // Vider le cache si n√©cessaire
            await loadDashboardData();
        }


        // ---- Drag & Drop des cartes du dashboard ----
        (function () {
            const GRID_SELECTOR = '.dashboard-grid';
            const STORAGE_KEY = 'dashboard_card_order_v1';

            let dragEl = null;
            let usingHandle = false;

            document.addEventListener('DOMContentLoaded', () => {
                initCardOrdering();
            });

            function initCardOrdering() {
                const grid = document.querySelector(GRID_SELECTOR);
                if (!grid) return;

                // 1) Restaurer l'ordre sauvegard√©
                restoreOrder(grid);

                // 2) Brancher les events
                grid.querySelectorAll('.card[draggable="true"]').forEach(card => {
                    // Si tu veux drag uniquement via l'ent√™te:
                    const handle = card.querySelector('.card-header');
                    if (handle) {
                        handle.setAttribute('data-drag-handle', 'true');
                        handle.style.cursor = 'move';
                        handle.addEventListener('mousedown', () => usingHandle = true);
                        handle.addEventListener('mouseup', () => usingHandle = false);
                        handle.addEventListener('mouseleave', () => usingHandle = false);
                    }

                    card.addEventListener('dragstart', onDragStart);
                    card.addEventListener('dragend', onDragEnd);
                    card.addEventListener('dragover', onDragOver);
                    card.addEventListener('dragleave', onDragLeave);
                    card.addEventListener('drop', onDrop);
                });

                // Permettre le drop partout dans la grille
                grid.addEventListener('dragover', e => e.preventDefault());
                grid.addEventListener('drop', e => {
                    e.preventDefault();
                    clearDropIndicators(grid);
                    saveOrder(grid);
                });
            }

            function onDragStart(e) {
                // Si handle requis : emp√™cher le drag initi√© ailleurs que sur le handle
                const wantsHandle = true; // passe √† false pour autoriser drag partout
                if (wantsHandle) {
                    const isOnHandle = e.target.closest('[data-drag-handle="true"]');
                    if (!isOnHandle && !usingHandle) {
                        e.preventDefault();
                        return;
                    }
                }
                dragEl = e.currentTarget;
                e.dataTransfer.effectAllowed = 'move';
                // Set data (certains navigateurs exigent une data)
                e.dataTransfer.setData('text/plain', dragEl.id || '');
                dragEl.classList.add('dragging');
            }

            function onDragEnd() {
                if (dragEl) dragEl.classList.remove('dragging');
                dragEl = null;
                usingHandle = false;
            }

            function onDragOver(e) {
                e.preventDefault();
                const card = e.currentTarget;
                if (!dragEl || card === dragEl) return;

                // Feedback visuel
                card.classList.add('drop-target');

                // Insertion live : on calcule si on met avant ou apr√®s la carte survol√©e
                const grid = card.parentElement;
                const above = shouldInsertBefore(e, card);
                if (above) grid.insertBefore(dragEl, card);
                else grid.insertBefore(dragEl, card.nextSibling);
            }

            function onDragLeave(e) {
                e.currentTarget.classList.remove('drop-target');
            }

            function onDrop(e) {
                e.preventDefault();
                e.currentTarget.classList.remove('drop-target');
                const grid = e.currentTarget.parentElement;
                saveOrder(grid);
            }

            function shouldInsertBefore(e, targetCard) {
                const rect = targetCard.getBoundingClientRect();
                // Heuristique : si on est sur la moiti√© sup√©rieure, on ins√®re avant
                return (e.clientY - rect.top) < (rect.height / 2);
            }

            function saveOrder(grid) {
                const order = Array.from(grid.querySelectorAll('.card[draggable="true"]')).map(c => c.id);
                try {
                    localStorage.setItem(STORAGE_KEY, JSON.stringify(order));
                } catch { }
            }

            function restoreOrder(grid) {
                let raw = null;
                try { raw = localStorage.getItem(STORAGE_KEY); } catch { }
                if (!raw) return;

                try {
                    const order = JSON.parse(raw);
                    const map = new Map(Array.from(grid.children).map(el => [el.id, el]));
                    order.forEach(id => {
                        const el = map.get(id);
                        if (el) grid.appendChild(el);
                    });
                } catch { }
            }

            function clearDropIndicators(root) {
                root.querySelectorAll('.drop-target').forEach(el => el.classList.remove('drop-target'));
            }
        })();

    </script>
</body>

</html>
