<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>üìä Dashboard - Crypto Rebalancer</title>
    <link rel="stylesheet" href="shared-theme.css">
    <link rel="stylesheet" href="theme-compat.css">
    <script type="module" src="components/nav.js"></script>
    <script type="module" src="components/tooltips.js"></script>
    <script type="module">
        import { initDeepLinks } from './components/deep-links.js';
        // Ancres pour dashboard.html : #overview #crypto #bourse #banque #divers #fx
        initDeepLinks({
            'overview': 'Vue d\'ensemble',
            'crypto': 'Crypto Portfolio',
            'bourse': 'Actions & ETF',
            'banque': 'Comptes bancaires',
            'divers': 'Actifs divers',
            'fx': 'Devises & Changes'
        });
    </script>

    <script src="debug-logger.js"></script>
    <script src="input-validator.js"></script>
    <script src="performance-optimizer.js"></script>
    <script src="global-config.js"></script>
    <script src="appearance.js"></script>
    <script type="module">
        // INTELLIGENT GLOBAL INSIGHT - Using sophisticated unified intelligence
        import { getUnifiedState, deriveRecommendations } from './core/unified-insights-v2.js';
        import { store } from './core/risk-dashboard-store.js';
        import { UNIFIED_ASSET_GROUPS, getAssetGroup, groupAssetsByClassification } from './shared-asset-groups.js';
        import { selectCapPercent, selectPolicyCapPercent, selectEngineCapPercent } from './selectors/governance.js';
        // Note: fetchSaxoSummary imported dynamically in refreshSaxoTile() to avoid scope issues

        const colorForScore = (s) => s > 70 ? 'var(--danger)' : s >= 40 ? 'var(--warning)' : 'var(--success)';

        async function refreshGI() {
            try {
                console.debug('üß† Refreshing Global Insight with intelligent analysis...');

                // Use sophisticated unified intelligence
                const unifiedState = await getUnifiedState();
                console.debug('‚úÖ Unified state loaded:', {
                    decision_score: unifiedState.decision?.score,
                    cycle_score: unifiedState.cycle?.score,
                    onchain_score: unifiedState.onchain?.score,
                    risk_score: unifiedState.risk?.score
                });
                const recommendations = deriveRecommendations(unifiedState);

                // Update Decision Index with confidence
                const scoreEl = document.getElementById('gi-score');
                if (scoreEl) {
                    scoreEl.textContent = unifiedState.decision.score;
                    scoreEl.style.color = colorForScore(unifiedState.decision.score);

                    // Add confidence tooltip if available
                    if (unifiedState.decision.confidence) {
                        scoreEl.title = `Confiance: ${Math.round(unifiedState.decision.confidence * 100)}% | ${unifiedState.decision.reasoning || 'Calcul intelligent'}`;
                    }
                }

                // Update component scores with enhanced data
                const cycleEl = document.getElementById('gi-cycle');
                if (cycleEl) {
                    const cycleScore = unifiedState.cycle?.score ?? '--';
                    const cyclePhase = unifiedState.cycle?.phase?.phase;
                    cycleEl.textContent = cycleScore;
                    cycleEl.title = cyclePhase ? `Phase: ${cyclePhase.replace('_', ' ')} | Confiance: ${Math.round((unifiedState.cycle?.confidence || 0) * 100)}%` : '';
                }

                const onchainEl = document.getElementById('gi-onchain');
                if (onchainEl) {
                    let onchainScore = unifiedState.onchain?.score;
                    if (onchainScore == null) {
                        const user = localStorage.getItem('activeUser') || 'demo';
                        const lsOn = Number(localStorage.getItem(`risk_score_onchain:${user}`) || localStorage.getItem('risk_score_onchain'));
                        if (Number.isFinite(lsOn)) onchainScore = Math.round(lsOn);
                    }
                    onchainEl.textContent = (onchainScore != null) ? onchainScore : '--';
                    if (unifiedState.onchain?.criticalCount > 0) {
                        onchainEl.title = `${unifiedState.onchain.criticalCount} indicateur(s) critique(s) d√©tect√©(s)`;
                        onchainEl.style.fontWeight = '700';
                    }
                }

                const riskEl = document.getElementById('gi-risk');
                if (riskEl) {
                    let riskScore = unifiedState.risk?.score;
                    if (riskScore == null) {
                        const user = localStorage.getItem('activeUser') || 'demo';
                        const lsRisk = Number(localStorage.getItem(`risk_score_risk:${user}`) || localStorage.getItem('risk_score_risk'));
                        if (Number.isFinite(lsRisk)) riskScore = Math.round(lsRisk);
                    }
                    riskEl.textContent = (riskScore != null) ? riskScore : '--';
                    if (unifiedState.risk?.budget?.percentages?.stables) {
                        riskEl.title = `Budget recommand√© - Stables: ${unifiedState.risk.budget.percentages.stables}%`;
                    }
                }

                // INTELLIGENT RECOMMENDATIONS from sophisticated modules
                const recoEl = document.getElementById('gi-reco');
                if (recoEl) {
                    if (recommendations.length > 0) {
                        const topReco = recommendations[0];
                        const urgencyIcon = topReco.priority === 'critical' ? 'üö®' : topReco.priority === 'high' ? '‚ö†Ô∏è' : topReco.priority === 'medium' ? 'üí°' : '‚ÑπÔ∏è';
                        recoEl.innerHTML = `${urgencyIcon} ${topReco.title}`;
                        recoEl.title = `${topReco.reason} | Source: ${topReco.source || 'Intelligence unifi√©e'}`;

                        // Color based on priority
                        const priorityColors = {
                            'critical': 'var(--danger)',
                            'high': 'var(--danger)',
                            'medium': 'var(--warning)',
                            'low': 'var(--info)'
                        };
                        recoEl.style.color = priorityColors[topReco.priority] || 'var(--theme-text)';
                    } else {
                        recoEl.innerHTML = 'üßò Aucune action urgente';
                        recoEl.style.color = 'var(--success)';
                        recoEl.title = 'Tous les modules sont en accord - situation stable';
                    }
                }

                console.debug('‚úÖ Global Insight refreshed with:', {
                    decision_score: unifiedState.decision.score,
                    confidence: unifiedState.decision.confidence,
                    recommendations_count: recommendations.length,
                    top_recommendation: recommendations[0]?.title
                });

                // Update the meta badge with governance data
                updateGlobalInsightMeta();

            } catch (error) {
                debugLogger.warn('‚ö†Ô∏è Global Insight fallback to simple calculation:', error);
                console.debug('Error details:', error.stack || error);

                // Fallback to simple calculation if intelligent system fails
                const st = store.snapshot();
                const blended = st.scores?.blended ?? null;
                const cycle = Math.round(st.cycle?.ccsStar ?? st.cycle?.score ?? 0);
                const onch = st.scores?.onchain ?? null;
                const risk = st.scores?.risk ?? null;
                const score = blended != null ? Math.round(blended) : Math.round(((cycle || 50) * 0.5) + ((onch ?? 50) * 0.3) + ((100 - (risk ?? 50)) * 0.2));

                const el = document.getElementById('gi-score');
                if (el) { el.textContent = score; el.style.color = colorForScore(score); }

                const ec = document.getElementById('gi-cycle'); if (ec) ec.textContent = cycle || '--';
                const eo = document.getElementById('gi-onchain'); if (eo) eo.textContent = onch != null ? Math.round(onch) : '--';
                const er = document.getElementById('gi-risk'); if (er) er.textContent = risk != null ? Math.round(risk) : '--';

                const reco = document.getElementById('gi-reco');
                if (reco) {
                    reco.textContent = score >= 70 ? '‚ö†Ô∏è All√©ger 10‚Äì20%' : score <= 35 ? 'üü¢ DCA prudent' : '‚è∏Ô∏è Neutre / Attente';
                    reco.title = 'Recommandation basique (syst√®me intelligent non disponible)';
                }

                // Update meta badge even in fallback
                updateGlobalInsightMeta();
            }
        }

        // SMART LOADING - Load data directly if not available in store
        async function loadUnifiedDataForDashboard() {
            try {
                debugLogger.debug('üîÑ Loading unified data for dashboard...');

                // Import and run the same cache-intelligent loader from analytics-unified
                const { getCurrentCycleMonths, cycleScoreFromMonths, getCyclePhase } = await import('./modules/cycle-navigator.js');

                // 1. Cycle data (quick calculation)
                const c = getCurrentCycleMonths();
                const cycleScore = Math.round(cycleScoreFromMonths(c.months));
                const phase = getCyclePhase(c.months);
                store.set('cycle.months', c.months);
                store.set('cycle.score', cycleScore);
                store.set('cycle.phase', phase);
                // Hydrate governance state to prefer backend Decision Engine
                try {
                    await store.syncGovernanceState();
                    await store.syncMLSignals();
                } catch { }
                debugLogger.debug('‚úÖ Cycle data loaded for dashboard');

                // 2. Try to get cached scores from localStorage (from analytics-unified cache)
                const getCachedScore = (key) => {
                    try {
                        const user = localStorage.getItem('activeUser') || 'demo';
                        const ds = (window.globalConfig && window.globalConfig.get('data_source')) || 'unknown';
                        const fullKey = `${key}_${user}_${ds}`;
                        const cached = localStorage.getItem(fullKey) || localStorage.getItem(key);
                        if (!cached) return null;
                        const data = JSON.parse(cached);
                        const age = Date.now() - data.timestamp;
                        // Use cache if less than 15 minutes old
                        if (age < 15 * 60 * 1000) {
                            return data.data;
                        }
                    } catch { }
                    return null;
                };

                // Try cached on-chain data
                const cachedOnchain = getCachedScore('analytics_unified_onchain');
                if (cachedOnchain && typeof cachedOnchain.score === 'number') {
                    store.set('scores.onchain', cachedOnchain.score);
                    store.set('scores.onchain_metadata', cachedOnchain.metadata);
                    debugLogger.debug('‚úÖ On-chain data loaded from cache for dashboard');
                }

                // Try cached risk data
                const cachedRisk = getCachedScore('analytics_unified_risk');
                if (cachedRisk && cachedRisk.risk_metrics?.risk_score) {
                    store.set('scores.risk', cachedRisk.risk_metrics.risk_score);
                    store.set('risk.risk_metrics', cachedRisk.risk_metrics); // Full risk metrics for sophisticated analysis
                    debugLogger.debug('‚úÖ Risk data loaded from cache for dashboard');
                }

                // Try cached blended data
                const cachedBlended = getCachedScore('analytics_unified_blended');
                if (cachedBlended && typeof cachedBlended.score === 'number') {
                    store.set('scores.blended', cachedBlended.score);
                    debugLogger.debug('‚úÖ Blended score loaded from cache for dashboard');
                } else {
                    // Calculate blended if we have component scores
                    // ‚úÖ Respecte docs/RISK_SEMANTICS.md - Risk Score utilis√© directement (pas d'inversion)
                    const state = store.snapshot();
                    const cycleScore = state.cycle?.score ?? 50;
                    const onchainScore = state.scores?.onchain ?? 50;
                    const riskScore = state.scores?.risk ?? 50;
                    const blended = (cycleScore * 0.50) + (onchainScore * 0.30) + (riskScore * 0.20);
                    const blendedScore = Math.round(Math.max(0, Math.min(100, blended)));
                    store.set('scores.blended', blendedScore);
                    debugLogger.debug('‚úÖ Blended score calculated for dashboard');
                }

                // Ensure basic CCS signals data is available for sophisticated modules
                const state = store.snapshot();
                if (!state.ccs?.signals) {
                    store.set('ccs.signals', {
                        fear_greed: { value: 50 },
                        btc_dominance: { value: 57.5 },
                        funding_rate: { value: 0.0001 }
                    });
                    debugLogger.debug('‚úÖ Basic CCS signals data initialized for dashboard');
                }

                debugLogger.debug('üéØ Dashboard data loading completed');
                refreshGI();

            } catch (error) {
                debugLogger.error('‚ùå Error loading dashboard data:', error);
                // Fallback to basic calculation
                refreshGI();
            }
        }

        async function waitForStoreReady() {
            const state = store.snapshot();
            const hasBlended = typeof state.scores?.blended === 'number';
            const hasPartialScores = state.cycle?.score != null && state.scores?.onchain != null && state.scores?.risk != null;

            if (hasBlended) {
                debugLogger.debug('üéØ Store ready with blended data, refreshing Global Insight');
                if (typeof state.risk?.risk_budget?.target_stables_pct !== 'number') {
                    try {
                        const { calculateRiskBudget } = await import('./modules/market-regimes.js');
                        const riskBudget = calculateRiskBudget(state.scores.blended, state.scores.risk ?? null);
                        store.set('risk.risk_budget', riskBudget);
                        console.debug('‚úÖ Synthesized risk budget fallback:', { target_stables_pct: riskBudget.target_stables_pct });
                    } catch (fallbackError) {
                        debugLogger.warn('‚ö†Ô∏è Unable to synthesize risk budget fallback:', fallbackError);
                    }
                }
                refreshGI();
                return;
            }

            if (hasPartialScores) {
                debugLogger.debug('üîÅ Partial store data, running unified loader to compute blended score...');
                await loadUnifiedDataForDashboard();
                return;
            }

            debugLogger.debug('‚è≥ No store data, loading directly for dashboard...');
            await loadUnifiedDataForDashboard();
        }

        // Update Global Insight meta badge with governance data
        function updateGlobalInsightMeta() {
            try {
                const metaEl = document.getElementById('gi-meta');
                if (!metaEl) return;

                // Get data from store
                const ml = store.get('governance.ml_signals');
                const state = (typeof store.snapshot === 'function' ? store.snapshot() : store.getState?.()) || window.realDataStore || {};

                // Format timestamp
                const ts = ml?.timestamp ? new Date(ml.timestamp) : null;
                const timeStr = ts ? ts.toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit', second: '2-digit' }) : '--:--:--';

                // Get contradiction index (0-1 scale, convert to percentage)
                const contradiction = ml?.contradiction_index != null ? Math.round(ml.contradiction_index * 100) : null;

                const policyCap = selectPolicyCapPercent(state);
                const engineCap = selectEngineCapPercent(state);
                const effectiveCap = selectCapPercent(state);

                const badges = [`Updated: ${timeStr}`];
                if (contradiction !== null) badges.push(`Contrad: ${contradiction}%`);
                if (policyCap != null) {
                    let capLabel = `Cap: ${policyCap}%`;
                    if (engineCap != null && engineCap !== policyCap) {
                        capLabel += ` ‚Ä¢ SMART ${engineCap}%`;
                    }
                    badges.push(capLabel);
                } else if (effectiveCap != null) {
                    badges.push(`Cap: ${effectiveCap}%`);
                } else {
                    badges.push('Cap: ‚Äî');
                }

                metaEl.textContent = badges.join(' ‚Ä¢ ');

                console.debug('üè∑Ô∏è Global Insight meta updated:', {
                    timestamp: timeStr,
                    contradiction,
                    policyCap,
                    engineCap,
                    effectiveCap,
                    text: metaEl.textContent
                });

            } catch (error) {
                debugLogger.warn('Failed to update Global Insight meta:', error);
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            // Subscribe to store changes for reactive updates
            store.subscribe(() => {
                clearTimeout(window.giRefreshTimer);
                window.giRefreshTimer = setTimeout(() => {
                    refreshGI();
                    updateGlobalInsightMeta();
                }, 300);
            });

            // Smart initial load - wait for data to be ready
            setTimeout(waitForStoreReady, 800); // Give time for analytics-unified to start loading
        });
    </script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            background: var(--theme-background);
            color: var(--theme-text);
            font-family: system-ui, -apple-system, 'Segoe UI', Roboto, Arial, sans-serif;
            line-height: 1.6;
            min-height: 100vh;
        }

        .wrap {
            max-width: 95vw;
            margin: 0 auto;
            padding: 20px;
        }

        .dashboard-grid {
            display: grid;
            gap: 20px;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            margin-top: 20px;
        }

        .card {
            background: var(--theme-surface);
            border: 1px solid var(--theme-border);
            border-radius: var(--radius-lg);
            padding: var(--space-xl);
            transition: all var(--transition-normal);
            box-shadow: var(--shadow-sm);
        }

        .card:hover {
            border-color: var(--brand-primary);
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--space-lg);
            padding-bottom: var(--space-md);
            border-bottom: 1px solid var(--theme-border);
        }

        .card-title {
            font-size: 18px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .card-icon {
            font-size: 24px;
        }

        .metric {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 12px 0;
            padding: 8px 0;
        }

        .metric-label {
            color: var(--theme-text-muted);
            font-size: 14px;
        }

        .metric-value {
            font-weight: 600;
            font-size: 16px;
            color: var(--theme-text);
        }

        .status-badge {
            padding: 4px 8px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .status-active {
            background: var(--success-bg);
            color: var(--success);
            border: 1px solid var(--success);
        }

        .status-warning {
            background: var(--warning-bg);
            color: var(--warning);
            border: 1px solid var(--warning);
        }

        .status-error {
            background: var(--danger-bg);
            color: var(--danger);
            border: 1px solid var(--danger);
        }

        .quick-actions {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 12px;
            margin-top: 16px;
        }

        .action-btn {
            background: var(--brand-primary);
            color: white;
            text-decoration: none;
            padding: var(--space-md) var(--space-lg);
            border-radius: var(--radius-md);
            font-weight: 600;
            text-align: center;
            transition: all var(--transition-normal);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: var(--space-sm);
        }

        .action-btn:hover {
            transform: translateY(-1px);
            box-shadow: var(--shadow-lg);
            background: var(--brand-primary-hover);
        }

        .action-btn.secondary {
            background: var(--theme-surface-elevated);
            color: var(--theme-text);
            border: 1px solid var(--theme-border);
        }

        .action-btn.secondary:hover {
            border-color: var(--brand-primary);
            color: var(--brand-primary);
            background: var(--theme-surface-hover);
        }

        /* Container pour graphique Chart.js */
        .portfolio-chart {
            height: 210px;
            position: relative;
            margin: var(--space-lg) 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .portfolio-chart canvas {
            max-height: 100%;
            max-width: 100%;
        }

        .recent-activity {
            max-height: 300px;
            overflow-y: auto;
        }

        .activity-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: var(--space-sm) 0;
            border-bottom: 1px solid var(--theme-border);
        }

        .activity-item:last-child {
            border-bottom: none;
        }

        .activity-desc {
            color: var(--theme-text-muted);
            font-size: 13px;
        }

        .activity-time {
            color: var(--theme-text-muted);
            font-size: 12px;
        }

        .connections-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 12px;
            margin-top: 12px;
        }

        .connection-item {
            text-align: center;
            padding: var(--space-md);
            border-radius: var(--radius-md);
            border: 1px solid var(--theme-border);
            background: var(--theme-surface-elevated);
        }

        .connection-name {
            font-size: 12px;
            margin-bottom: 4px;
            color: var(--theme-text-muted);
        }

        .loading {
            color: var(--theme-text-muted);
            text-align: center;
            padding: var(--space-xl);
        }

        .error {
            color: var(--danger);
            text-align: center;
            padding: var(--space-xl);
            background: var(--danger-bg);
            border: 1px solid var(--danger);
            border-radius: var(--radius-md);
            margin: var(--space-md) 0;
        }

        @media (max-width: 768px) {
            .dashboard-grid {
                grid-template-columns: 1fr;
            }

            .quick-actions {
                grid-template-columns: 1fr;
            }
        }
    </style>


</head>

<body>
    <div class="wrap">
        <div class="dashboard-grid">
            <!-- Global Insight (Unified view) -->
            <div class="card" id="overview" draggable="true"
                data-tooltip="Vue unifi√©e: d√©cision, cycle, on-chain, risque, sentiment"
                data-source="Scores unifi√©s du Risk Dashboard">
                <div class="card-header">
                    <a href="analytics-unified.html" class="card-title" style="text-decoration: none; color: inherit;">
                        <span class="card-icon">üß≠</span> Global Insight
                    </a>
                </div>
                <div style="display:flex; justify-content:space-between; align-items:center; gap:12px;">
                    <div>
                        <div style="font-size:.85rem; color: var(--theme-text-muted); font-weight:600;">Decision Index
                        </div>
                        <div id="gi-score" style="font-size:2rem; font-weight:800;">--</div>
                    </div>
                    <div style="text-align:right; font-size:.85rem; color: var(--theme-text-muted);">
                        <div>Cycle: <span id="gi-cycle">--</span></div>
                        <div>On‚ÄëChain: <span id="gi-onchain">--</span></div>
                        <div>Risque: <span id="gi-risk">--</span></div>
                    </div>
                </div>
                <div id="gi-reco" style="margin-top:.5rem; font-size:.9rem; color: var(--theme-text);"></div>
                <div id="gi-meta"
                    style="text-align:center; font-size:11px; color:var(--theme-text-muted); margin-top:8px; padding-top:8px; border-top:1px solid var(--theme-border);">
                </div>
            </div>

            <!-- Portfolio Overview - Disposition am√©lior√©e pour gagner de la place -->
            <div class="card" id="crypto" draggable="true" style="grid-column: span 2;"
                data-tooltip="Vue d'ensemble compl√®te de votre portefeuille crypto avec r√©partition, m√©triques de performance et graphiques en temps r√©el."
                data-source="API /balances/current + prix CoinGecko/CoinGlass">
                <div class="card-header">
                    <div class="card-title">Portfolio Overview</div>
                    <div style="display:flex;gap:8px;align-items:center;">
                        <span id="portfolio-source-display"
                            style="font-size:11px;color:var(--theme-text-muted);padding:2px 6px;background:var(--theme-bg);border-radius:4px;border:1px solid var(--theme-border);">--</span>
                        <button class="action-btn secondary" style="padding:4px 8px;font-size:12px;"
                            onclick="forceRefreshData()">üîÑ</button>
                        <span class="status-badge status-active" id="portfolio-status">Loading</span>
                    </div>
                </div>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: var(--space-lg);">
                    <!-- Colonne gauche : M√©triques -->
                    <div>
                        <div class="metric">
                            <span class="metric-label">Total Value</span>
                            <span class="metric-value" id="total-value">--</span>
                        </div>

                        <div class="metric">
                            <span class="metric-label">P&L Today</span>
                            <span class="metric-value" id="daily-pnl">--</span>
                        </div>

                        <div class="metric">
                            <span class="metric-label">Assets Count</span>
                            <span class="metric-value" id="assets-count">--</span>
                        </div>
                    </div>

                    <!-- Colonne droite : Graphique et Breakdown -->
                    <div>
                        <div class="portfolio-chart" id="portfolio-chart">
                            <canvas id="portfolioChartCanvas"></canvas>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Bourse (Saxo) - Lecture legacy -->
            <div class="card" id="bourse" draggable="true"
                data-tooltip="Vue d'ensemble de votre portefeuille d'actions et ETF via Saxo Bank en lecture seule."
                data-source="API /api/saxo/positions (legacy)">
                <div class="card-header">
                    <div class="card-title"><span class="card-icon">üè¶</span>Bourse (Saxo)</div>
                    <div style="display:flex;gap:8px;align-items:center;">
                        <button class="action-btn secondary" style="padding:4px 8px;font-size:12px;"
                            onclick="refreshSaxoTile()">üîÑ</button>
                        <span class="status-badge" id="saxo-status">Loading</span>
                    </div>
                </div>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: var(--space-lg);">
                    <!-- Colonne gauche : M√©triques -->
                    <div>
                        <div class="metric">
                            <span class="metric-label">Valeur Totale</span>
                            <span class="metric-value" id="saxo-total-value">--</span>
                        </div>

                        <div class="metric">
                            <span class="metric-label">Positions</span>
                            <span class="metric-value" id="saxo-positions-count">--</span>
                        </div>

                        <div class="metric">
                            <span class="metric-label">Dernier Import</span>
                            <span class="metric-value" id="saxo-last-import" style="font-size:0.9rem;">--</span>
                        </div>
                    </div>

                    <!-- Colonne droite : Actions -->
                    <div style="display:flex;flex-direction:column;justify-content:center;gap:12px;">
                        <a href="saxo-dashboard.html"
                           class="action-btn primary"
                           style="text-decoration:none;text-align:center;padding:12px;font-weight:600;">
                            üìä Voir le d√©tail
                        </a>

                        <div id="saxo-empty-state" style="display:none;text-align:center;color:var(--theme-text-muted);font-size:0.85rem;">
                            Aucune position Saxo.<br>
                            <a href="settings.html#sources" style="color:var(--theme-accent);">Importez un fichier dans Settings</a>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Execution Status -->
            <div class="card" id="card-execution" draggable="true"
                data-tooltip="Statut des ex√©cutions automatiques de trades avec historique des performances et volumes trait√©s."
                data-source="API /execution/status + logs internes">
                <div class="card-header">
                    <div class="card-title"><span class="card-icon">üéØ</span>Execution Status</div>
                    <span class="status-badge" id="execution-status">Loading</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Last Execution</span>
                    <span class="metric-value" id="last-execution">--</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Success Rate (24h)</span>
                    <span class="metric-value" id="success-rate">--</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Total Volume (24h)</span>
                    <span class="metric-value" id="volume-24h">--</span>
                </div>
            </div>

            <!-- Exchange Connections -->
            <div class="card" id="card-exchange" draggable="true"
                data-tooltip="√âtat des connexions avec les exchanges (Binance, KuCoin) et v√©rification des API keys."
                data-source="Tests de connectivit√© API en temps r√©el">
                <div class="card-header">
                    <div class="card-title"><span class="card-icon">üîó</span>Exchange Status</div>
                    <a href="monitoring.html" class="status-badge status-active" style="text-decoration:none;">View
                        Details</a>
                </div>
                <div class="connections-grid" id="connections-grid">
                    <div class="loading">Loading connections...</div>
                </div>
            </div>

            <!-- Recent Activity -->
            <div class="card" id="card-activity" draggable="true"
                data-tooltip="Historique des derni√®res op√©rations de trading, rebalancing et √©v√©nements syst√®me."
                data-source="API /execution/history + logs syst√®me">
                <div class="card-header">
                    <div class="card-title"><span class="card-icon">üìã</span>Recent Activity</div>
                    <a href="execution_history.html" class="status-badge status-active"
                        style="text-decoration:none;">View All</a>
                </div>
                <div class="recent-activity" id="recent-activity">
                    <div class="loading">Loading recent activity...</div>
                </div>
            </div>

            <!-- System Health -->
            <div class="card" id="card-health" draggable="true"
                data-tooltip="Surveillance de la sant√© du syst√®me : APIs, fra√Æcheur des donn√©es et validateurs de s√©curit√©."
                data-source="Monitoring interne + tests API">
                <div class="card-header">
                    <div class="card-title"><span class="card-icon">‚ù§Ô∏è</span>System Health</div>
                    <span class="status-badge" id="system-health">Loading</span>
                </div>
                <div class="metric">
                    <span class="metric-label">API Status</span>
                    <span class="metric-value" id="api-status">--</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Data Freshness</span>
                    <span class="metric-value" id="data-freshness">--</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Safety Validator</span>
                    <span class="metric-value" id="safety-status">--</span>
                </div>
            </div>

            <!-- Scores -->
            <div class="card" id="card-scores" draggable="true"
                data-tooltip="Scores de performance et m√©triques calcul√©s par les algorithmes ML pour √©valuer le portefeuille."
                data-source="API /analytics/scores + mod√®les ML">
                <div class="card-header">
                    <a href="risk-dashboard.html" class="card-title" style="text-decoration: none; color: inherit;">
                        Scores
                    </a>
                    <span class="status-badge" id="scores-status">Loading</span>
                </div>
                <div id="scores-content">
                    <div class="loading">Chargement des scores...</div>
                </div>
            </div>

            <!-- Debug & New Modules -->
            <div class="card" id="card-debug" draggable="true"
                data-tooltip="Acc√®s rapide aux outils de debug et aux nouveaux modules : Analytics, AI, Optimisation et Performance."
                data-source="Liens internes et outils d√©veloppeur">
                <div class="card-header">
                    <div class="card-title"><span class="card-icon">üîß</span>Debug & Nouveaux Modules</div>
                    <a href="debug-menu.html" class="status-badge status-active" style="text-decoration:none;">Menu
                        Complet</a>
                </div>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; padding: 12px;">
                    <a href="analytics-unified.html"
                        style="color: var(--theme-accent); text-decoration: none; padding: 8px; border: 1px solid var(--theme-border); border-radius: 6px; text-align: center; font-size: 0.9em;">
                        üìä Analytics
                    </a>
                    <a href="ai-dashboard.html"
                        style="color: var(--theme-accent); text-decoration: none; padding: 8px; border: 1px solid var(--theme-border); border-radius: 6px; text-align: center; font-size: 0.9em;">
                        ü§ñ AI Dashboard
                    </a>
                    <a href="portfolio-optimization.html"
                        style="color: var(--theme-accent); text-decoration: none; padding: 8px; border: 1px solid var(--theme-border); border-radius: 6px; text-align: center; font-size: 0.9em;">
                        üéØ Optimisation+
                    </a>
                    <a href="/api/performance/cache/stats" target="_blank"
                        style="color: var(--theme-accent); text-decoration: none; padding: 8px; border: 1px solid var(--theme-border); border-radius: 6px; text-align: center; font-size: 0.9em;">
                        ‚ö° Performance
                    </a>
                </div>
                <div
                    style="padding: 8px 12px; font-size: 0.8em; color: var(--theme-text-secondary); border-top: 1px solid var(--theme-border);">
                    4 nouveaux syst√®mes: Performance (4.8x), Multi-actifs (7 classes), Charts interactifs, Optimisation
                    avanc√©e
                </div>
            </div>

        </div>
    </div>

    <script>
        // √âtat global
        let dashboardData = { portfolio: null, connections: null, recentActivity: null, executionStats: null };
        let portfolioChart = null;

        document.addEventListener('DOMContentLoaded', async () => {
            console.debug('üìä Dashboard unifi√© initialis√©');
            // Navigation th√©matique initialis√©e automatiquement

            // Appliquer le th√®me imm√©diatement
            console.debug('Initializing theme for dashboard page...');
            if (window.globalConfig && window.globalConfig.applyTheme) {
                window.globalConfig.applyTheme();
            }
            if (window.applyAppearance) {
                window.applyAppearance();
            }
            console.debug('Current theme after dashboard init:', document.documentElement.getAttribute('data-theme'));

            // Configuration Chart.js avec th√®me
            initChartTheme();

            // Initialize data source tracking for cross-tab synchronization
            window.lastKnownDataSource = globalConfig.get('data_source');
            console.debug(`üìä Dashboard initialized with data source: ${window.lastKnownDataSource}`);

            await loadDashboardData();
            setInterval(loadDashboardData, 60000);

            // Initialize Saxo tile
            await refreshSaxoTile();
            setInterval(refreshSaxoTile, 120000); // Refresh every 2 minutes

            // Also check for data source changes more frequently (every 5 seconds)
            setInterval(() => {
                const currentSource = globalConfig.get('data_source');
                if (currentSource && currentSource !== window.lastKnownDataSource) {
                    console.debug(`üîÑ Periodic check: Data source changed from ${window.lastKnownDataSource} to ${currentSource}`);
                    window.lastKnownDataSource = currentSource;
                    loadDashboardData();
                }
            }, 5000);

            // √âcouter les changements de th√®me et source pour synchronisation cross-tab
            window.addEventListener('storage', function (e) {
                const expectedKey = (window.globalConfig?.getStorageKey && window.globalConfig.getStorageKey()) || 'crypto_rebal_settings_v1';
                if (e.key === expectedKey) {
                    console.debug('Settings changed in another tab, checking for theme and data source changes...');

                    // Check if data source changed
                    const currentSource = globalConfig.get('data_source');
                    const previousSource = window.lastKnownDataSource;

                    if (currentSource && currentSource !== previousSource) {
                        console.debug(`üîÑ Data source changed from ${previousSource} to ${currentSource}, reloading dashboard...`);
                        console.debug('üîÑ Storage event triggered data source change - forcing portfolio refresh...');
                        window.lastKnownDataSource = currentSource;

                        // Clear portfolio chart cache on source change
                        if (window.portfolioChart) {
                            window.portfolioChart.destroy();
                            window.portfolioChart = null;
                        }

                        loadDashboardData();
                    }

                    // Apply theme changes
                    setTimeout(() => {
                        if (window.globalConfig && window.globalConfig.applyTheme) {
                            window.globalConfig.applyTheme();
                        }
                        if (window.applyAppearance) {
                            window.applyAppearance();
                        }
                        // Refaire le th√®me des graphiques aussi
                        initChartTheme();
                    }, 100);
                }
            });

            window.addEventListener('dataSourceChanged', (event) => {
                console.debug(`üîÑ Source chang√©e: ${event.detail.oldSource} ‚Üí ${event.detail.newSource}`);
                console.debug('üîÑ Forcing complete portfolio refresh due to data source change...');

                // Clear portfolio cache when source changes
                if (window.portfolioChart) {
                    window.portfolioChart.destroy();
                    window.portfolioChart = null;
                }

                // Update the known source immediately
                window.lastKnownDataSource = event.detail.newSource;

                // Force complete reload of dashboard data
                loadDashboardData();
            });

            // Reformat values when display currency changes
            window.addEventListener('configChanged', (ev) => {
                try {
                    const key = ev?.detail?.key;
                    if (key === 'display_currency') {
                        console.debug('üí± Display currency changed, re-rendering amounts...');
                        const cur = (window.globalConfig && window.globalConfig.get('display_currency')) || 'USD';
                        const maybeRender = () => {
                            if (dashboardData && dashboardData.portfolio) {
                                updatePortfolioDisplay(dashboardData.portfolio);
                            }
                            if (dashboardData && dashboardData.recentActivity) {
                                updateRecentActivity(dashboardData.recentActivity);
                            }
                            if (dashboardData && dashboardData.executionStats) {
                                updateExecutionStatus(dashboardData.executionStats);
                            }
                        };
                        if (window.currencyManager && cur !== 'USD') {
                            window.currencyManager.ensureRate(cur).then(maybeRender).catch(maybeRender);
                        } else {
                            maybeRender();
                        }
                    }
                } catch (e) {
                    debugLogger.warn('Currency change re-render failed:', e);
                }
                // Update meta badge (Updated / Contrad / Cap)
                updateGlobalInsightMeta();
            });

            // Also re-render when async rate fetch completes
            window.addEventListener('currencyRateUpdated', () => {
                try {
                    if (dashboardData && dashboardData.portfolio) updatePortfolioDisplay(dashboardData.portfolio);
                    if (dashboardData && dashboardData.recentActivity) updateRecentActivity(dashboardData.recentActivity);
                    if (dashboardData && dashboardData.executionStats) updateExecutionStatus(dashboardData.executionStats);
                } catch (e) { debugLogger.warn('Re-render on rate update failed:', e); }
            });
        });

        async function loadDashboardData() {
            try {
                // Clear any potential cached data
                const currentTimestamp = Date.now();
                console.debug(`üîÑ loadDashboardData called at ${currentTimestamp} with source: ${globalConfig.get('data_source')}`);

                // Charger d'abord les groupes depuis alias-manager
                await loadAssetGroups();

                const [portfolioData, connectionsData, historyData, executionStatus, scoresData] = await Promise.allSettled([
                    loadPortfolioData(), loadConnectionsStatus(), loadRecentHistory(), loadExecutionStatus(), loadScoresData()
                ]);
                const portfolioResult = portfolioData.status === 'fulfilled' ? portfolioData.value : null;
                console.debug('üìä About to update portfolio display with:', {
                    hasData: !!portfolioResult,
                    totalValue: portfolioResult?.metrics?.total_value_usd,
                    assetCount: portfolioResult?.metrics?.asset_count
                });
                // Store for re-rendering on currency change
                dashboardData.portfolio = portfolioResult;
                dashboardData.connections = connectionsData.status === 'fulfilled' ? connectionsData.value : null;
                dashboardData.recentActivity = historyData.status === 'fulfilled' ? historyData.value : null;
                dashboardData.executionStats = executionStatus.status === 'fulfilled' ? executionStatus.value : null;

                await updatePortfolioDisplay(dashboardData.portfolio);
                updateConnectionsDisplay(dashboardData.connections);
                updateRecentActivity(dashboardData.recentActivity);
                updateExecutionStatus(dashboardData.executionStats);
                updateScoresDisplay(scoresData.status === 'fulfilled' ? scoresData.value : null);
                updateSystemHealth();

                console.debug('‚úÖ Dashboard data loaded successfully');
            } catch (e) {
                log.error('Erreur chargement dashboard:', e);
                showError('Impossible de charger les donn√©es du dashboard. V√©rifiez votre connexion.');
                showError('Erreur lors du chargement des donn√©es');
            }
        }

        async function loadPortfolioData() {
            try {
                const currentSource = globalConfig.get('data_source');
                console.debug(`üìä Loading REAL portfolio data with source: ${currentSource}`);
                return await loadRealCSVPortfolioData();
            } catch (e) {
                log.error('Erreur portfolio CSV non disponible:', e);
                showError('Fichier CSV du portfolio non accessible.');
                return null; // Pas de fallback hardcod√©
            }
        }

        // Fallback function to load CSV directly when API is not available
        async function loadDirectCSV() {
            const configuredSource = globalConfig.get('data_source');
            console.debug(`üìÑ Loading CSV files directly for source: ${configuredSource}`);

            // Only use direct CSV access for cointracking source
            if (configuredSource === 'cointracking') {
                const csvFiles = [
                    'data/raw/CoinTracking - Current Balance.csv',
                    'data/raw/CoinTracking - Balance by Exchange - 26.08.2025.csv'
                ];

                for (const csvFile of csvFiles) {
                    try {
                        debugLogger.debug(`üìÑ Attempting to load: ${csvFile}`);
                        const response = await fetch(csvFile);
                        if (response.ok) {
                            const csvText = await response.text();
                            debugLogger.debug(`‚úÖ Successfully loaded ${csvFile} (${csvText.length} characters)`);
                            return {
                                success: true,
                                csvText: csvText,
                                source: 'csv_direct',
                                file: csvFile
                            };
                        }
                    } catch (fileError) {
                        debugLogger.debug(`‚ö†Ô∏è Could not load ${csvFile}:`, fileError.message);
                    }
                }
            } else {
                // For stub sources or others, create fallback stub data
                console.debug(`üìä Creating fallback stub data for source: ${configuredSource}`);
                return createStubBalanceData(configuredSource);
            }

            return {
                success: false,
                error: `No data accessible for source: ${configuredSource}`,
                source: configuredSource
            };
        }

        // Create fallback stub data based on configured source
        function createStubBalanceData(source) {
            const stubData = {
                stub_conservative: [
                    { symbol: 'BTC', balance: 0.5, value_usd: 50000, price_change_percentage_24h: 2.1 },
                    { symbol: 'ETH', balance: 5, value_usd: 20000, price_change_percentage_24h: 1.8 },
                    { symbol: 'USDC', balance: 10000, value_usd: 10000, price_change_percentage_24h: 0.1 }
                ],
                stub_balanced: [
                    { symbol: 'BTC', balance: 1.5, value_usd: 150000, price_change_percentage_24h: -1.2 },
                    { symbol: 'ETH', balance: 10, value_usd: 40000, price_change_percentage_24h: -2.5 },
                    { symbol: 'SOL', balance: 100, value_usd: 15000, price_change_percentage_24h: 3.2 },
                    { symbol: 'LINK', balance: 500, value_usd: 12000, price_change_percentage_24h: 1.5 },
                    { symbol: 'USDT', balance: 8000, value_usd: 8000, price_change_percentage_24h: 0.0 }
                ],
                stub_shitcoins: [
                    { symbol: 'DOGE', balance: 100000, value_usd: 20000, price_change_percentage_24h: 15.2 },
                    { symbol: 'SHIB', balance: 50000000, value_usd: 15000, price_change_percentage_24h: -8.5 },
                    { symbol: 'PEPE', balance: 1000000000, value_usd: 10000, price_change_percentage_24h: 25.7 },
                    { symbol: 'BONK', balance: 2000000, value_usd: 5000, price_change_percentage_24h: -12.3 }
                ]
            };

            const balances = stubData[source] || stubData['stub_balanced'];

            return {
                success: true,
                data: { items: balances, source_used: source + '_fallback' },
                source: source + '_fallback'
            };
        }

        async function loadRealCSVPortfolioData() {
            console.debug('üîÑ Loading portfolio data using configured source...');
            const currentSource = globalConfig.get('data_source');
            console.debug(`üìä Using data source: ${currentSource}`);

            // Update source display (show actual CSV filename when using CSV files)
            const sourceDisplay = document.getElementById('portfolio-source-display');
            if (sourceDisplay) {
                let displaySource = currentSource || 'Unknown';

                // If using cointracking source, try to get the actual CSV filename
                if (displaySource === 'cointracking') {
                    try {
                        const userSettings = await fetch('/api/users/settings', {
                            headers: { 'X-User': localStorage.getItem('activeUser') || 'demo' }
                        }).then(r => r.ok ? r.json() : null);

                        const csvFileName = userSettings?.csv_selected_file;
                        if (csvFileName) {
                            displaySource = csvFileName;
                        } else {
                            displaySource = 'cointracking_csv';
                        }
                    } catch (e) {
                        displaySource = 'cointracking_csv';
                    }
                }
                sourceDisplay.textContent = displaySource;
            }

            // Load balances first (original working code)
            console.debug('üì° About to call window.loadBalanceData()...');
            let balanceResult;

            try {
                balanceResult = await window.loadBalanceData();
                console.debug('üìä Balance result received:', {
                    success: balanceResult?.success,
                    source: balanceResult?.source,
                    hasData: !!balanceResult?.data,
                    hasCsvText: !!balanceResult?.csvText,
                    dataItemsCount: balanceResult?.data?.items?.length || 0
                });
            } catch (error) {
                debugLogger.warn('üìä API not available, trying direct CSV access...', error.message);
                // Fallback: try direct CSV access since API is not available
                balanceResult = await loadDirectCSV();
            }

            if (!balanceResult || !balanceResult.success) {
                const msg = balanceResult?.error || 'Failed to load balance data';
                log.error(msg);
                throw new Error(msg);
            }

            let balances;

            if (balanceResult.csvText) {
                // Source CSV locale
                const csvText = balanceResult.csvText;
                const minThreshold = (window.globalConfig && window.globalConfig.get('min_usd_threshold')) || 1.0;
                balances = parseCSVBalancesAuto(csvText, { thresholdUSD: minThreshold });
            } else if (balanceResult.data && Array.isArray(balanceResult.data.items)) {
                // Source API
                balances = balanceResult.data.items.map(item => ({
                    symbol: item.symbol,
                    balance: item.balance,
                    value_usd: item.value_usd
                }));
            } else {
                throw new Error('Invalid data format received');
            }

            const totalValue = balances.reduce((sum, it) => sum + (parseFloat(it.value_usd) || 0), 0);
            const assetCount = balances.length;

            console.debug(`‚úÖ REAL data loaded: ${assetCount} assets, total: $${totalValue.toFixed(2)}`);
            console.debug('üìä Final portfolio metrics calculated:', {
                source: currentSource,
                totalValue: totalValue,
                assetCount: assetCount,
                sampleAssets: balances.slice(0, 5).map(b => `${b.symbol}: $${b.value_usd}`)
            });

            // Try to fetch P&L from API (non-blocking)
            let performance = {
                performance_available: false,
                current_value_usd: totalValue,
                absolute_change_usd: 0
            };

            try {
                const activeUser = localStorage.getItem('activeUser') || 'demo';
                const pnlUrl = `${window.location.origin}/portfolio/metrics?source=${currentSource}&user_id=${activeUser}`;
                const pnlResponse = await fetch(pnlUrl);

                if (pnlResponse.ok) {
                    const pnlData = await pnlResponse.json();
                    if (pnlData.ok && pnlData.performance && pnlData.performance.performance_available) {
                        performance = pnlData.performance;
                        debugLogger.debug('‚úÖ [PNL] P&L loaded from API:', {
                            pnl: performance.absolute_change_usd,
                            pnlPct: performance.percentage_change
                        });
                    }
                }
            } catch (e) {
                debugLogger.warn('‚ö†Ô∏è Could not fetch P&L from API:', e.message);
            }

            return {
                ok: true,
                metrics: {
                    total_value_usd: totalValue,
                    asset_count: assetCount,
                    last_updated: new Date().toISOString()
                },
                performance: performance,
                balances: {
                    items: balances,
                    total_count: balances.length,
                    timestamp: new Date().toISOString()
                }
            };
        }


        async function loadConnectionsStatus() {
            try {
                return { binance: { name: "Binance", connected: true }, kraken: { name: "Kraken", connected: true }, coinbase: { name: "Coinbase", connected: false } };
            } catch (e) { log.error('Erreur connexions:', e); return null; }
        }


        async function loadRecentHistory() {
            try {
                return {
                    sessions: [
                        { exchange: "Binance", total_orders: 3, successful_orders: 3, total_volume_usd: 1250.50, timestamp: new Date(Date.now() - 3600000).toISOString() },
                        { exchange: "Kraken", total_orders: 2, successful_orders: 2, total_volume_usd: 890.25, timestamp: new Date(Date.now() - 7200000).toISOString() }
                    ]
                };
            } catch (e) { log.error('Erreur historique:', e); return null; }
        }

        async function loadExecutionStatus() {
            try {
                return { recent_24h: { total_orders: 5, success_rate: 96.5, total_volume: 2140.75 } };
            } catch (e) { log.error('Erreur statut ex√©cution:', e); return null; }
        }

        // Charger les donn√©es de score depuis le risk dashboard
        async function loadScoresData() {
            try {
                console.debug('üìä Loading scores data...');

                // Essayer de r√©cup√©rer les scores depuis localStorage (stock√©s par risk-dashboard)
                const __user = localStorage.getItem('activeUser') || 'demo';
                const get = (k) => localStorage.getItem(`${k}:${__user}`) || localStorage.getItem(k);
                const scores = {
                    onchain: get('risk_score_onchain'),
                    risk: get('risk_score_risk'),
                    blended: get('risk_score_blended'),
                    ccs: get('risk_score_ccs'),
                    timestamp: get('risk_score_timestamp')
                };

                // V√©rifier si au moins un score est disponible et r√©cent (moins de 5 minutes)
                let hasValidScores = false;
                const result = {};

                if (scores.timestamp) {
                    const age = Date.now() - parseInt(scores.timestamp);
                    // Accepter les scores jusqu'√† 12 heures, marquer "stale" plus tard si besoin
                    if (age < 12 * 60 * 60 * 1000) { // 12 heures
                        result.timestamp = parseInt(scores.timestamp);

                        // Ajouter chaque score disponible
                        if (scores.onchain && scores.onchain !== '') {
                            result.onchain = parseFloat(scores.onchain);
                            hasValidScores = true;
                        }
                        if (scores.risk && scores.risk !== '') {
                            result.risk = parseFloat(scores.risk);
                            hasValidScores = true;
                        }
                        if (scores.blended && scores.blended !== '') {
                            result.blended = parseFloat(scores.blended);
                            hasValidScores = true;
                        }
                        if (scores.ccs && scores.ccs !== '') {
                            result.ccs = parseFloat(scores.ccs);
                            hasValidScores = true;
                        }
                    }
                }

                if (hasValidScores) {
                    console.debug('‚úÖ Scores loaded from localStorage:', result);
                    return result;
                }

                // Fallback: utiliser le cache persistant du risk-dashboard (12h TTL)
                try {
                    const cached = localStorage.getItem('risk_scores_cache');
                    if (cached) {
                        const entry = JSON.parse(cached);
                        const data = entry?.data || {};
                        const ts = entry?.timestamp;
                        const out = {};
                        if (typeof data.onchainScore === 'number') out.onchain = data.onchainScore;
                        if (typeof data.riskScore === 'number') out.risk = data.riskScore;
                        if (typeof data.blendedScore === 'number') out.blended = data.blendedScore;
                        if (typeof data.ccsScore === 'number') out.ccs = data.ccsScore;
                        if (typeof ts === 'number') out.timestamp = ts;
                        if (Object.keys(out).length > 0) {
                            console.debug('‚úÖ Scores loaded from persistent cache:', out);
                            return out;
                        }
                    }
                } catch (cacheErr) {
                    debugLogger.warn('Failed to read persistent risk scores cache:', cacheErr);
                }

                // Si pas de scores disponibles, retourner null
                console.debug('‚ö†Ô∏è No scores available (localStorage or cache)');
                return null;

            } catch (e) {
                log.error('Erreur chargement scores:', e);
                return null;
            }
        }

        async function updatePortfolioDisplay(data) {
            console.debug('üìä updatePortfolioDisplay called with:', {
                hasData: !!data,
                isOk: data?.ok,
                totalValue: data?.metrics?.total_value_usd,
                assetCount: data?.metrics?.asset_count
            });

            if (!data || !data.ok) {
                console.debug('‚ùå Portfolio data invalid or missing, showing error');
                document.getElementById('total-value').textContent = 'Erreur';
                document.getElementById('daily-pnl').textContent = 'Erreur';
                const st = document.getElementById('portfolio-status');
                st.className = 'status-badge status-error'; st.textContent = 'Erreur';
                return;
            }
            const { metrics, performance } = data;

            document.getElementById('total-value').textContent = formatUSD(metrics.total_value_usd || 0);

            const dailyPnl = performance?.absolute_change_usd || 0;
            const dailyPnlPct = performance?.percentage_change || 0;
            debugLogger.debug('üîç [PNL Display] Values:', {
                raw_performance: performance,
                absolute_change_usd: performance?.absolute_change_usd,
                percentage_change: performance?.percentage_change,
                dailyPnl: dailyPnl,
                dailyPnlPct: dailyPnlPct,
                formatted: formatUSD(dailyPnl)
            });
            const pnlEl = document.getElementById('daily-pnl');

            // Format: "+25,833.28$ (+6.11%)" ou "-1,234.56$ (-2.34%)"
            const pnlSign = dailyPnl >= 0 ? '+' : '';
            const pctSign = dailyPnlPct >= 0 ? '+' : '';
            const pnlText = `${pnlSign}${formatUSD(dailyPnl)} (${pctSign}${dailyPnlPct.toFixed(2)}%)`;

            pnlEl.textContent = pnlText;
            pnlEl.style.color = dailyPnl >= 0 ? 'var(--success)' : 'var(--danger)';

            document.getElementById('assets-count').textContent = metrics.asset_count || 0;

            console.debug('‚úÖ Portfolio display updated:', {
                totalValueDisplayed: document.getElementById('total-value').textContent,
                assetsCountDisplayed: document.getElementById('assets-count').textContent,
                sourceDisplayed: document.getElementById('portfolio-source-display')?.textContent
            });

            const statusEl = document.getElementById('portfolio-status');
            if ((metrics.total_value_usd || 0) > 0) { statusEl.className = 'status-badge status-active'; statusEl.textContent = 'Actif'; }
            else { statusEl.className = 'status-badge status-warning'; statusEl.textContent = 'Vide'; }

            log.debug('About to call updatePortfolioChart with:', data.balances);
            await updatePortfolioChart(data.balances);
            // N'appeler le breakdown que si le conteneur est pr√©sent dans le DOM
            if (document.getElementById('breakdown-list')) {
                await updatePortfolioBreakdown(data.balances);
            }
        }
        function updateConnectionsDisplay(data) {
            const container = document.getElementById('connections-grid');
            if (!data) { container.innerHTML = '<div class="error">Erreur de chargement</div>'; return; }

            const html = Object.values(data).map(conn => {
                const cls = conn.connected ? 'status-active' : 'status-error';
                const txt = conn.connected ? 'Online' : 'Offline';
                return `
          <div class="connection-item">
            <div class="connection-name">${conn.name}</div>
            <div class="status-badge ${cls}">${txt}</div>
          </div>`;
            }).join('');
            container.innerHTML = html;
        }

        function updateRecentActivity(data) {
            const container = document.getElementById('recent-activity');
            if (!data || !data.sessions || data.sessions.length === 0) {
                container.innerHTML = `
          <div class="activity-item">
            <div>
              <div>Aucune activit√© r√©cente</div>
              <div class="activity-desc">Les sessions d'ex√©cution appara√Ætront ici</div>
            </div>
            <div class="activity-time">--</div>
          </div>`;
                return;
            }
            const html = data.sessions.slice(0, 5).map(s => `
        <div class="activity-item">
          <div>
            <div>${s.total_orders || 0} ordres sur ${s.exchange || 'Exchange'}</div>
            <div class="activity-desc">${s.successful_orders || 0} r√©ussis, ${formatUSD(s.total_volume_usd || 0)} volume</div>
          </div>
          <div class="activity-time">${formatTimeAgo(s.timestamp)}</div>
        </div>`).join('');
            container.innerHTML = html;
        }

        function updateExecutionStatus(data) {
            if (!data || !data.recent_24h) {
                document.getElementById('last-execution').textContent = 'Aucune';
                document.getElementById('success-rate').textContent = '--';
                document.getElementById('volume-24h').textContent = '$0.00';
                const st = document.getElementById('execution-status'); st.className = 'status-badge status-warning'; st.textContent = 'En attente';
                return;
            }
            document.getElementById('last-execution').textContent = data.recent_24h?.total_orders > 0 ? 'R√©cent' : 'Aucune';
            const sr = data.recent_24h?.success_rate;
            document.getElementById('success-rate').textContent = (sr !== undefined) ? sr.toFixed(1) + '%' : '--';
            document.getElementById('volume-24h').textContent = formatUSD(data.recent_24h?.total_volume || 0);

            const st = document.getElementById('execution-status');
            if (sr >= 95) { st.className = 'status-badge status-active'; st.textContent = 'Excellent'; }
            else if (sr >= 90) { st.className = 'status-badge status-warning'; st.textContent = 'Bon'; }
            else if (sr !== undefined) { st.className = 'status-badge status-error'; st.textContent = '√Ä am√©liorer'; }
            else { st.className = 'status-badge status-warning'; st.textContent = 'En attente'; }
        }

        function updateSystemHealth() {
            document.getElementById('api-status').textContent = 'Online';
            document.getElementById('data-freshness').textContent = 'R√©cente';
            document.getElementById('safety-status').textContent = 'Actif';
            const st = document.getElementById('system-health'); st.className = 'status-badge status-active'; st.textContent = 'Healthy';
        }

        // Mettre √† jour l'affichage des scores
        function updateScoresDisplay(scoresData) {
            const container = document.getElementById('scores-content');
            const statusEl = document.getElementById('scores-status');

            if (!scoresData) {
                // Aucun score disponible - afficher message avec lien vers risk-dashboard
                container.innerHTML = `
                    <div style="text-align: center; padding: var(--space-lg); color: var(--theme-text-muted);">
                        <div style="font-size: 2rem; margin-bottom: var(--space-md);">üìä</div>
                        <div style="margin-bottom: var(--space-md);">Aucun score de risque disponible</div>
                        <a href="risk-dashboard.html"
                    </div>
                `;
                if (statusEl) {
                    statusEl.className = 'status-badge status-warning';
                    statusEl.textContent = 'Donn√©es manquantes';
                }
                return;
            }

            // Scores disponibles - afficher les valeurs disponibles
            const { onchain, risk, blended, ccs, timestamp } = scoresData;
            const STALE_MINUTES = 30; // au-del√†: afficher l'√©tiquette Cache
            const ageMin = timestamp ? Math.round((Date.now() - timestamp) / 60000) : null;
            const isStale = ageMin != null && ageMin >= STALE_MINUTES;

            // D√©terminer les couleurs en fonction des scores (rouge >70, orange 40-70, vert <40)
            const getScoreColor = (score) => {
                if (score > 70) return 'var(--danger)';
                if (score >= 40) return 'var(--warning)';
                return 'var(--success)';
            };

            const getScoreLabel = (score) => {
                if (score > 70) return '√âlev√©';
                if (score >= 40) return 'Moyen';
                return 'Faible';
            };

            let scoresHTML = '';

            // Afficher chaque score disponible
            if (blended !== undefined && blended !== null) {
                scoresHTML += `
                    <div class="metric" style="margin: 6px 0;">
                        <span class="metric-label">‚öñÔ∏è Score Strat√©gique</span>
                        <span class="metric-value" style="color: ${getScoreColor(blended)};">
                            ${Math.round(blended)}/100
                            <span style="font-size: 0.8em; color: var(--theme-text-muted);">(${getScoreLabel(blended)})</span>
                        </span>
                    </div>
                `;
            }

            if (ccs !== undefined && ccs !== null) {
                scoresHTML += `
                    <div class="metric" style="margin: 6px 0;">
                        <span class="metric-label">üìä CCS Score</span>
                        <span class="metric-value" style="color: ${getScoreColor(ccs)};">
                            ${Math.round(ccs)}/100
                            <span style="font-size: 0.8em; color: var(--theme-text-muted);">(${getScoreLabel(ccs)})</span>
                        </span>
                    </div>
                `;
            }

            if (onchain !== undefined && onchain !== null) {
                scoresHTML += `
                    <div class="metric" style="margin: 6px 0;">
                        <span class="metric-label">üîó On-Chain</span>
                        <span class="metric-value" style="color: ${getScoreColor(onchain)};">
                            ${Math.round(onchain)}/100
                            <span style="font-size: 0.8em; color: var(--theme-text-muted);">(${getScoreLabel(onchain)})</span>
                        </span>
                    </div>
                `;
            }

            if (risk !== undefined && risk !== null) {
                scoresHTML += `
                    <div class="metric" style="margin: 6px 0;">
                        <span class="metric-label">üõ°Ô∏è Risk</span>
                        <span class="metric-value" style="color: ${getScoreColor(risk)};">
                            ${Math.round(risk)}/100
                            <span style="font-size: 0.8em; color: var(--theme-text-muted);">(${getScoreLabel(risk)})</span>
                        </span>
                    </div>
                `;
            }

            // Message pour les scores manquants
            if (scoresHTML === '') {
                scoresHTML = `
                    <div style="text-align: center; color: var(--theme-text-muted); padding: var(--space-md);">
                        <div>üìä Aucun score disponible</div>
                        <div style="font-size: 0.9em; margin-top: var(--space-xs);">
                            Visitez le risk dashboard pour g√©n√©rer des scores
                        </div>
                    </div>
                `;
            }

            container.innerHTML = `
                <div style="display: grid; gap: 2px;">
                    ${scoresHTML}
                    
                    <!-- Timestamp -->
                    ${timestamp ? `
                    <div style="text-align: center; font-size: 0.8em; color: var(--theme-text-muted); margin-top: 6px;">
                        Mis √† jour: ${new Date(timestamp).toLocaleTimeString()}${isStale ? ` ¬∑ <span class=\"status-badge status-warning\">Cache</span>` : ''}
                    </div>
                    ` : ''}
                </div>
            `;

            if (statusEl) {
                if (isStale) {
                    statusEl.className = 'status-badge status-warning';
                    statusEl.textContent = 'Cache';
                } else {
                    statusEl.className = 'status-badge status-active';
                    statusEl.textContent = '√Ä jour';
                }
            }
        }

        function formatUSD(v) {
            const cur = (window.globalConfig && window.globalConfig.get('display_currency')) || 'USD';
            const rate = (window.currencyManager && window.currencyManager.getRateSync(cur)) || 1;
            if (cur !== 'USD' && (!rate || rate <= 0)) return '‚Äî';
            const val = (v == null || isNaN(v)) ? 0 : (v * rate);
            try {
                // BTC is not a standard ISO code; Intl may throw
                const decimals = (cur === 'BTC') ? 8 : 2;
                const out = new Intl.NumberFormat('fr-FR', { style: 'currency', currency: cur, minimumFractionDigits: decimals, maximumFractionDigits: decimals }).format(val);
                return (cur === 'USD') ? out.replace(/\s?US$/, '') : out;
            } catch (_) {
                const decimals = (cur === 'BTC') ? 8 : 2;
                return `${val.toFixed(decimals)} ${cur}`;
            }
        }
        function formatTimeAgo(ts) {
            if (!ts) return 'N/A';
            const d = new Date(ts), now = new Date(), dm = Math.floor((now - d) / (1000 * 60));
            if (dm < 60) return `${dm}min`;
            if (dm < 1440) return `${Math.floor(dm / 60)}h`;
            return `${Math.floor(dm / 1440)}j`;
        }
        function showError(m) {
            log.error(m);
            // Afficher l'erreur √† l'utilisateur via UI
            const errorDiv = document.getElementById('error-display') || createErrorDisplay();
            errorDiv.textContent = m;
            errorDiv.style.display = 'block';
            setTimeout(() => errorDiv.style.display = 'none', 5000);
        }

        function createErrorDisplay() {
            const div = document.createElement('div');
            div.id = 'error-display';
            div.style.cssText = `
                position: fixed; top: 20px; right: 20px; z-index: 9999;
                background: var(--theme-error, #ff4444); color: white;
                padding: 12px 16px; border-radius: 8px; max-width: 400px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.2); display: none;
            `;
            document.body.appendChild(div);
            return div;
        }

        // Configuration Chart.js avec th√®me adaptatif
        function initChartTheme() {
            if (typeof Chart !== 'undefined') {
                Chart.defaults.color = 'var(--theme-text)';
                Chart.defaults.borderColor = 'var(--theme-border)';
                Chart.defaults.backgroundColor = 'var(--theme-surface)';
                Chart.defaults.plugins.tooltip.backgroundColor = 'var(--theme-surface-elevated)';
                Chart.defaults.plugins.tooltip.titleColor = 'var(--theme-text)';
                Chart.defaults.plugins.tooltip.bodyColor = 'var(--theme-text)';
                Chart.defaults.plugins.tooltip.borderColor = 'var(--theme-border)';
                Chart.defaults.plugins.tooltip.borderWidth = 1;
            }
        }

        // Couleurs pour le graphique portfolio (11 couleurs pour les 11 groupes canoniques)
        const PORTFOLIO_COLORS = [
            '#3b82f6', '#ef4444', '#10b981', '#f59e0b', '#8b5cf6',
            '#06b6d4', '#84cc16', '#f97316', '#ec4899', '#6366f1',
            '#14b8a6'  // Ajout 11√®me couleur (teal)
        ];

        // Classification dynamique - sera charg√©e depuis alias-manager
        let ASSET_GROUPS = null;

        // Force reload taxonomy pour classification correcte des 11 groupes
        async function loadAssetGroups() {
            try {
                console.debug('üîÑ [Dashboard] Force reloading taxonomy for proper asset classification...');
                const { forceReloadTaxonomy, UNIFIED_ASSET_GROUPS } = await import('./shared-asset-groups.js');
                await forceReloadTaxonomy();

                if (!Object.keys(UNIFIED_ASSET_GROUPS || {}).length) {
                    debugLogger.warn('‚ö†Ô∏è [Dashboard] Taxonomy non charg√©e ‚Äì risque de "Others" gonfl√©');
                } else {
                    debugLogger.debug('‚úÖ [Dashboard] Taxonomy loaded:', Object.keys(UNIFIED_ASSET_GROUPS).length, 'groupes');
                }
            } catch (error) {
                debugLogger.error('‚ùå [Dashboard] Failed to load taxonomy:', error);
            }
        }

        // Parser CSV : wrapper auto qui utilise window.parseCSVBalances si dispo, sinon notre local
        function parseCSVBalancesAuto(csvText, { thresholdUSD = 1.0 } = {}) {
            if (typeof window.parseCSVBalances === 'function') {
                return window.parseCSVBalances(csvText);
            }
            return parseCSVBalancesLocal(csvText, { thresholdUSD });
        }

        // Impl√©mentation locale robuste
        function parseCSVBalancesLocal(csvText, { thresholdUSD = 1.0 } = {}) {
            const cleanedText = csvText.replace(/^\ufeff/, '');
            const lines = cleanedText.split(/\r?\n/);
            const balances = [];
            const minThreshold = (window.globalConfig && window.globalConfig.get('min_usd_threshold')) || thresholdUSD || 1.0;

            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;

                try {
                    const columns = parseCSVLineLocal(line);
                    if (columns.length >= 5) {
                        const ticker = columns[0];
                        const norm = s => parseFloat(String(s).replace(/[,\u00A0]/g, ''));
                        const amount = norm(columns[3]);
                        const valueUSD = norm(columns[4]);

                        if (ticker && !isNaN(amount) && !isNaN(valueUSD) && valueUSD >= minThreshold) {
                            balances.push({
                                symbol: ticker.toUpperCase(),
                                balance: amount,
                                value_usd: valueUSD
                            });
                        }
                    }
                } catch (error) {
                    debugLogger.warn('Erreur parsing ligne CSV:', error.message);
                }
            }

            return balances;
        }

        function parseCSVLineLocal(line) {
            const result = [];
            let current = '';
            let inQuotes = false;

            for (let i = 0; i < line.length; i++) {
                const char = line[i];

                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === ';' && !inQuotes) {
                    result.push(current.trim().replace(/^"|"$/g, ''));
                    current = '';
                } else {
                    current += char;
                }
            }

            if (current) {
                result.push(current.trim().replace(/^"|"$/g, ''));
            }

            return result;
        }

        async function groupAssetsByAliases(items) {
            // Utiliser la fonction unifi√©e de groupement directement depuis le module
            try {
                debugLogger.debug('üîÑ [Dashboard] Classifying', items.length, 'assets with unified taxonomy');
                const { groupAssetsByClassification } = await import('./shared-asset-groups.js');

                if (!groupAssetsByClassification) {
                    throw new ReferenceError('groupAssetsByClassification not available');
                }

                const result = groupAssetsByClassification(items);
                debugLogger.debug('‚úÖ [Dashboard] Unified grouping succeeded, found', result.length, 'groups');
                return result;
            } catch (error) {
                debugLogger.warn('‚ö†Ô∏è [Dashboard] Unified grouping failed, using fallback:', error);
                // Fallback qui utilise aussi le groupement par classification
                const groups = new Map();
                const resolveGroup = (typeof window !== 'undefined' && typeof window.getAssetGroup === 'function')
                    ? window.getAssetGroup
                    : null;

                items.forEach(item => {
                    const symbol = (item.symbol || '').toUpperCase();
                    let group;

                    // Essayer d'abord l'API taxonomy directement
                    group = getGroupFromTaxonomyAPI(symbol);

                    if (!group && resolveGroup) {
                        try {
                            group = resolveGroup(symbol);
                        } catch (e) {
                            group = autoClassifySymbol(symbol);
                        }
                    }

                    if (!group) {
                        group = autoClassifySymbol(symbol);
                    }

                    // Debug temporaire pour voir les classifications
                    if (parseFloat(item.value_usd || 0) > 100) { // Seulement pour les assets significatifs
                        debugLogger.debug(`üîç ${symbol} ‚Üí ${group} ($${parseFloat(item.value_usd || 0).toFixed(2)})`);
                    }

                    if (!groups.has(group)) {
                        groups.set(group, {
                            label: group,
                            value: 0,
                            assets: []
                        });
                    }
                    const groupObj = groups.get(group);
                    groupObj.value += parseFloat(item.value_usd || 0);
                    groupObj.assets.push(symbol);
                });

                return Array.from(groups.values());
            }
        }

        // Cache local pour l'API taxonomy
        let taxonomyAPICache = null;

        // Fonction pour r√©cup√©rer directement depuis l'API taxonomy (synchrone)
        function getGroupFromTaxonomyAPI(symbol) {
            if (!taxonomyAPICache) {
                try {
                    // Chargement synchrone de la taxonomy
                    const xhr = new XMLHttpRequest();
                    xhr.open('GET', '/taxonomy', false); // false = synchrone
                    xhr.send();

                    if (xhr.status === 200) {
                        const data = JSON.parse(xhr.responseText);
                        taxonomyAPICache = data.aliases || {};
                        debugLogger.debug('‚úÖ Taxonomy API loaded synchronously for dashboard fallback');
                    }
                } catch (e) {
                    debugLogger.warn('Failed to load taxonomy API for fallback:', e);
                    taxonomyAPICache = {};
                }
            }

            return taxonomyAPICache[symbol] || null;
        }

        // Fonction de classification basique en cas d'urgence
        function autoClassifySymbol(symbol) {
            const upperSymbol = symbol.toUpperCase();

            if (upperSymbol.includes('BTC') || upperSymbol.includes('WBTC')) {
                return 'BTC';
            } else if (upperSymbol.includes('ETH') || upperSymbol.includes('STETH') || upperSymbol.includes('RETH')) {
                return 'ETH';
            } else if (['USDT', 'USDC', 'DAI', 'USD', 'BUSD', 'TUSD', 'EUR'].includes(upperSymbol)) {
                return 'Stablecoins';
            } else if (upperSymbol.includes('SOL')) {
                return 'SOL';
            } else {
                return 'Others';
            }
        }

        // Cr√©er ou mettre √† jour le graphique portfolio
        async function updatePortfolioChart(balancesData) {
            log.debug('updatePortfolioChart - balancesData:', balancesData);

            if (!balancesData || !balancesData.items) {
                console.debug('‚ùå No balances data or items');
                document.getElementById('portfolio-chart').innerHTML = '<div style="text-align: center; padding: 20px; color: var(--warning);">‚è≥ Chargement des donn√©es...</div>';
                return;
            }

            // Plus besoin de v√©rifier ASSET_GROUPS, utilise directement les fonctions

            let canvas = document.getElementById('portfolioChartCanvas');
            if (!canvas) {
                console.debug('‚ùå Canvas element not found, creating it...');
                // Cr√©er le canvas manquant
                const chartContainer = document.getElementById('portfolio-chart');
                if (chartContainer) {
                    chartContainer.innerHTML = '<canvas id="portfolioChartCanvas"></canvas>';
                    canvas = document.getElementById('portfolioChartCanvas');
                    console.debug('‚úÖ Canvas element created successfully');
                } else {
                    console.debug('‚ùå Portfolio chart container not found');
                    return;
                }
            }

            // V√©rifier que Chart.js est charg√©
            if (typeof Chart === 'undefined') {
                console.debug('‚ùå Chart.js not loaded, trying to reload...');
                document.getElementById('portfolio-chart').innerHTML = '<div style="text-align: center; padding: 20px; color: var(--danger);">‚ùå Chart.js non charg√© - rechargez la page</div>';
                return;
            }

            const ctx = canvas.getContext('2d');
            log.debug('Number of items:', balancesData.items.length);

            // Traiter les donn√©es pour le graphique avec regroupement par aliases
            const items = balancesData.items || [];
            const filteredItems = items.filter(item => parseFloat(item.value_usd || 0) > 0);

            // Regrouper par aliases
            log.debug('Filtered items for chart:', filteredItems.length);
            const groupedData = await groupAssetsByAliases(filteredItems);
            log.debug('Grouped data:', groupedData.length, 'groups');

            // Trier par valeur et afficher TOUS les groupes (11 groupes canoniques)
            const sortedData = groupedData
                .sort((a, b) => b.value - a.value);

            const labels = sortedData.map(item => item.label);
            const values = sortedData.map(item => item.value);

            // Use real total from ALL assets, not just top 8 groups shown
            const realTotal = groupedData.reduce((sum, item) => sum + item.value, 0);
            const total = realTotal;

            log.debug('Chart data:', { labels, values, total: total.toFixed(2) });

            // Si aucune donn√©e, afficher un message explicatif
            if (labels.length === 0 || total === 0) {
                console.debug('‚ùå No chart data available, showing placeholder');
                document.getElementById('portfolio-chart').innerHTML = `
                    <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 200px; color: var(--theme-text-muted);">
                        <div style="font-size: 2rem; margin-bottom: 12px;">üìä</div>
                        <div style="font-weight: 600; margin-bottom: 4px;">Donn√©es en cours de chargement</div>
                        <div style="font-size: 0.875rem;">Le graphique s'affichera quand les donn√©es seront disponibles</div>
                    </div>
                `;
                return;
            }

            // D√©truire l'ancien graphique s'il existe
            if (portfolioChart) {
                portfolioChart.destroy();
            }

            // Obtenir les couleurs du th√®me actuel
            const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
            const tooltipBg = isDark ? '#374151' : '#f9fafb';
            const tooltipText = isDark ? '#f9fafb' : '#1f2937';
            const tooltipBorder = isDark ? '#6b7280' : '#d1d5db';

            // Cr√©er le nouveau graphique
            portfolioChart = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: labels,
                    datasets: [{
                        data: values,
                        backgroundColor: values.map((_, i) => PORTFOLIO_COLORS[i % PORTFOLIO_COLORS.length]),
                        borderColor: isDark ? '#374151' : '#ffffff',
                        borderWidth: 2,
                        hoverBorderWidth: 3
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            backgroundColor: tooltipBg,
                            titleColor: tooltipText,
                            bodyColor: tooltipText,
                            borderColor: tooltipBorder,
                            borderWidth: 1,
                            cornerRadius: 8,
                            padding: 12,
                            callbacks: {
                                label: function (context) {
                                    const value = context.parsed;
                                    const percentage = ((value / total) * 100).toFixed(1);
                                    const groupData = sortedData[context.dataIndex];
                                    let label = `${context.label}: ${formatUSD(value)} (${percentage}%)`;

                                    // Ajouter les assets du groupe si c'est un groupe
                                    if (groupData.assets && groupData.assets.length > 1) {
                                        label += `\nAssets: ${groupData.assets.join(', ')}`;
                                    }

                                    return label;
                                }
                            }
                        }
                    },
                    cutout: '60%',
                    animation: {
                        animateRotate: true,
                        duration: 1000
                    },
                    interaction: {
                        intersect: false,
                        mode: 'point'
                    }
                }
            });
        }

        // Afficher la liste d√©taill√©e des allocations
        async function updatePortfolioBreakdown(balancesData) {
            const container = document.getElementById('breakdown-list');
            // Si le conteneur n'existe pas sur cette page, on sort proprement
            if (!container) {
                return;
            }
            if (!balancesData || !balancesData.items) {
                container.innerHTML = '<div style="color: var(--danger);">‚ùå Pas de donn√©es</div>';
                return;
            }

            const items = balancesData.items || [];
            const filteredItems = items.filter(item => parseFloat(item.value_usd || 0) > 0);

            // Regrouper par aliases comme le graphique
            const groupedData = await groupAssetsByAliases(filteredItems);
            const sortedData = groupedData.sort((a, b) => b.value - a.value);
            const total = sortedData.reduce((sum, item) => sum + item.value, 0);

            log.debug('updatePortfolioBreakdown - total:', total, 'groups:', sortedData.length);

            const html = sortedData.map((group, index) => {
                const percentage = ((group.value / total) * 100).toFixed(1);
                const assets = group.assets ? ` (${group.assets.join(', ')})` : '';
                return `
                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 4px 0; border-bottom: 1px solid var(--theme-border);">
                        <span style="color: var(--theme-text);">${group.label}${assets}</span>
                        <span style="font-weight: 600; color: var(--theme-text);">${formatUSD(group.value)} (${percentage}%)</span>
                    </div>
                `;
            }).join('');

            container.innerHTML = html + `
                <div style="display: flex; justify-content: space-between; align-items: center; padding: 8px 0; margin-top: 8px; font-weight: 700; border-top: 2px solid var(--theme-border);">
                    <span>TOTAL</span>
                    <span>${formatUSD(total)} (100%)</span>
                </div>
            `;
        }

        // Forcer un refresh des donn√©es avec la source actuelle
        async function forceRefreshData() {
            console.debug('üîÑ Force refresh demand√© par utilisateur');
            console.debug('üìä Current source before refresh:', globalConfig.get('data_source'));
            console.debug('üìä Known source before refresh:', window.lastKnownDataSource);

            // Clear any potential caches
            if (window.portfolioChart) {
                window.portfolioChart.destroy();
                window.portfolioChart = null;
            }

            // Force reload taxonomy
            if (window.forceReloadTaxonomy) {
                window.forceReloadTaxonomy();
            }

            // Force reload
            await loadDashboardData();
        }

        // Function for debugging - call from browser console
        window.debugPortfolioData = async function () {
            console.group('üîç Portfolio Data Debug');

            const currentSource = globalConfig.get('data_source');
            debugLogger.debug('Current configured source:', currentSource);

            debugLogger.debug('Testing direct API calls...');

            // Test stub source
            try {
                const stubResponse = await fetch(`${globalConfig.get('api_base_url')}/balances/current?source=stub&_t=${Date.now()}`);
                const stubData = await stubResponse.json();
                const stubTotal = stubData.items?.reduce((sum, item) => sum + (item.value_usd || 0), 0) || 0;
                debugLogger.debug('‚úÖ Stub source API response:', {
                    success: stubResponse.ok,
                    itemCount: stubData.items?.length,
                    totalValue: stubTotal
                });
            } catch (e) {
                debugLogger.error('‚ùå Stub source failed:', e);
            }

            // Test cointracking source
            try {
                const csvResponse = await fetch(`${globalConfig.get('api_base_url')}/balances/current?source=cointracking&_t=${Date.now()}`);
                const csvData = await csvResponse.json();
                const csvTotal = csvData.items?.reduce((sum, item) => sum + (item.value_usd || 0), 0) || 0;
                debugLogger.debug('‚úÖ CoinTracking source API response:', {
                    success: csvResponse.ok,
                    itemCount: csvData.items?.length,
                    totalValue: csvTotal
                });
            } catch (e) {
                debugLogger.error('‚ùå CoinTracking source failed:', e);
            }

            // Test current configured source
            debugLogger.debug(`Testing current configured source: ${currentSource}`);
            try {
                const currentResponse = await window.loadBalanceData();
                debugLogger.debug('‚úÖ Current source via loadBalanceData():', {
                    success: currentResponse?.success,
                    source: currentResponse?.source,
                    hasData: !!currentResponse?.data,
                    hasCsvText: !!currentResponse?.csvText,
                    dataItemsCount: currentResponse?.data?.items?.length || 0
                });

                if (currentResponse?.data?.items) {
                    const total = currentResponse.data.items.reduce((sum, item) => sum + (item.value_usd || 0), 0);
                    debugLogger.debug('Calculated total from current source:', total);
                }
            } catch (e) {
                debugLogger.error('‚ùå Current source failed:', e);
            }

            console.groupEnd();
        };


        // ---- Drag & Drop des cartes du dashboard ----
        (function () {
            const GRID_SELECTOR = '.dashboard-grid';
            const STORAGE_KEY = 'dashboard_card_order_v1';

            let dragEl = null;
            let usingHandle = false;

            document.addEventListener('DOMContentLoaded', () => {
                initCardOrdering();
            });

            function initCardOrdering() {
                const grid = document.querySelector(GRID_SELECTOR);
                if (!grid) return;

                // 1) Restaurer l'ordre sauvegard√©
                restoreOrder(grid);

                // 2) Brancher les events
                grid.querySelectorAll('.card[draggable="true"]').forEach(card => {
                    // Si tu veux drag uniquement via l'ent√™te:
                    const handle = card.querySelector('.card-header');
                    if (handle) {
                        handle.setAttribute('data-drag-handle', 'true');
                        handle.style.cursor = 'move';
                        handle.addEventListener('mousedown', () => usingHandle = true);
                        handle.addEventListener('mouseup', () => usingHandle = false);
                        handle.addEventListener('mouseleave', () => usingHandle = false);
                    }

                    card.addEventListener('dragstart', onDragStart);
                    card.addEventListener('dragend', onDragEnd);
                    card.addEventListener('dragover', onDragOver);
                    card.addEventListener('dragleave', onDragLeave);
                    card.addEventListener('drop', onDrop);
                });

                // Permettre le drop partout dans la grille
                grid.addEventListener('dragover', e => e.preventDefault());
                grid.addEventListener('drop', e => {
                    e.preventDefault();
                    clearDropIndicators(grid);
                    saveOrder(grid);
                });
            }

            function onDragStart(e) {
                // Si handle requis : emp√™cher le drag initi√© ailleurs que sur le handle
                const wantsHandle = true; // passe √† false pour autoriser drag partout
                if (wantsHandle) {
                    const isOnHandle = e.target.closest('[data-drag-handle="true"]');
                    if (!isOnHandle && !usingHandle) {
                        e.preventDefault();
                        return;
                    }
                }
                dragEl = e.currentTarget;
                e.dataTransfer.effectAllowed = 'move';
                // Set data (certains navigateurs exigent une data)
                e.dataTransfer.setData('text/plain', dragEl.id || '');
                dragEl.classList.add('dragging');
            }

            function onDragEnd() {
                if (dragEl) dragEl.classList.remove('dragging');
                dragEl = null;
                usingHandle = false;
            }

            function onDragOver(e) {
                e.preventDefault();
                const card = e.currentTarget;
                if (!dragEl || card === dragEl) return;

                // Feedback visuel
                card.classList.add('drop-target');

                // Insertion live : on calcule si on met avant ou apr√®s la carte survol√©e
                const grid = card.parentElement;
                const above = shouldInsertBefore(e, card);
                if (above) grid.insertBefore(dragEl, card);
                else grid.insertBefore(dragEl, card.nextSibling);
            }

            function onDragLeave(e) {
                e.currentTarget.classList.remove('drop-target');
            }

            function onDrop(e) {
                e.preventDefault();
                e.currentTarget.classList.remove('drop-target');
                const grid = e.currentTarget.parentElement;
                saveOrder(grid);
            }

            function shouldInsertBefore(e, targetCard) {
                const rect = targetCard.getBoundingClientRect();
                // Heuristique : si on est sur la moiti√© sup√©rieure, on ins√®re avant
                return (e.clientY - rect.top) < (rect.height / 2);
            }

            function saveOrder(grid) {
                const order = Array.from(grid.querySelectorAll('.card[draggable="true"]')).map(c => c.id);
                try {
                    localStorage.setItem(STORAGE_KEY, JSON.stringify(order));
                } catch { }
            }

            function restoreOrder(grid) {
                let raw = null;
                try { raw = localStorage.getItem(STORAGE_KEY); } catch { }
                if (!raw) return;

                try {
                    const order = JSON.parse(raw);
                    const map = new Map(Array.from(grid.children).map(el => [el.id, el]));
                    order.forEach(id => {
                        const el = map.get(id);
                        if (el) grid.appendChild(el);
                    });
                } catch { }
            }

            function clearDropIndicators(root) {
                root.querySelectorAll('.drop-target').forEach(el => el.classList.remove('drop-target'));
            }
        })();

        // === SAXO TILE FUNCTIONS ===
        async function refreshSaxoTile() {
            debugLogger.debug('üè¶ Refreshing Saxo tile...');

            const statusEl = document.getElementById('saxo-status');
            const totalValueEl = document.getElementById('saxo-total-value');
            const positionsCountEl = document.getElementById('saxo-positions-count');
            const lastImportEl = document.getElementById('saxo-last-import');
            const emptyStateEl = document.getElementById('saxo-empty-state');

            // Set loading state
            if (statusEl) statusEl.textContent = 'Loading';
            if (statusEl) statusEl.className = 'status-badge status-loading';

            try {
                // Dynamic import to access module functions
                const { fetchSaxoSummary, formatCurrency, getMetricColor } = await import('./modules/wealth-saxo-summary.js');
                const summary = await fetchSaxoSummary();

                if (summary.isEmpty || summary.error) {
                    // Empty state or error
                    if (totalValueEl) totalValueEl.textContent = formatCurrency(0);
                    if (positionsCountEl) positionsCountEl.textContent = '0';
                    if (lastImportEl) lastImportEl.textContent = summary.asof || 'Aucune donn√©e';

                    if (emptyStateEl) emptyStateEl.style.display = 'block';
                    if (statusEl) {
                        statusEl.textContent = summary.error ? 'Erreur' : 'Vide';
                        statusEl.className = 'status-badge status-warning';
                    }

                    debugLogger.warn('[Saxo Tile] Empty state or error:', summary.error || 'No positions');
                } else {
                    // Success with data
                    if (totalValueEl) {
                        totalValueEl.textContent = formatCurrency(summary.total_value);
                        totalValueEl.style.color = getMetricColor(summary.total_value);
                    }
                    if (positionsCountEl) positionsCountEl.textContent = summary.positions_count.toString();
                    if (lastImportEl) lastImportEl.textContent = summary.asof;

                    if (emptyStateEl) emptyStateEl.style.display = 'none';
                    if (statusEl) {
                        statusEl.textContent = 'OK';
                        statusEl.className = 'status-badge status-active';
                    }

                    debugLogger.debug('‚úÖ Saxo tile updated:', {
                        total_value: summary.total_value,
                        positions_count: summary.positions_count,
                        asof: summary.asof
                    });
                }

                // Console assertion for sanity check
                console.assert(
                    summary.positions_count >= 0,
                    '[Saxo Tile] Positions count should be >= 0, got:', summary.positions_count
                );

            } catch (error) {
                debugLogger.error('[Saxo Tile] Error refreshing:', error);

                if (totalValueEl) totalValueEl.textContent = '--';
                if (positionsCountEl) positionsCountEl.textContent = '--';
                if (lastImportEl) lastImportEl.textContent = 'Erreur';

                if (emptyStateEl) emptyStateEl.style.display = 'block';
                if (statusEl) {
                    statusEl.textContent = 'Erreur';
                    statusEl.className = 'status-badge status-error';
                }
            }
        }

        // Make function globally available for onclick
        window.refreshSaxoTile = refreshSaxoTile;

    </script>

    <script>
        // Keep the Scores tile in sync when risk-dashboard updates localStorage from another tab
        window.addEventListener('storage', function (e) {
            try {
                if (e.key && e.key.startsWith('risk_score_')) {
                    if (typeof loadScoresData === 'function' && typeof updateScoresDisplay === 'function') {
                        loadScoresData()
                            .then(data => updateScoresDisplay(data))
                            .catch(err => debugLogger.warn('Failed to refresh scores from storage event:', err));
                    }
                }
            } catch (_) { /* ignore */ }
        });
    </script>

    <script>
        // Also refresh the Scores tile when returning to this tab
        function refreshScoresFromLocalStorage() {
            try {
                if (typeof loadScoresData === 'function' && typeof updateScoresDisplay === 'function') {
                    loadScoresData()
                        .then(data => updateScoresDisplay(data))
                        .catch(err => debugLogger.warn('Failed to refresh scores on focus:', err));
                }
            } catch (_) { /* ignore */ }
        }
        window.addEventListener('focus', refreshScoresFromLocalStorage);
        document.addEventListener('visibilitychange', function () {
            if (!document.hidden) refreshScoresFromLocalStorage();
        });
    </script>

</body>

</html>