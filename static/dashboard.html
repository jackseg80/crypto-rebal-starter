<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>üìä Dashboard - Crypto Rebalancer</title>
    <link rel="stylesheet" href="shared-theme.css">
    <link rel="stylesheet" href="theme-compat.css">

    <script src="global-config.js"></script>
    <script src="shared-header.js"></script>
    <script src="appearance.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            background: var(--theme-background);
            color: var(--theme-text);
            font-family: system-ui, -apple-system, 'Segoe UI', Roboto, Arial, sans-serif;
            line-height: 1.6;
            min-height: 100vh;
        }

        .wrap {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .dashboard-grid {
            display: grid;
            gap: 20px;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            margin-top: 20px;
        }

        .card {
            background: var(--theme-surface);
            border: 1px solid var(--theme-border);
            border-radius: var(--radius-lg);
            padding: var(--space-xl);
            transition: all var(--transition-normal);
            box-shadow: var(--shadow-sm);
        }

        .card:hover {
            border-color: var(--brand-primary);
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--space-lg);
            padding-bottom: var(--space-md);
            border-bottom: 1px solid var(--theme-border);
        }

        .card-title {
            font-size: 18px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .card-icon {
            font-size: 24px;
        }

        .metric {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 12px 0;
            padding: 8px 0;
        }

        .metric-label {
            color: var(--theme-text-muted);
            font-size: 14px;
        }

        .metric-value {
            font-weight: 600;
            font-size: 16px;
            color: var(--theme-text);
        }

        .status-badge {
            padding: 4px 8px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .status-active {
            background: var(--success-bg);
            color: var(--success);
            border: 1px solid var(--success);
        }

        .status-warning {
            background: var(--warning-bg);
            color: var(--warning);
            border: 1px solid var(--warning);
        }

        .status-error {
            background: var(--danger-bg);
            color: var(--danger);
            border: 1px solid var(--danger);
        }

        .quick-actions {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 12px;
            margin-top: 16px;
        }

        .action-btn {
            background: var(--brand-primary);
            color: white;
            text-decoration: none;
            padding: var(--space-md) var(--space-lg);
            border-radius: var(--radius-md);
            font-weight: 600;
            text-align: center;
            transition: all var(--transition-normal);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: var(--space-sm);
        }

        .action-btn:hover {
            transform: translateY(-1px);
            box-shadow: var(--shadow-lg);
            background: var(--brand-primary-hover);
        }

        .action-btn.secondary {
            background: var(--theme-surface-elevated);
            color: var(--theme-text);
            border: 1px solid var(--theme-border);
        }

        .action-btn.secondary:hover {
            border-color: var(--brand-primary);
            color: var(--brand-primary);
            background: var(--theme-surface-hover);
        }

        /* Container pour graphique Chart.js */
        .portfolio-chart {
            height: 250px;
            position: relative;
            margin: var(--space-lg) 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .portfolio-chart canvas {
            max-height: 100%;
            max-width: 100%;
        }

        .recent-activity {
            max-height: 300px;
            overflow-y: auto;
        }

        .activity-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: var(--space-sm) 0;
            border-bottom: 1px solid var(--theme-border);
        }

        .activity-item:last-child {
            border-bottom: none;
        }

        .activity-desc {
            color: var(--theme-text-muted);
            font-size: 13px;
        }

        .activity-time {
            color: var(--theme-text-muted);
            font-size: 12px;
        }

        .connections-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 12px;
            margin-top: 12px;
        }

        .connection-item {
            text-align: center;
            padding: var(--space-md);
            border-radius: var(--radius-md);
            border: 1px solid var(--theme-border);
            background: var(--theme-surface-elevated);
        }

        .connection-name {
            font-size: 12px;
            margin-bottom: 4px;
            color: var(--theme-text-muted);
        }

        .loading {
            color: var(--theme-text-muted);
            text-align: center;
            padding: var(--space-xl);
        }

        .error {
            color: var(--danger);
            text-align: center;
            padding: var(--space-xl);
            background: var(--danger-bg);
            border: 1px solid var(--danger);
            border-radius: var(--radius-md);
            margin: var(--space-md) 0;
        }

        @media (max-width: 768px) {
            .dashboard-grid {
                grid-template-columns: 1fr;
            }

            .quick-actions {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>

<body>
    <!-- Header inject√© par shared-header.js -->
    <div class="wrap">
        <div class="dashboard-grid">

            <!-- Portfolio Overview -->
            <div class="card">
                <div class="card-header">
                    <div class="card-title"><span class="card-icon">üí∞</span>Portfolio Overview</div>
                    <div style="display:flex;gap:8px;align-items:center;">
                        <button class="action-btn secondary" style="padding:4px 8px;font-size:12px;"
                            onclick="forceRefreshData()">üîÑ</button>
                        <span class="status-badge status-active" id="portfolio-status">Loading</span>
                    </div>
                </div>

                <div class="metric">
                    <span class="metric-label">Total Value</span>
                    <span class="metric-value" id="total-value">--</span>
                </div>

                <div class="metric">
                    <span class="metric-label">P&L Today</span>
                    <span class="metric-value" id="daily-pnl">--</span>
                </div>

                <div class="metric">
                    <span class="metric-label">Assets Count</span>
                    <span class="metric-value" id="assets-count">--</span>
                </div>

                <div class="portfolio-chart" id="portfolio-chart">
                    <canvas id="portfolioChartCanvas"></canvas>
                </div>
                
                <!-- Liste d√©taill√©e des allocations (collapsible) -->
                <div id="portfolio-breakdown" style="margin-top: var(--space-lg); font-size: 0.875rem;">
                    <div onclick="toggleBreakdown()" style="font-weight: 600; margin-bottom: var(--space-sm); color: var(--theme-text-muted); cursor: pointer; display: flex; align-items: center; gap: var(--space-xs);">
                        <span id="breakdown-arrow">‚ñ∂Ô∏è</span>
                        <span>üìä Breakdown d√©taill√©</span>
                    </div>
                    <div id="breakdown-list" style="display: none;">Loading...</div>
                </div>
            </div>


            <!-- Execution Status -->
            <div class="card">
                <div class="card-header">
                    <div class="card-title"><span class="card-icon">üéØ</span>Execution Status</div>
                    <span class="status-badge" id="execution-status">Loading</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Last Execution</span>
                    <span class="metric-value" id="last-execution">--</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Success Rate (24h)</span>
                    <span class="metric-value" id="success-rate">--</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Total Volume (24h)</span>
                    <span class="metric-value" id="volume-24h">--</span>
                </div>
            </div>

            <!-- Exchange Connections -->
            <div class="card">
                <div class="card-header">
                    <div class="card-title"><span class="card-icon">üîó</span>Exchange Status</div>
                    <a href="monitoring_advanced.html" class="status-badge status-active"
                        style="text-decoration:none;">View Details</a>
                </div>
                <div class="connections-grid" id="connections-grid">
                    <div class="loading">Loading connections...</div>
                </div>
            </div>

            <!-- Recent Activity -->
            <div class="card">
                <div class="card-header">
                    <div class="card-title"><span class="card-icon">üìã</span>Recent Activity</div>
                    <a href="execution_history.html" class="status-badge status-active"
                        style="text-decoration:none;">View All</a>
                </div>
                <div class="recent-activity" id="recent-activity">
                    <div class="loading">Loading recent activity...</div>
                </div>
            </div>

            <!-- System Health -->
            <div class="card">
                <div class="card-header">
                    <div class="card-title"><span class="card-icon">‚ù§Ô∏è</span>System Health</div>
                    <span class="status-badge" id="system-health">Loading</span>
                </div>
                <div class="metric">
                    <span class="metric-label">API Status</span>
                    <span class="metric-value" id="api-status">--</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Data Freshness</span>
                    <span class="metric-value" id="data-freshness">--</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Safety Validator</span>
                    <span class="metric-value" id="safety-status">--</span>
                </div>
            </div>

        </div>
    </div>

    <script>
        // √âtat global
        let dashboardData = { portfolio: null, connections: null, recentActivity: null, executionStats: null };
        let portfolioChart = null;

        document.addEventListener('DOMContentLoaded', async () => {
            console.log('üìä Dashboard unifi√© initialis√©');
            initSharedHeader('dashboard', { showConfigIndicators: true });

            // Appliquer le th√®me imm√©diatement
            console.log('Initializing theme for dashboard page...');
            if (window.globalConfig && window.globalConfig.applyTheme) {
                window.globalConfig.applyTheme();
            }
            if (window.applyAppearance) {
                window.applyAppearance();
            }
            console.log('Current theme after dashboard init:', document.documentElement.getAttribute('data-theme'));

            // Configuration Chart.js avec th√®me
            initChartTheme();

            await loadDashboardData();
            setInterval(loadDashboardData, 30000);

            // √âcouter les changements de th√®me pour synchronisation cross-tab
            window.addEventListener('storage', function (e) {
                if (e.key === 'crypto_rebalancer_settings') {
                    console.log('Settings changed in another tab, reapplying theme...');
                    setTimeout(() => {
                        if (window.globalConfig && window.globalConfig.applyTheme) {
                            window.globalConfig.applyTheme();
                        }
                        if (window.applyAppearance) {
                            window.applyAppearance();
                        }
                        // Refaire le th√®me des graphiques aussi
                        initChartTheme();
                    }, 100);
                }
            });

            window.addEventListener('dataSourceChanged', (event) => {
                console.log(`üîÑ Source chang√©e: ${event.detail.oldSource} ‚Üí ${event.detail.newSource}`);
                loadDashboardData();
            });
        });

        async function loadDashboardData() {
            try {
                // Charger d'abord les groupes depuis alias-manager
                await loadAssetGroups();
                
                const [portfolioData, connectionsData, historyData, executionStatus] = await Promise.allSettled([
                    loadPortfolioData(), loadConnectionsStatus(), loadRecentHistory(), loadExecutionStatus()
                ]);
                updatePortfolioDisplay(portfolioData.status === 'fulfilled' ? portfolioData.value : null);
                updateConnectionsDisplay(connectionsData.status === 'fulfilled' ? connectionsData.value : null);
                updateRecentActivity(historyData.status === 'fulfilled' ? historyData.value : null);
                updateExecutionStatus(executionStatus.status === 'fulfilled' ? executionStatus.value : null);
                updateSystemHealth();

                console.log('‚úÖ Dashboard data loaded successfully');
            } catch (e) {
                console.error('Erreur chargement dashboard:', e);
                showError('Erreur lors du chargement des donn√©es');
            }
        }

        async function loadPortfolioData() {
            try {
                const source = (typeof globalConfig !== 'undefined' ? (globalConfig.get('data_source') || 'cointracking') : 'cointracking');
                console.log(`üìä Chargement portfolio avec source: ${source}`);

                // Essayer d'abord l'API, puis fallback vers CSV
                try {
                    // Utiliser l'API r√©elle pour obtenir les donn√©es du portefeuille
                    const response = await fetch(`http://localhost:8000/api/risk/dashboard?source=${source}&pricing=local&min_usd=1.00`);
                    if (response.ok) {
                        const data = await response.json();
                        if (data.success) {
                            const portfolioSummary = data.portfolio_summary;
                            
                            // L'API ne retourne pas les balances d√©taill√©es, mais on a le total correct
                            // On va utiliser les vraies valeurs de l'API + lire CSV pour le graphique
                            let csvBalances = [];
                            try {
                                let csvResponse;
                                try {
                                    csvResponse = await fetch('/data/raw/CoinTracking - Current Balance.csv');
                                    if (!csvResponse.ok) throw new Error('Uvicorn path failed');
                                } catch {
                                    csvResponse = await fetch('./data/raw/CoinTracking - Current Balance.csv');
                                }
                                if (csvResponse.ok) {
                                    const csvText = await csvResponse.text();
                                    csvBalances = parseCSVBalances(csvText);
                                }
                            } catch (csvError) {
                                console.warn('CSV read failed, using API data only:', csvError);
                            }

                            return {
                                ok: true,
                                metrics: {
                                    total_value_usd: portfolioSummary.total_value || 0,
                                    asset_count: portfolioSummary.num_assets || 0,
                                    last_updated: data.timestamp || new Date().toISOString()
                                },
                                performance: {
                                    performance_available: true,
                                    current_value_usd: portfolioSummary.total_value || 0,
                                    absolute_change_usd: 0
                                },
                                balances: {
                                    items: csvBalances, // CSV pour le graphique
                                    total_count: csvBalances.length,
                                    timestamp: data.timestamp || new Date().toISOString()
                                }
                            };
                        }
                    }
                } catch (apiError) {
                    console.warn('API indisponible, utilisation des donn√©es CSV:', apiError);
                }

                // Fallback : lire les donn√©es CSV locales depuis /data/raw/
                console.log('API indisponible, lecture des donn√©es CSV locales');
                
                let csvBalances = [];
                try {
                    // Lire le fichier CSV Current Balance
                    // Essayer d'abord le chemin uvicorn, puis le chemin local
                    let csvResponse;
                    try {
                        csvResponse = await fetch('/data/raw/CoinTracking - Current Balance.csv');
                        if (!csvResponse.ok) {
                            throw new Error('Uvicorn path failed');
                        }
                    } catch {
                        csvResponse = await fetch('./data/raw/CoinTracking - Current Balance.csv');
                    }
                    if (csvResponse.ok) {
                        const csvText = await csvResponse.text();
                        csvBalances = parseCSVBalances(csvText);
                        console.log('Donn√©es CSV charg√©es:', csvBalances.length, 'assets');
                    } else {
                        throw new Error('CSV file not accessible');
                    }
                } catch (csvError) {
                    console.warn('Impossible de lire le CSV, utilisation de donn√©es simul√©es:', csvError);
                    // Fallback avec les nouvelles donn√©es du CSV mis √† jour
                    csvBalances = [
                        { symbol: 'BTC', value_usd: 167140.44, balance: 1.52191480 },
                        { symbol: 'WSTETH', value_usd: 45849.45, balance: 8.53967597 },
                        { symbol: 'ETH', value_usd: 31142.35, balance: 7.04373146 },
                        { symbol: 'RETH', value_usd: 20683.69, balance: 4.10095164 },
                        { symbol: 'TBTC', value_usd: 14354.50, balance: 0.13008938 },
                        { symbol: 'USDT', value_usd: 14166.41, balance: 14166.40 },
                        { symbol: 'USD', value_usd: 11414.63, balance: 11414.63 },
                        { symbol: 'BNB', value_usd: 8013.54, balance: 9.52 },
                        { symbol: 'XRP', value_usd: 7807.37, balance: 2694.98 },
                        { symbol: 'LINK', value_usd: 7632.63, balance: 326.39 },
                        { symbol: 'XMR', value_usd: 5799.14, balance: 22.06 },
                        { symbol: 'AAVE', value_usd: 5555.24, balance: 16.81 },
                        { symbol: 'DOGE', value_usd: 5294.04, balance: 25215.73 },
                        { symbol: 'BGB', value_usd: 5189.49, balance: 1134.62 },
                        { symbol: 'STETH', value_usd: 3726.08, balance: 0.84 },
                        { symbol: 'SOL2', value_usd: 3621.38, balance: 19.34 }
                    ];
                    console.log('üîç DEBUG: Using fallback CSV data with', csvBalances.length, 'assets');
                }
                
                const mockBalances = csvBalances;

                const totalValue = mockBalances.reduce((sum, item) => sum + item.value_usd, 0);
                
                // Calculer le nombre de groupes d'assets (apr√®s regroupement)
                const groupedData = groupAssetsByAliases(mockBalances);
                const groupCount = groupedData.length; // C'est un array, pas une Map
                
                console.log('üîç DEBUG: Total value calculated:', totalValue.toFixed(2));
                console.log('üîç DEBUG: Group count calculated:', groupCount);

                return {
                    ok: true,
                    metrics: {
                        total_value_usd: totalValue,
                        asset_count: groupCount, // Nombre de groupes, pas d'assets individuels
                        last_updated: new Date().toISOString()
                    },
                    performance: {
                        performance_available: true,
                        current_value_usd: totalValue,
                        absolute_change_usd: 2547.33 // P&L positif simul√©
                    },
                    balances: {
                        items: mockBalances,
                        total_count: mockBalances.length,
                        timestamp: new Date().toISOString()
                    }
                };
                
            } catch (e) {
                console.error('Erreur portfolio:', e);
                return null;
            }
        }

        async function loadConnectionsStatus() {
            try {
                return { binance: { name: "Binance", connected: true }, kraken: { name: "Kraken", connected: true }, coinbase: { name: "Coinbase", connected: false } };
            } catch (e) { console.error('Erreur connexions:', e); return null; }
        }

        async function loadRecentHistory() {
            try {
                return {
                    sessions: [
                        { exchange: "Binance", total_orders: 3, successful_orders: 3, total_volume_usd: 1250.50, timestamp: new Date(Date.now() - 3600000).toISOString() },
                        { exchange: "Kraken", total_orders: 2, successful_orders: 2, total_volume_usd: 890.25, timestamp: new Date(Date.now() - 7200000).toISOString() }
                    ]
                };
            } catch (e) { console.error('Erreur historique:', e); return null; }
        }

        async function loadExecutionStatus() {
            try {
                return { recent_24h: { total_orders: 5, success_rate: 96.5, total_volume: 2140.75 } };
            } catch (e) { console.error('Erreur statut ex√©cution:', e); return null; }
        }

        function updatePortfolioDisplay(data) {
            if (!data || !data.ok) {
                document.getElementById('total-value').textContent = 'Erreur';
                document.getElementById('daily-pnl').textContent = 'Erreur';
                const st = document.getElementById('portfolio-status');
                st.className = 'status-badge status-error'; st.textContent = 'Erreur';
                return;
            }
            const { metrics, performance } = data;

            document.getElementById('total-value').textContent = formatUSD(metrics.total_value_usd || 0);

            const dailyPnl = performance?.absolute_change_usd || 0;
            const pnlEl = document.getElementById('daily-pnl');
            pnlEl.textContent = formatUSD(dailyPnl);
            pnlEl.style.color = dailyPnl >= 0 ? 'var(--success)' : 'var(--danger)';

            document.getElementById('assets-count').textContent = metrics.asset_count || 0;

            const statusEl = document.getElementById('portfolio-status');
            if ((metrics.total_value_usd || 0) > 0) { statusEl.className = 'status-badge status-active'; statusEl.textContent = 'Actif'; }
            else { statusEl.className = 'status-badge status-warning'; statusEl.textContent = 'Vide'; }

            console.log('üîç DEBUG: About to call updatePortfolioChart with:', data.balances);
            updatePortfolioChart(data.balances);
            updatePortfolioBreakdown(data.balances);
        }
        function updateConnectionsDisplay(data) {
            const container = document.getElementById('connections-grid');
            if (!data) { container.innerHTML = '<div class="error">Erreur de chargement</div>'; return; }

            const html = Object.values(data).map(conn => {
                const cls = conn.connected ? 'status-active' : 'status-error';
                const txt = conn.connected ? 'Online' : 'Offline';
                return `
          <div class="connection-item">
            <div class="connection-name">${conn.name}</div>
            <div class="status-badge ${cls}">${txt}</div>
          </div>`;
            }).join('');
            container.innerHTML = html;
        }

        function updateRecentActivity(data) {
            const container = document.getElementById('recent-activity');
            if (!data || !data.sessions || data.sessions.length === 0) {
                container.innerHTML = `
          <div class="activity-item">
            <div>
              <div>Aucune activit√© r√©cente</div>
              <div class="activity-desc">Les sessions d'ex√©cution appara√Ætront ici</div>
            </div>
            <div class="activity-time">--</div>
          </div>`;
                return;
            }
            const html = data.sessions.slice(0, 5).map(s => `
        <div class="activity-item">
          <div>
            <div>${s.total_orders || 0} ordres sur ${s.exchange || 'Exchange'}</div>
            <div class="activity-desc">${s.successful_orders || 0} r√©ussis, ${formatUSD(s.total_volume_usd || 0)} volume</div>
          </div>
          <div class="activity-time">${formatTimeAgo(s.timestamp)}</div>
        </div>`).join('');
            container.innerHTML = html;
        }

        function updateExecutionStatus(data) {
            if (!data || !data.recent_24h) {
                document.getElementById('last-execution').textContent = 'Aucune';
                document.getElementById('success-rate').textContent = '--';
                document.getElementById('volume-24h').textContent = '$0.00';
                const st = document.getElementById('execution-status'); st.className = 'status-badge status-warning'; st.textContent = 'En attente';
                return;
            }
            document.getElementById('last-execution').textContent = data.recent_24h?.total_orders > 0 ? 'R√©cent' : 'Aucune';
            const sr = data.recent_24h?.success_rate;
            document.getElementById('success-rate').textContent = (sr !== undefined) ? sr.toFixed(1) + '%' : '--';
            document.getElementById('volume-24h').textContent = formatUSD(data.recent_24h?.total_volume || 0);

            const st = document.getElementById('execution-status');
            if (sr >= 95) { st.className = 'status-badge status-active'; st.textContent = 'Excellent'; }
            else if (sr >= 90) { st.className = 'status-badge status-warning'; st.textContent = 'Bon'; }
            else if (sr !== undefined) { st.className = 'status-badge status-error'; st.textContent = '√Ä am√©liorer'; }
            else { st.className = 'status-badge status-warning'; st.textContent = 'En attente'; }
        }

        function updateSystemHealth() {
            document.getElementById('api-status').textContent = 'Online';
            document.getElementById('data-freshness').textContent = 'R√©cente';
            document.getElementById('safety-status').textContent = 'Actif';
            const st = document.getElementById('system-health'); st.className = 'status-badge status-active'; st.textContent = 'Healthy';
        }

        function formatUSD(v) {
            if (!v) return '$0.00';
            return new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD', minimumFractionDigits: 2, maximumFractionDigits: 2 }).format(v);
        }
        function formatTimeAgo(ts) {
            if (!ts) return 'N/A';
            const d = new Date(ts), now = new Date(), dm = Math.floor((now - d) / (1000 * 60));
            if (dm < 60) return `${dm}min`;
            if (dm < 1440) return `${Math.floor(dm / 60)}h`;
            return `${Math.floor(dm / 1440)}j`;
        }
        function showError(m) { console.error(m); }
        async function forceRefreshData() { console.log('üîÑ Force refresh demand√© par utilisateur'); await loadDashboardData(); }

        // Configuration Chart.js avec th√®me adaptatif
        function initChartTheme() {
            if (typeof Chart !== 'undefined') {
                Chart.defaults.color = 'var(--theme-text)';
                Chart.defaults.borderColor = 'var(--theme-border)';
                Chart.defaults.backgroundColor = 'var(--theme-surface)';
                Chart.defaults.plugins.tooltip.backgroundColor = 'var(--theme-surface-elevated)';
                Chart.defaults.plugins.tooltip.titleColor = 'var(--theme-text)';
                Chart.defaults.plugins.tooltip.bodyColor = 'var(--theme-text)';
                Chart.defaults.plugins.tooltip.borderColor = 'var(--theme-border)';
                Chart.defaults.plugins.tooltip.borderWidth = 1;
            }
        }

        // Couleurs pour le graphique portfolio
        const PORTFOLIO_COLORS = [
            '#3b82f6', '#ef4444', '#10b981', '#f59e0b', '#8b5cf6',
            '#06b6d4', '#84cc16', '#f97316', '#ec4899', '#6366f1'
        ];

        // Classification dynamique - sera charg√©e depuis alias-manager
        let ASSET_GROUPS = null;

        // Charger la classification depuis alias-manager
        async function loadAssetGroups() {
            try {
                const apiBase = globalConfig?.get('api_base_url') || 'http://localhost:8765';
                const response = await fetch(`${apiBase}/taxonomy`);
                if (response.ok) {
                    const data = await response.json();
                    const aliases = data.aliases || {};
                    
                    // Convertir les aliases en groupes invers√©s
                    ASSET_GROUPS = {};
                    Object.entries(aliases).forEach(([asset, group]) => {
                        if (!ASSET_GROUPS[group]) {
                            ASSET_GROUPS[group] = [];
                        }
                        ASSET_GROUPS[group].push(asset);
                    });
                    
                    console.log('üîç DEBUG: Loaded asset groups from alias-manager:', Object.keys(ASSET_GROUPS));
                    return true;
                }
            } catch (error) {
                console.warn('Could not load from alias-manager API, using fallback:', error);
            }
            
            // Fallback: utiliser la m√™me logique que alias-manager.html
            const fallbackAliases = {
                'BTC': 'BTC', 'TBTC': 'BTC', 'WBTC': 'BTC',
                'ETH': 'ETH', 'WETH': 'ETH', 'STETH': 'ETH', 'WSTETH': 'ETH', 'RETH': 'ETH', 'CBETH': 'ETH',
                'USDC': 'Stablecoins', 'USDT': 'Stablecoins', 'USD': 'Stablecoins', 'DAI': 'Stablecoins',
                'SOL': 'L1/L0 majors', 'SOL2': 'L1/L0 majors',
                'ATOM': 'L1/L0 majors', 'ATOM2': 'L1/L0 majors', 'DOT': 'L1/L0 majors', 'ADA': 'L1/L0 majors',
                'AVAX': 'L1/L0 majors', 'NEAR': 'L1/L0 majors', 'LINK': 'L1/L0 majors', 'XRP': 'L1/L0 majors',
                'BNB': 'Exchange Tokens', 'BGB': 'Exchange Tokens',
                'AAVE': 'DeFi', 'DOGE': 'Memecoins', 'XMR': 'Privacy',
                'IMO': 'Others'
            };
            
            ASSET_GROUPS = {};
            Object.entries(fallbackAliases).forEach(([asset, group]) => {
                if (!ASSET_GROUPS[group]) {
                    ASSET_GROUPS[group] = [];
                }
                ASSET_GROUPS[group].push(asset);
            });
            
            console.log('üîç DEBUG: Using fallback asset groups:', Object.keys(ASSET_GROUPS));
            return false;
        }

        // Parser pour le fichier CSV CoinTracking - corrig√© pour lire TOUS les assets
        function parseCSVBalances(csvText) {
            // Remove BOM if present
            const cleanedText = csvText.replace(/^\ufeff/, '');
            const lines = cleanedText.split('\n');
            const balances = [];
            
            console.log('üîç DEBUG: Parsing CSV with', lines.length, 'total lines');
            console.log('üîç DEBUG: Original first char code:', csvText.charCodeAt(0));
            console.log('üîç DEBUG: Cleaned first char code:', cleanedText.charCodeAt(0));
            console.log('üîç DEBUG: First line (header):', lines[0]);
            console.log('üîç DEBUG: Second line (first data):', lines[1]);
            
            // Skip header line (ligne 1)
            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) {
                    console.log('üîç DEBUG: Skipping empty line', i);
                    continue;
                }
                
                // Debug first few lines in detail
                if (i <= 5) {
                    console.log('üîç DEBUG: Processing line', i, ':', line);
                }
                
                try {
                    // Parse CSV avec des guillemets et point-virgules
                    const columns = parseCSVLine(line);
                    
                    if (i <= 5) {
                        console.log('üîç DEBUG: Line', i, 'parsed to', columns.length, 'columns:', columns);
                    }
                    
                    if (columns.length >= 5) {
                        const ticker = columns[0];
                        const name = columns[1];
                        const type = columns[2];
                        const amount = parseFloat(columns[3]);
                        const valueUSD = parseFloat(columns[4]);
                        
                        if (i <= 5) {
                            console.log('üîç DEBUG: Line', i, 'data:', { ticker, name, type, amount, valueUSD });
                        }
                        
                        // Accepter TOUS les assets avec value > 0.50$ au lieu de 1.0$
                        if (ticker && !isNaN(amount) && !isNaN(valueUSD) && valueUSD >= 0.50) {
                            const balance = {
                                symbol: ticker.toUpperCase(),
                                balance: amount,
                                value_usd: valueUSD
                            };
                            balances.push(balance);
                            
                            // Debug log for significant assets
                            if (valueUSD > 1000 || i <= 5) {
                                console.log('üîç DEBUG: Asset added:', ticker, '-', valueUSD.toFixed(2), '$');
                            }
                        } else if (ticker) {
                            // Log des assets exclus pour debug
                            if ((valueUSD < 0.50 && valueUSD > 0) || i <= 5) {
                                console.log('üîç DEBUG: Excluded asset:', ticker, '-', valueUSD, '$', 'reason:', !ticker ? 'no ticker' : isNaN(amount) ? 'invalid amount' : isNaN(valueUSD) ? 'invalid value' : 'value < 0.50');
                            }
                        }
                    } else {
                        if (i <= 5) {
                            console.log('üîç DEBUG: Invalid line format, columns:', columns.length, 'in line:', line);
                        }
                    }
                } catch (error) {
                    console.warn('Erreur parsing ligne CSV:', error.message);
                }
            }
            
            const totalParsed = balances.reduce((sum, item) => sum + item.value_usd, 0);
            console.log('üîç DEBUG: CSV parsing complete -', balances.length, 'assets, total:', totalParsed.toFixed(2), '$');
            
            // Afficher les 10 plus gros assets pour v√©rification
            const sortedBalances = [...balances].sort((a, b) => b.value_usd - a.value_usd).slice(0, 10);
            console.log('üîç DEBUG: Top 10 assets:');
            sortedBalances.forEach((asset, i) => {
                console.log(`  ${i+1}. ${asset.symbol}: ${asset.value_usd.toFixed(2)}$`);
            });
            
            return balances;
        }
        
        // Parser une ligne CSV avec guillemets et point-virgules
        function parseCSVLine(line) {
            const result = [];
            let current = '';
            let inQuotes = false;
            
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                
                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === ';' && !inQuotes) {
                    result.push(current.trim().replace(/^"|"$/g, ''));
                    current = '';
                } else {
                    current += char;
                }
            }
            
            // Ajouter le dernier √©l√©ment
            if (current) {
                result.push(current.trim().replace(/^"|"$/g, ''));
            }
            
            return result;
        }

        function groupAssetsByAliases(items) {
            const groups = new Map();
            const ungrouped = [];

            console.log('üîç DEBUG: Grouping', items.length, 'assets by aliases');
            
            // Si ASSET_GROUPS n'est pas encore charg√©, mettre tout dans "Others"
            if (!ASSET_GROUPS) {
                console.warn('‚ö†Ô∏è ASSET_GROUPS not loaded yet, putting all assets in Others');
                const totalValue = items.reduce((sum, item) => sum + parseFloat(item.value_usd || 0), 0);
                return [{
                    label: 'Others',
                    value: totalValue,
                    assets: items.map(item => item.symbol)
                }];
            }

            items.forEach(item => {
                const symbol = (item.symbol || '').toUpperCase();
                let foundGroup = null;

                // Chercher dans quel groupe appartient ce symbol
                for (const [groupName, aliases] of Object.entries(ASSET_GROUPS)) {
                    if (aliases.includes(symbol)) {
                        foundGroup = groupName;
                        break;
                    }
                }

                if (foundGroup) {
                    if (!groups.has(foundGroup)) {
                        groups.set(foundGroup, {
                            label: foundGroup,
                            value: 0,
                            assets: []
                        });
                    }
                    const group = groups.get(foundGroup);
                    group.value += parseFloat(item.value_usd || 0);
                    group.assets.push(symbol);
                    
                    // Debug log for significant groupings
                    if (item.value_usd > 5000) {
                        console.log('üîç DEBUG: Grouped', symbol, 'into', foundGroup, '- value:', item.value_usd.toFixed(2));
                    }
                } else {
                    ungrouped.push({
                        label: symbol,
                        value: parseFloat(item.value_usd || 0)
                    });
                    
                    // Debug log for ungrouped assets
                    if (item.value_usd > 1000) {
                        console.log('‚ö†Ô∏è DEBUG: UNGROUPED asset:', symbol, '- value:', item.value_usd.toFixed(2));
                    }
                }
            });

            console.log('üîç DEBUG: Final groups:', groups.size, 'grouped +', ungrouped.length, 'ungrouped');
            const result = [...Array.from(groups.values()), ...ungrouped];
            
            // Debug final result
            result.forEach(group => {
                if (group.value > 1000) {
                    console.log('üîç DEBUG: Final group:', group.label, '- value:', group.value.toFixed(2));
                    if (group.assets && group.assets.length > 1) {
                        console.log('  ‚îî‚îÄ Assets:', group.assets.join(', '));
                    }
                }
            });
            
            return result;
        }

        // Cr√©er ou mettre √† jour le graphique portfolio
        function updatePortfolioChart(balancesData) {
            console.log('üîç DEBUG updatePortfolioChart - balancesData:', balancesData);

            if (!balancesData || !balancesData.items) {
                console.log('‚ùå No balances data or items');
                return;
            }

            const canvas = document.getElementById('portfolioChartCanvas');
            if (!canvas) {
                console.log('‚ùå Canvas element not found');
                return;
            }

            // V√©rifier que Chart.js est charg√©
            if (typeof Chart === 'undefined') {
                console.log('‚ùå Chart.js not loaded');
                document.getElementById('portfolio-chart').innerHTML = '<div style="text-align: center; padding: 20px; color: var(--danger);">‚ùå Chart.js not loaded</div>';
                return;
            }

            const ctx = canvas.getContext('2d');
            console.log('üîç DEBUG - Number of items:', balancesData.items.length);

            // Traiter les donn√©es pour le graphique avec regroupement par aliases
            const items = balancesData.items || [];
            const filteredItems = items.filter(item => parseFloat(item.value_usd || 0) > 0);

            // Regrouper par aliases
            const groupedData = groupAssetsByAliases(filteredItems);

            // Trier par valeur et prendre les top 8
            const sortedData = groupedData
                .sort((a, b) => b.value - a.value)
                .slice(0, 8);

            const labels = sortedData.map(item => item.label);
            const values = sortedData.map(item => item.value);
            const total = values.reduce((sum, val) => sum + val, 0);

            // D√©truire l'ancien graphique s'il existe
            if (portfolioChart) {
                portfolioChart.destroy();
            }

            // Obtenir les couleurs du th√®me actuel
            const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
            const tooltipBg = isDark ? '#374151' : '#f9fafb';
            const tooltipText = isDark ? '#f9fafb' : '#1f2937';
            const tooltipBorder = isDark ? '#6b7280' : '#d1d5db';

            // Cr√©er le nouveau graphique
            portfolioChart = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: labels,
                    datasets: [{
                        data: values,
                        backgroundColor: PORTFOLIO_COLORS.slice(0, values.length),
                        borderColor: isDark ? '#374151' : '#ffffff',
                        borderWidth: 2,
                        hoverBorderWidth: 3
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            backgroundColor: tooltipBg,
                            titleColor: tooltipText,
                            bodyColor: tooltipText,
                            borderColor: tooltipBorder,
                            borderWidth: 1,
                            cornerRadius: 8,
                            padding: 12,
                            callbacks: {
                                label: function (context) {
                                    const value = context.parsed;
                                    const percentage = ((value / total) * 100).toFixed(1);
                                    const groupData = sortedData[context.dataIndex];
                                    let label = `${context.label}: ${formatUSD(value)} (${percentage}%)`;

                                    // Ajouter les assets du groupe si c'est un groupe
                                    if (groupData.assets && groupData.assets.length > 1) {
                                        label += `\nAssets: ${groupData.assets.join(', ')}`;
                                    }

                                    return label;
                                }
                            }
                        }
                    },
                    cutout: '60%',
                    animation: {
                        animateRotate: true,
                        duration: 1000
                    },
                    interaction: {
                        intersect: false,
                        mode: 'point'
                    }
                }
            });
        }

        // Afficher la liste d√©taill√©e des allocations pour debug
        function updatePortfolioBreakdown(balancesData) {
            const container = document.getElementById('breakdown-list');
            
            if (!balancesData || !balancesData.items) {
                container.innerHTML = '<div style="color: var(--danger);">‚ùå Pas de donn√©es</div>';
                return;
            }

            const items = balancesData.items || [];
            const filteredItems = items.filter(item => parseFloat(item.value_usd || 0) > 0);
            
            // Regrouper par aliases comme le graphique
            const groupedData = groupAssetsByAliases(filteredItems);
            const sortedData = groupedData.sort((a, b) => b.value - a.value);
            const total = sortedData.reduce((sum, item) => sum + item.value, 0);
            
            console.log('üîç DEBUG updatePortfolioBreakdown - total:', total, 'groups:', sortedData.length);
            
            const html = sortedData.map((group, index) => {
                const percentage = ((group.value / total) * 100).toFixed(1);
                const assets = group.assets ? ` (${group.assets.join(', ')})` : '';
                return `
                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 4px 0; border-bottom: 1px solid var(--theme-border);">
                        <span style="color: var(--theme-text);">${group.label}${assets}</span>
                        <span style="font-weight: 600; color: var(--theme-text);">${formatUSD(group.value)} (${percentage}%)</span>
                    </div>
                `;
            }).join('');
            
            container.innerHTML = html + `
                <div style="display: flex; justify-content: space-between; align-items: center; padding: 8px 0; margin-top: 8px; font-weight: 700; border-top: 2px solid var(--theme-border);">
                    <span>TOTAL</span>
                    <span>${formatUSD(total)} (100%)</span>
                </div>
            `;
        }

        // Toggle pour afficher/cacher le breakdown d√©taill√©
        function toggleBreakdown() {
            const list = document.getElementById('breakdown-list');
            const arrow = document.getElementById('breakdown-arrow');
            
            if (list.style.display === 'none') {
                list.style.display = 'block';
                arrow.textContent = '‚ñºÔ∏è';
            } else {
                list.style.display = 'none';
                arrow.textContent = '‚ñ∂Ô∏è';
            }
        }

        // Forcer un refresh des donn√©es avec la source actuelle
        async function forceRefreshData() {
            console.log('üîÑ Force refresh demand√© par utilisateur');
            // Vider le cache si n√©cessaire
            await loadDashboardData();
        }
    </script>
</body>

</html>