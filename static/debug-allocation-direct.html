<!DOCTYPE html>
<html>
<head>
    <title>Debug Allocation Direct</title>
    <script src="global-config.js"></script>
</head>
<body>
    <h1>üîß Debug Allocation Engine Direct</h1>
    <button onclick="testAllocationEngine()">Test Direct Allocation Engine</button>
    <button onclick="testStrategyAPI()">Test Strategy API</button>
    <pre id="output"></pre>

    <script type="module">
        import { calculateHierarchicalAllocation } from './core/allocation-engine.js';
        import { calculateIntelligentDecisionIndexAPI } from './core/strategy-api-adapter.js';

        const output = document.getElementById('output');

        function log(message) {
            output.textContent += message + '\n';
            console.log(message);
        }

        window.testAllocationEngine = async function() {
            log('üß™ Test direct de l\'allocation engine V2...\n');

            try {
                const context = {
                    cycleScore: 100,  // Bullish pour avoir des floors renforc√©s
                    onchainScore: 36,
                    riskScore: 47,
                    contradiction: 0.48,
                    risk_budget: { target_stables_pct: 20 },
                    execution: { cap_pct_per_iter: 7 }
                };

                const mockPositions = [
                    { symbol: 'BTC', value_usd: 1000 },
                    { symbol: 'ETH', value_usd: 800 },
                    { symbol: 'SOL', value_usd: 300 },
                    { symbol: 'USDC', value_usd: 1500 },
                    { symbol: 'LINK', value_usd: 200 }
                ];

                log('üìä Context:');
                log(JSON.stringify(context, null, 2));
                log('\nüí∞ Positions:');
                log(JSON.stringify(mockPositions, null, 2));

                log('\nüöÄ Calling calculateHierarchicalAllocation...');
                const result = await calculateHierarchicalAllocation(context, mockPositions, { enableV2: true });

                if (result) {
                    log('\n‚úÖ SUCCESS! Allocation engine returned:');
                    log(`Version: ${result.version}`);
                    log(`Phase: ${result.metadata?.phase}`);
                    log(`Total check: ${JSON.stringify(result.metadata?.total_check)}`);

                    log('\nüìã Allocation:');
                    Object.entries(result.allocation || {}).forEach(([asset, weight]) => {
                        log(`  ${asset}: ${(weight * 100).toFixed(2)}% ${isNaN(weight) ? '‚ö†Ô∏è NaN!' : ''}`);
                    });

                    log('\nüéØ Execution Plan:');
                    log(JSON.stringify(result.execution, null, 2));
                } else {
                    log('‚ùå √âCHEC! Allocation engine returned null');
                    log('V√©rifiez les erreurs dans la console du navigateur');
                }

            } catch (error) {
                log(`‚ùå ERREUR: ${error.message}`);
                log(`Stack: ${error.stack}`);
            }
        };

        window.testStrategyAPI = async function() {
            log('\nüß™ Test Strategy API Adapter...\n');

            try {
                const context = {
                    cycleData: { score: 100, confidence: 0.9 },
                    onchainScore: 36,
                    riskScore: 47,
                    contradiction: 0.48,
                    adaptiveWeights: {
                        wCycle: 0.65,
                        wOnchain: 0.25,
                        wRisk: 0.1
                    }
                };

                log('üìä Strategy API Context:');
                log(JSON.stringify(context, null, 2));

                log('\nüöÄ Calling calculateIntelligentDecisionIndexAPI...');
                const result = await calculateIntelligentDecisionIndexAPI(context);

                if (result) {
                    log('\n‚úÖ SUCCESS! Strategy API returned:');
                    log(`Score: ${result.score}`);
                    log(`Source: ${result.source}`);
                    log(`Confidence: ${result.confidence}`);
                    log(`Targets count: ${result.targets?.length || 0}`);

                    if (result.targets && result.targets.length > 0) {
                        log('\nüéØ Targets:');
                        result.targets.forEach(target => {
                            log(`  ${target.symbol}: ${(target.weight * 100).toFixed(2)}%`);
                        });
                    } else {
                        log('\n‚ùå NO TARGETS FOUND!');
                    }
                } else {
                    log('‚ùå √âCHEC! Strategy API returned null');
                }

            } catch (error) {
                log(`‚ùå ERREUR: ${error.message}`);
                log(`Stack: ${error.stack}`);
            }
        };
    </script>
</body>
</html>