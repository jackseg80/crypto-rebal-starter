<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üî¨ Test Suite Stabilit√© - Production Ready</title>
    <link rel="stylesheet" href="shared-theme.css">
    <style>
        .test-suite {
            max-width: 1400px;
            margin: 0 auto;
            padding: 1rem;
        }

        .test-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 1rem;
            margin: 1rem 0;
        }

        .test-card {
            background: var(--theme-bg);
            border: 1px solid var(--theme-border);
            border-radius: var(--radius-md);
            padding: 1rem;
        }

        .test-scenario {
            background: var(--theme-bg-secondary);
            border-radius: var(--radius-sm);
            padding: 0.75rem;
            margin: 0.5rem 0;
            border-left: 4px solid var(--theme-border);
        }

        .test-scenario.running {
            border-left-color: var(--warning);
            background: color-mix(in oklab, var(--warning) 10%, var(--theme-bg-secondary));
        }

        .test-scenario.pass {
            border-left-color: var(--success);
            background: color-mix(in oklab, var(--success) 10%, var(--theme-bg-secondary));
        }

        .test-scenario.fail {
            border-left-color: var(--danger);
            background: color-mix(in oklab, var(--danger) 10%, var(--theme-bg-secondary));
        }

        .test-controls {
            display: flex;
            gap: 0.5rem;
            margin: 1rem 0;
            flex-wrap: wrap;
        }

        .control-button {
            padding: 0.5rem 1rem;
            border: 1px solid var(--theme-border);
            border-radius: var(--radius-sm);
            background: var(--theme-bg);
            color: var(--theme-text);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .control-button:hover {
            background: var(--theme-bg-secondary);
        }

        .control-button.primary {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }

        .control-button.danger {
            background: var(--danger);
            color: white;
            border-color: var(--danger);
        }

        .stability-chart {
            height: 200px;
            background: var(--theme-bg-secondary);
            border-radius: var(--radius-sm);
            margin: 0.5rem 0;
            position: relative;
            overflow: hidden;
        }

        .chart-line {
            position: absolute;
            height: 2px;
            background: var(--primary);
            transition: all 0.1s ease;
        }

        .chart-point {
            position: absolute;
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: var(--primary);
            transform: translate(-50%, -50%);
        }

        .rate-limit-status {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 0.5rem;
            margin: 0.5rem 0;
        }

        .status-item {
            text-align: center;
            padding: 0.5rem;
            background: var(--theme-bg-secondary);
            border-radius: var(--radius-sm);
        }

        .status-value {
            font-weight: 600;
            font-size: 1.1rem;
            color: var(--theme-text);
        }

        .status-label {
            font-size: 0.875rem;
            color: var(--theme-text-muted);
        }

        .log-output {
            background: #1a1a1a;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            padding: 1rem;
            border-radius: var(--radius-sm);
            height: 200px;
            overflow-y: auto;
            font-size: 0.875rem;
            margin: 0.5rem 0;
        }

        .progress-bar {
            width: 100%;
            height: 6px;
            background: var(--theme-border);
            border-radius: 3px;
            overflow: hidden;
            margin: 0.5rem 0;
        }

        .progress-fill {
            height: 100%;
            background: var(--primary);
            transition: width 0.3s ease;
            width: 0%;
        }
    </style>
</head>
<body>
    <div class="test-suite">
        <h1>üî¨ Test Suite Stabilit√© - Production Ready</h1>
        <p>Suite compl√®te de tests pour hyst√©r√©sis, EMA, staleness gating et rate limiting adaptatif.</p>

        <div class="test-controls">
            <button class="control-button primary" onclick="runFullSuite()">üöÄ Suite Compl√®te</button>
            <button class="control-button" onclick="runHysteresisTests()">‚öñÔ∏è Hyst√©r√©sis</button>
            <button class="control-button" onclick="runStalenesTests()">üîí Staleness</button>
            <button class="control-button" onclick="runRateLimitTests()">ü™£ Rate Limit</button>
            <button class="control-button danger" onclick="resetAllTests()">üîÑ Reset</button>
        </div>

        <div class="progress-bar">
            <div class="progress-fill" id="overall-progress"></div>
        </div>

        <div class="test-grid">
            <!-- Hyst√©r√©sis Tests -->
            <div class="test-card">
                <h3>‚öñÔ∏è Tests Hyst√©r√©sis & EMA</h3>
                <div id="hysteresis-scenarios"></div>
                <div class="stability-chart" id="hysteresis-chart"></div>
            </div>

            <!-- Staleness Gating Tests -->
            <div class="test-card">
                <h3>üîí Tests Staleness Gating</h3>
                <div id="staleness-scenarios"></div>
                <div class="stability-chart" id="staleness-chart"></div>
            </div>

            <!-- Rate Limiting Tests -->
            <div class="test-card">
                <h3>ü™£ Tests Rate Limiting</h3>
                <div id="rate-limit-scenarios"></div>
                <div class="rate-limit-status" id="rate-limit-status">
                    <div class="status-item">
                        <div class="status-value" id="tokens-available">12</div>
                        <div class="status-label">Tokens</div>
                    </div>
                    <div class="status-item">
                        <div class="status-value" id="hit-ratio">0%</div>
                        <div class="status-label">Cache Hit</div>
                    </div>
                    <div class="status-item">
                        <div class="status-value" id="adaptive-ttl">30s</div>
                        <div class="status-label">TTL</div>
                    </div>
                </div>
            </div>

            <!-- Integration Tests -->
            <div class="test-card">
                <h3>üîß Tests Int√©gration</h3>
                <div id="integration-scenarios"></div>
                <div class="rate-limit-status" id="integration-status">
                    <div class="status-item">
                        <div class="status-value" id="stability-score">-</div>
                        <div class="status-label">Stabilit√©</div>
                    </div>
                    <div class="status-item">
                        <div class="status-value" id="robustness-score">-</div>
                        <div class="status-label">Robustesse</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Log Output -->
        <div class="test-card">
            <h3>üìã Console de Test</h3>
            <div class="log-output" id="test-console"></div>
        </div>
    </div>

    <script type="module">
        import { getStableContradiction, applyHysteresis, resetStabilityState, forceStalenessFrozen, getStabilityDebugInfo } from './governance/stability-engine.js';
        import { calculateAdaptiveWeights, calculateRiskCaps } from './governance/contradiction-policy.js';

        // Test state management
        let testState = {
            governance: { contradiction_index: 0.47 },
            ui: { apiStatus: { backend: 'healthy' } }
        };

        let testResults = {
            hysteresis: [],
            staleness: [],
            rateLimit: [],
            integration: []
        };

        let currentTest = 0;
        let totalTests = 0;

        // Mock rate limiter for testing
        class MockRateLimiter {
            constructor() {
                this.tokens = 12;
                this.hits = 0;
                this.misses = 0;
                this.lastRefill = Date.now();
            }

            async checkRateLimit(clientId, endpoint = "") {
                const now = Date.now();
                const elapsed = (now - this.lastRefill) / 1000;
                this.tokens = Math.min(12, this.tokens + elapsed * 6); // 6 tokens/sec
                this.lastRefill = now;

                if (this.tokens >= 1) {
                    this.tokens -= 1;
                    this.hits++;
                    return [true, { available_tokens: Math.floor(this.tokens) }];
                } else {
                    this.misses++;
                    return [false, { available_tokens: 0, time_until_available: (1 - this.tokens) / 6 }];
                }
            }

            getAdaptiveCacheTTL() {
                const hitRatio = this.hits / (this.hits + this.misses);
                return Math.round(30 * (1 + hitRatio));
            }
        }

        const mockRateLimiter = new MockRateLimiter();

        // Logging utilities
        function log(message, type = 'info') {
            const console = document.getElementById('test-console');
            const timestamp = new Date().toLocaleTimeString();
            const colorMap = {
                info: '#00ff00',
                warn: '#ffaa00',
                error: '#ff0000',
                success: '#00ff88'
            };

            const color = colorMap[type] || '#00ff00';
            console.innerHTML += `<span style="color: ${color}">[${timestamp}] ${message}</span>\n`;
            console.scrollTop = console.scrollHeight;
        }

        function updateProgress() {
            const progress = (currentTest / totalTests) * 100;
            document.getElementById('overall-progress').style.width = `${progress}%`;
        }

        function addScenario(container, title, status = 'pending') {
            const scenario = document.createElement('div');
            scenario.className = `test-scenario ${status}`;
            scenario.innerHTML = `<strong>${title}</strong>`;
            scenario.id = `scenario-${Date.now()}-${Math.random()}`;
            document.getElementById(container).appendChild(scenario);
            return scenario;
        }

        function updateScenario(scenario, status, details = '') {
            scenario.className = `test-scenario ${status}`;
            if (details) {
                scenario.innerHTML += `<br><small>${details}</small>`;
            }
        }

        // Hyst√©r√©sis Tests
        async function runHysteresisTests() {
            log('üîß D√©marrage tests hyst√©r√©sis & EMA', 'info');
            resetStabilityState();

            const scenarios = [
                'Test deadband ¬±2%',
                'Test persistence 3 ticks',
                'Test EMA smoothing',
                'Test oscillation prevention'
            ];

            for (const scenarioTitle of scenarios) {
                const scenario = addScenario('hysteresis-scenarios', scenarioTitle, 'running');

                try {
                    await testHysteresisScenario(scenarioTitle);
                    updateScenario(scenario, 'pass', '‚úÖ R√©ussi');
                    testResults.hysteresis.push({ scenario: scenarioTitle, result: 'pass' });
                } catch (error) {
                    updateScenario(scenario, 'fail', `‚ùå ${error.message}`);
                    testResults.hysteresis.push({ scenario: scenarioTitle, result: 'fail', error: error.message });
                }

                currentTest++;
                updateProgress();
                await sleep(500);
            }

            log('‚úÖ Tests hyst√©r√©sis termin√©s', 'success');
        }

        async function testHysteresisScenario(scenario) {
            switch (scenario) {
                case 'Test deadband ¬±2%':
                    // Test que les changements < 2% ne d√©clenchent pas de changement
                    resetStabilityState();
                    testState.governance.contradiction_index = 0.50;
                    let result1 = getStableContradiction(testState);

                    testState.governance.contradiction_index = 0.51; // +1% < deadband
                    let result2 = getStableContradiction(testState);

                    if (Math.abs(result1 - result2) > 0.001) {
                        throw new Error('Deadband failed: small change triggered update');
                    }
                    log('   Deadband ¬±2% valid√©', 'success');
                    break;

                case 'Test persistence 3 ticks':
                    resetStabilityState();
                    testState.governance.contradiction_index = 0.50;
                    getStableContradiction(testState); // Initial

                    // 3 ticks with consistent direction
                    testState.governance.contradiction_index = 0.55; // +5% > deadband
                    let tick1 = getStableContradiction(testState);
                    let tick2 = getStableContradiction(testState);
                    let tick3 = getStableContradiction(testState);

                    if (Math.abs(tick3 - 0.55) > 0.02) {
                        throw new Error('Persistence failed: change not applied after 3 ticks');
                    }
                    log('   Persistence 3 ticks valid√©e', 'success');
                    break;

                case 'Test EMA smoothing':
                    resetStabilityState();
                    testState.governance.contradiction_index = 0.30;
                    let baseline = getStableContradiction(testState);

                    testState.governance.contradiction_index = 0.70; // Jump +40%
                    let smoothed = getStableContradiction(testState);

                    // EMA should smooth the jump
                    if (Math.abs(smoothed - 0.70) < 0.05) {
                        throw new Error('EMA smoothing failed: no smoothing detected');
                    }
                    log('   EMA smoothing valid√©', 'success');
                    break;

                case 'Test oscillation prevention':
                    resetStabilityState();
                    testState.governance.contradiction_index = 0.50;
                    let values = [];

                    // Simulate oscillating input
                    for (let i = 0; i < 10; i++) {
                        testState.governance.contradiction_index = 0.50 + (i % 2 === 0 ? 0.01 : -0.01);
                        values.push(getStableContradiction(testState));
                    }

                    // Check for stability (low variance)
                    const variance = values.reduce((acc, val) => acc + Math.pow(val - 0.50, 2), 0) / values.length;
                    if (variance > 0.001) {
                        throw new Error('Oscillation prevention failed: high variance detected');
                    }
                    log('   Anti-oscillation valid√©', 'success');
                    break;
            }
        }

        // Staleness Tests
        async function runStalenesTests() {
            log('üîí D√©marrage tests staleness gating', 'info');

            const scenarios = [
                'Test freeze on stale data',
                'Test resume on fresh data',
                'Test defensive caps preservation',
                'Test graceful degradation'
            ];

            for (const scenarioTitle of scenarios) {
                const scenario = addScenario('staleness-scenarios', scenarioTitle, 'running');

                try {
                    await testStalenessScenario(scenarioTitle);
                    updateScenario(scenario, 'pass', '‚úÖ R√©ussi');
                    testResults.staleness.push({ scenario: scenarioTitle, result: 'pass' });
                } catch (error) {
                    updateScenario(scenario, 'fail', `‚ùå ${error.message}`);
                    testResults.staleness.push({ scenario: scenarioTitle, result: 'fail', error: error.message });
                }

                currentTest++;
                updateProgress();
                await sleep(500);
            }

            log('‚úÖ Tests staleness termin√©s', 'success');
        }

        async function testStalenessScenario(scenario) {
            switch (scenario) {
                case 'Test freeze on stale data':
                    resetStabilityState();
                    forceStalenessFrozen(true);

                    testState.governance.contradiction_index = 0.30;
                    let frozenValue = getStableContradiction(testState);

                    testState.governance.contradiction_index = 0.80; // Big change
                    let shouldBeFrozen = getStableContradiction(testState);

                    if (Math.abs(shouldBeFrozen - frozenValue) > 0.01) {
                        throw new Error('Staleness freeze failed: values changed when frozen');
                    }
                    log('   Freeze sur donn√©es stale valid√©', 'success');
                    break;

                case 'Test resume on fresh data':
                    forceStalenessFrozen(false);

                    testState.governance.contradiction_index = 0.60;
                    let resumedValue = getStableContradiction(testState);

                    // Should resume processing
                    if (Math.abs(resumedValue - 0.60) > 0.1) {
                        log('   Resume apr√®s staleness valid√©', 'success');
                    } else {
                        throw new Error('Resume failed: still frozen after unfreezing');
                    }
                    break;

                case 'Test defensive caps preservation':
                    forceStalenessFrozen(true);

                    const caps = calculateRiskCaps({}, testState);

                    // Even when frozen, caps should still apply defensive limits
                    if (caps.memecoins > 0.15 || caps.small_caps > 0.25) {
                        throw new Error('Defensive caps failed: caps too high during staleness');
                    }
                    log('   Caps d√©fensifs pr√©serv√©s', 'success');
                    break;

                case 'Test graceful degradation':
                    // Simulate various failure modes
                    forceStalenessFrozen(true);

                    const debugInfo = getStabilityDebugInfo();
                    if (!debugInfo.analysis.staleness_frozen) {
                        throw new Error('Graceful degradation failed: staleness flag not set');
                    }
                    log('   D√©gradation gracieuse valid√©e', 'success');
                    break;
            }
        }

        // Rate Limiting Tests
        async function runRateLimitTests() {
            log('ü™£ D√©marrage tests rate limiting', 'info');

            const scenarios = [
                'Test token bucket mechanics',
                'Test burst handling',
                'Test adaptive cache TTL',
                'Test graceful degradation'
            ];

            for (const scenarioTitle of scenarios) {
                const scenario = addScenario('rate-limit-scenarios', scenarioTitle, 'running');

                try {
                    await testRateLimitScenario(scenarioTitle);
                    updateScenario(scenario, 'pass', '‚úÖ R√©ussi');
                    testResults.rateLimit.push({ scenario: scenarioTitle, result: 'pass' });
                } catch (error) {
                    updateScenario(scenario, 'fail', `‚ùå ${error.message}`);
                    testResults.rateLimit.push({ scenario: scenarioTitle, result: 'fail', error: error.message });
                }

                currentTest++;
                updateProgress();
                await sleep(500);
            }

            updateRateLimitStatus();
            log('‚úÖ Tests rate limiting termin√©s', 'success');
        }

        async function testRateLimitScenario(scenario) {
            switch (scenario) {
                case 'Test token bucket mechanics':
                    // Test basic token consumption
                    let [allowed1] = await mockRateLimiter.checkRateLimit('test-client');
                    if (!allowed1) {
                        throw new Error('Token bucket failed: should allow first request');
                    }

                    // Exhaust bucket
                    for (let i = 0; i < 15; i++) {
                        await mockRateLimiter.checkRateLimit('test-client');
                    }

                    let [allowed2] = await mockRateLimiter.checkRateLimit('test-client');
                    if (allowed2) {
                        throw new Error('Token bucket failed: should block after exhaustion');
                    }
                    log('   Token bucket mechanics valid√©s', 'success');
                    break;

                case 'Test burst handling':
                    // Reset bucket
                    mockRateLimiter.tokens = 12;

                    // Should handle burst of 12 requests
                    let burstResults = [];
                    for (let i = 0; i < 12; i++) {
                        let [allowed] = await mockRateLimiter.checkRateLimit('burst-client');
                        burstResults.push(allowed);
                    }

                    if (!burstResults.every(r => r)) {
                        throw new Error('Burst handling failed: should allow burst within capacity');
                    }
                    log('   Burst handling valid√©', 'success');
                    break;

                case 'Test adaptive cache TTL':
                    let baseTTL = mockRateLimiter.getAdaptiveCacheTTL();

                    // Simulate high hit ratio
                    mockRateLimiter.hits = 80;
                    mockRateLimiter.misses = 20;
                    let highHitTTL = mockRateLimiter.getAdaptiveCacheTTL();

                    if (highHitTTL <= baseTTL) {
                        throw new Error('Adaptive TTL failed: should increase with high hit ratio');
                    }
                    log('   TTL adaptatif valid√©', 'success');
                    break;

                case 'Test graceful degradation':
                    // Test behavior under extreme load
                    let consecutiveBlocks = 0;
                    for (let i = 0; i < 20; i++) {
                        let [allowed] = await mockRateLimiter.checkRateLimit('stress-client');
                        if (!allowed) consecutiveBlocks++;
                    }

                    if (consecutiveBlocks < 5) {
                        throw new Error('Graceful degradation failed: should block under extreme load');
                    }
                    log('   D√©gradation gracieuse valid√©e', 'success');
                    break;
            }
        }

        function updateRateLimitStatus() {
            document.getElementById('tokens-available').textContent = Math.floor(mockRateLimiter.tokens);

            const hitRatio = mockRateLimiter.hits / (mockRateLimiter.hits + mockRateLimiter.misses);
            document.getElementById('hit-ratio').textContent = `${Math.round(hitRatio * 100)}%`;

            document.getElementById('adaptive-ttl').textContent = `${mockRateLimiter.getAdaptiveCacheTTL()}s`;
        }

        // Integration Tests
        async function runIntegrationTests() {
            log('üîß D√©marrage tests int√©gration', 'info');

            const scenarios = [
                'Test pipeline complet',
                'Test coherence multi-modules',
                'Test edge cases',
                'Test performance sous charge'
            ];

            for (const scenarioTitle of scenarios) {
                const scenario = addScenario('integration-scenarios', scenarioTitle, 'running');

                try {
                    await testIntegrationScenario(scenarioTitle);
                    updateScenario(scenario, 'pass', '‚úÖ R√©ussi');
                    testResults.integration.push({ scenario: scenarioTitle, result: 'pass' });
                } catch (error) {
                    updateScenario(scenario, 'fail', `‚ùå ${error.message}`);
                    testResults.integration.push({ scenario: scenarioTitle, result: 'fail', error: error.message });
                }

                currentTest++;
                updateProgress();
                await sleep(500);
            }

            updateIntegrationStatus();
            log('‚úÖ Tests int√©gration termin√©s', 'success');
        }

        async function testIntegrationScenario(scenario) {
            switch (scenario) {
                case 'Test pipeline complet':
                    resetStabilityState();

                    // Test full pipeline: contradiction ‚Üí stability ‚Üí weights ‚Üí caps
                    testState.governance.contradiction_index = 0.65;

                    let stableContradiction = getStableContradiction(testState);
                    let weights = calculateAdaptiveWeights({}, testState);
                    let caps = calculateRiskCaps({}, testState);

                    // Verify coherence
                    if (Math.abs(weights.cycle + weights.onchain + weights.risk - 1) > 0.001) {
                        throw new Error('Pipeline failed: weights sum != 1');
                    }

                    if (weights.risk < 0.25) {
                        throw new Error('Pipeline failed: risk weight should increase with contradiction');
                    }

                    log('   Pipeline complet valid√©', 'success');
                    break;

                case 'Test coherence multi-modules':
                    // Test that all modules use consistent data
                    let testResults = [];

                    for (let i = 0; i < 5; i++) {
                        testState.governance.contradiction_index = 0.3 + (i * 0.1);

                        let contradiction = getStableContradiction(testState);
                        let weights = calculateAdaptiveWeights({}, testState);

                        testResults.push({ contradiction, weights });
                    }

                    // Check monotonicity: risk should increase with contradiction
                    for (let i = 1; i < testResults.length; i++) {
                        if (testResults[i].weights.risk <= testResults[i-1].weights.risk) {
                            throw new Error('Coherence failed: risk not monotonic with contradiction');
                        }
                    }

                    log('   Coh√©rence multi-modules valid√©e', 'success');
                    break;

                case 'Test edge cases':
                    // Test extreme values
                    resetStabilityState();

                    testState.governance.contradiction_index = 0; // Minimum
                    let minWeights = calculateAdaptiveWeights({}, testState);

                    testState.governance.contradiction_index = 1; // Maximum
                    let maxWeights = calculateAdaptiveWeights({}, testState);

                    // All weights should be within bounds
                    for (let key of ['cycle', 'onchain', 'risk']) {
                        if (minWeights[key] < 0.12 || minWeights[key] > 0.65 ||
                            maxWeights[key] < 0.12 || maxWeights[key] > 0.65) {
                            throw new Error(`Edge case failed: ${key} weight out of bounds`);
                        }
                    }

                    log('   Cas limites valid√©s', 'success');
                    break;

                case 'Test performance sous charge':
                    resetStabilityState();
                    let start = performance.now();

                    // Simulate high frequency updates
                    for (let i = 0; i < 1000; i++) {
                        testState.governance.contradiction_index = Math.random();
                        getStableContradiction(testState);
                        calculateAdaptiveWeights({}, testState);
                    }

                    let duration = performance.now() - start;

                    if (duration > 100) { // Should complete in < 100ms
                        throw new Error(`Performance failed: ${duration}ms for 1000 iterations`);
                    }

                    log(`   Performance valid√©e: ${duration.toFixed(1)}ms`, 'success');
                    break;
            }
        }

        function updateIntegrationStatus() {
            const stabilityPassed = testResults.hysteresis.filter(r => r.result === 'pass').length;
            const stabilityTotal = testResults.hysteresis.length;
            const stabilityScore = stabilityTotal > 0 ? Math.round((stabilityPassed / stabilityTotal) * 100) : 0;

            const robustnessPassed = testResults.staleness.filter(r => r.result === 'pass').length +
                                   testResults.rateLimit.filter(r => r.result === 'pass').length;
            const robustnessTotal = testResults.staleness.length + testResults.rateLimit.length;
            const robustnessScore = robustnessTotal > 0 ? Math.round((robustnessPassed / robustnessTotal) * 100) : 0;

            document.getElementById('stability-score').textContent = `${stabilityScore}%`;
            document.getElementById('robustness-score').textContent = `${robustnessScore}%`;
        }

        // Main test runners
        async function runFullSuite() {
            log('üöÄ D√©marrage suite compl√®te de tests', 'info');

            // Clear previous results
            document.getElementById('hysteresis-scenarios').innerHTML = '';
            document.getElementById('staleness-scenarios').innerHTML = '';
            document.getElementById('rate-limit-scenarios').innerHTML = '';
            document.getElementById('integration-scenarios').innerHTML = '';

            testResults = { hysteresis: [], staleness: [], rateLimit: [], integration: [] };
            currentTest = 0;
            totalTests = 16; // 4 tests per category

            await runHysteresisTests();
            await runStalenesTests();
            await runRateLimitTests();
            await runIntegrationTests();

            log('üéâ Suite compl√®te termin√©e!', 'success');

            // Generate summary
            const totalPassed = Object.values(testResults).flat().filter(r => r.result === 'pass').length;
            const totalTests = Object.values(testResults).flat().length;
            log(`üìä R√©sum√©: ${totalPassed}/${totalTests} tests r√©ussis (${Math.round(totalPassed/totalTests*100)}%)`, 'info');
        }

        function resetAllTests() {
            log('üîÑ Reset de tous les tests', 'warn');

            document.getElementById('hysteresis-scenarios').innerHTML = '';
            document.getElementById('staleness-scenarios').innerHTML = '';
            document.getElementById('rate-limit-scenarios').innerHTML = '';
            document.getElementById('integration-scenarios').innerHTML = '';
            document.getElementById('test-console').innerHTML = '';

            resetStabilityState();
            forceStalenessFrozen(false);

            currentTest = 0;
            totalTests = 0;
            updateProgress();
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // Export for global access
        window.stabilityTests = {
            runFullSuite,
            runHysteresisTests,
            runStalenesTests,
            runRateLimitTests,
            resetAllTests
        };

        // Auto-update rate limit status
        setInterval(updateRateLimitStatus, 1000);

        log('üî¨ Suite de tests initialis√©e', 'info');
        log('üí° Utilisez les boutons ou window.stabilityTests.*', 'info');
    </script>
</body>
</html>