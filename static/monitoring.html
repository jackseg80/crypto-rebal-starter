<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üîç Monitoring - Crypto Rebal</title>
    <link rel="stylesheet" href="shared-theme.css">
    <link rel="stylesheet" href="theme-compat.css">
    <script type="module" src="components/nav.js"></script>
    <script src="global-config.js"></script>
    <style>
        .monitoring-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1.5rem;
            margin: 2rem 0;
        }

        .kpi-card {
            background: var(--theme-surface);
            border: 1px solid var(--theme-border);
            border-radius: var(--radius-lg);
            padding: 1.5rem;
            position: relative;
            overflow: hidden;
        }

        .kpi-header {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 1rem;
        }

        .kpi-icon {
            font-size: 1.5rem;
        }

        .kpi-title {
            font-size: 1rem;
            font-weight: 600;
            color: var(--theme-text);
        }

        .kpi-value {
            font-size: 2.5rem;
            font-weight: 700;
            margin: 1rem 0;
            transition: color 0.3s ease;
        }

        .kpi-details {
            font-size: 0.85rem;
            color: var(--theme-text-muted);
            line-height: 1.4;
        }

        .kpi-trend {
            position: absolute;
            top: 1rem;
            right: 1rem;
            font-size: 1.2rem;
        }

        /* Status Colors */
        .status-healthy { color: var(--success); }
        .status-warning { color: var(--warning); }
        .status-critical { color: var(--danger); }

        .alert-banner {
            display: none;
            background: color-mix(in oklab, var(--danger) 20%, transparent);
            border: 1px solid var(--danger);
            color: var(--theme-text);
            padding: 1rem;
            margin: 1rem 0;
            border-radius: var(--radius-md);
            animation: pulse 2s ease-in-out infinite alternate;
        }

        .alert-banner.show {
            display: block;
        }

        @keyframes pulse {
            from { opacity: 0.8; }
            to { opacity: 1; }
        }

        .last-update {
            text-align: center;
            color: var(--theme-text-muted);
            font-size: 0.8rem;
            margin-top: 2rem;
            padding: 1rem;
            border-top: 1px solid var(--theme-border);
        }

        .refresh-btn {
            background: var(--brand-primary);
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: var(--radius-sm);
            cursor: pointer;
            font-size: 0.85rem;
            margin-left: 1rem;
            transition: background 0.2s ease;
        }

        .refresh-btn:hover {
            background: color-mix(in oklab, var(--brand-primary) 80%, black);
        }

        .refresh-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
    </style>
</head>
<body>
    <div class="wrap">
        <div class="page-header">
            <h1>üîç Monitoring - KPIs Vitaux</h1>
            <button id="refresh-btn" class="refresh-btn" onclick="refreshAllMetrics()">
                üîÑ Refresh
            </button>
        </div>

        <!-- Alert Banner -->
        <div id="alert-banner" class="alert-banner">
            <strong>‚ö†Ô∏è Alerte Syst√®me:</strong> <span id="alert-message"></span>
        </div>

        <!-- KPIs Grid -->
        <div class="monitoring-grid">
            <!-- KPI 1: p95 Latence API -->
            <div class="kpi-card">
                <div class="kpi-header">
                    <div class="kpi-icon">‚ö°</div>
                    <div class="kpi-title">p95 Latence API</div>
                    <div id="latency-trend" class="kpi-trend"></div>
                </div>
                <div id="latency-value" class="kpi-value status-healthy">--</div>
                <div class="kpi-details">
                    <div>Objectif: &lt; 300ms</div>
                    <div>√âchantillons: <span id="latency-samples">0</span></div>
                    <div>Derni√®re mesure: <span id="latency-timestamp">--</span></div>
                </div>
            </div>

            <!-- KPI 2: Taux d'erreur ML -->
            <div class="kpi-card">
                <div class="kpi-header">
                    <div class="kpi-icon">ü§ñ</div>
                    <div class="kpi-title">Taux d'Erreur ML</div>
                    <div id="ml-trend" class="kpi-trend"></div>
                </div>
                <div id="ml-error-value" class="kpi-value status-healthy">--</div>
                <div class="kpi-details">
                    <div>Objectif: &lt; 0.5%</div>
                    <div>Backend Status: <span id="ml-backend-status">--</span></div>
                    <div>Mod√®les Actifs: <span id="ml-active-models">--</span></div>
                </div>
            </div>

            <!-- KPI 3: Staleness -->
            <div class="kpi-card">
                <div class="kpi-header">
                    <div class="kpi-icon">‚è∞</div>
                    <div class="kpi-title">Staleness Donn√©es</div>
                    <div id="stale-trend" class="kpi-trend"></div>
                </div>
                <div id="stale-value" class="kpi-value status-healthy">--</div>
                <div class="kpi-details">
                    <div>üü¢ &lt;10min | üü° 10-30min | üî¥ &gt;30min</div>
                    <div>Derni√®re MAJ: <span id="stale-timestamp">--</span></div>
                    <div>Source: <span id="stale-source">ML Signals</span></div>
                </div>
            </div>

            <!-- KPI 4: VaR Tracking -->
            <div class="kpi-card">
                <div class="kpi-header">
                    <div class="kpi-icon">üìä</div>
                    <div class="kpi-title">VaR95 Tracking</div>
                    <div id="var-trend" class="kpi-trend"></div>
                </div>
                <div id="var-value" class="kpi-value status-healthy">--</div>
                <div class="kpi-details">
                    <div>Seuil critique: &gt; 4%</div>
                    <div>Portfolio VaR: <span id="var-portfolio">--</span></div>
                    <div>Confiance: <span id="var-confidence">95%</span></div>
                </div>
            </div>
        </div>

        <div class="last-update">
            Derni√®re mise √† jour: <span id="global-timestamp">--</span> |
            Auto-refresh: <span id="auto-refresh-status">Actif (30s)</span>
        </div>
    </div>

    <script type="module">
        // Configuration
        const API_BASE = globalConfig?.get('api_base_url') || window.location.origin;
        let refreshInterval;
        let latencyMeasures = [];
        const MAX_SAMPLES = 20;

        // Store pour les donn√©es temps r√©el
        let metricsStore = {
            latency: { value: null, status: 'unknown', trend: null },
            mlError: { value: null, status: 'unknown', trend: null },
            staleness: { value: null, status: 'unknown', trend: null },
            var: { value: null, status: 'unknown', trend: null }
        };

        // KPI 1: p95 Latence API
        async function measureLatency() {
            const start = performance.now();
            try {
                const response = await fetch(`${API_BASE}/health`, {
                    cache: 'no-cache',
                    headers: { 'Cache-Control': 'no-cache' }
                });
                const end = performance.now();
                const latency = end - start;

                // Ajouter √† l'historique
                latencyMeasures.push({ time: Date.now(), value: latency });
                if (latencyMeasures.length > MAX_SAMPLES) {
                    latencyMeasures.shift();
                }

                // Calculer p95
                const sorted = latencyMeasures.map(m => m.value).sort((a, b) => a - b);
                const p95Index = Math.ceil(sorted.length * 0.95) - 1;
                const p95 = sorted[p95Index] || latency;

                // Status
                let status = 'healthy';
                if (p95 > 300) status = 'critical';
                else if (p95 > 200) status = 'warning';

                metricsStore.latency = { value: p95, status, samples: latencyMeasures.length };

                return { p95, status, samples: latencyMeasures.length };
            } catch (error) {
                metricsStore.latency = { value: null, status: 'critical', error: error.message };
                return { error: error.message, status: 'critical' };
            }
        }

        // KPI 2: Taux d'erreur ML
        async function checkMLErrors() {
            try {
                const response = await fetch(`${API_BASE}/execution/governance/signals`);
                if (!response.ok) {
                    metricsStore.mlError = { value: 100, status: 'critical', error: 'API unavailable' };
                    return { error: 'API unavailable', status: 'critical' };
                }

                const data = await response.json();
                const backendStatus = data.signals?.backend_status || 'unknown';
                const isError = ['stale', 'error', 'failed'].includes(backendStatus.toLowerCase());

                // Simuler un taux d'erreur bas√© sur le statut
                const errorRate = isError ? 1.0 : 0.0; // 1% si erreur, 0% sinon

                let status = 'healthy';
                if (errorRate > 0.5) status = 'critical';
                else if (errorRate > 0.2) status = 'warning';

                metricsStore.mlError = {
                    value: errorRate,
                    status,
                    backendStatus,
                    activeModels: data.signals?.active_models || 0
                };

                return { errorRate, status, backendStatus, activeModels: data.signals?.active_models || 0 };
            } catch (error) {
                metricsStore.mlError = { value: null, status: 'critical', error: error.message };
                return { error: error.message, status: 'critical' };
            }
        }

        // KPI 3: Staleness
        async function checkStaleness() {
            try {
                const response = await fetch(`${API_BASE}/execution/governance/signals`);
                if (!response.ok) {
                    metricsStore.staleness = { value: null, status: 'critical', error: 'API unavailable' };
                    return { error: 'API unavailable', status: 'critical' };
                }

                const data = await response.json();
                const lastUpdate = data.signals?.ml_signals_timestamp || data.signals?.timestamp;

                if (!lastUpdate) {
                    metricsStore.staleness = { value: null, status: 'warning', error: 'No timestamp' };
                    return { error: 'No timestamp available', status: 'warning' };
                }

                const now = Date.now();
                const lastUpdateMs = new Date(lastUpdate).getTime();
                const staleMinutes = Math.round((now - lastUpdateMs) / (1000 * 60));

                let status = 'healthy';
                if (staleMinutes > 30) status = 'critical';
                else if (staleMinutes > 10) status = 'warning';

                metricsStore.staleness = {
                    value: staleMinutes,
                    status,
                    timestamp: lastUpdate
                };

                return { staleMinutes, status, timestamp: lastUpdate };
            } catch (error) {
                metricsStore.staleness = { value: null, status: 'critical', error: error.message };
                return { error: error.message, status: 'critical' };
            }
        }

        // KPI 4: VaR Tracking
        async function checkVaR() {
            try {
                const response = await fetch(`${API_BASE}/api/risk/dashboard`);
                if (!response.ok) {
                    metricsStore.var = { value: null, status: 'critical', error: 'Risk API unavailable' };
                    return { error: 'Risk API unavailable', status: 'critical' };
                }

                const data = await response.json();
                const var95 = data.risk_metrics?.var_95 || data.portfolio_summary?.var_95;

                if (var95 == null) {
                    metricsStore.var = { value: null, status: 'warning', error: 'VaR not available' };
                    return { error: 'VaR not available', status: 'warning' };
                }

                const varPercent = Math.abs(var95 * 100); // Convertir en pourcentage positif

                let status = 'healthy';
                if (varPercent > 4) status = 'critical';
                else if (varPercent > 3) status = 'warning';

                metricsStore.var = {
                    value: varPercent,
                    status,
                    portfolioVar: var95
                };

                return { varPercent, status, portfolioVar: var95 };
            } catch (error) {
                metricsStore.var = { value: null, status: 'critical', error: error.message };
                return { error: error.message, status: 'critical' };
            }
        }

        // Mise √† jour de l'affichage
        function updateDisplay() {
            const now = new Date();

            // KPI 1: Latence
            const latencyEl = document.getElementById('latency-value');
            const latencyData = metricsStore.latency;
            if (latencyData.value !== null) {
                latencyEl.textContent = `${Math.round(latencyData.value)}ms`;
                latencyEl.className = `kpi-value status-${latencyData.status}`;
                document.getElementById('latency-samples').textContent = latencyData.samples || 0;
                document.getElementById('latency-timestamp').textContent = now.toLocaleTimeString('fr-FR');
            } else {
                latencyEl.textContent = latencyData.error || '--';
                latencyEl.className = `kpi-value status-${latencyData.status}`;
            }

            // KPI 2: ML Erreurs
            const mlEl = document.getElementById('ml-error-value');
            const mlData = metricsStore.mlError;
            if (mlData.value !== null) {
                mlEl.textContent = `${mlData.value.toFixed(1)}%`;
                mlEl.className = `kpi-value status-${mlData.status}`;
                document.getElementById('ml-backend-status').textContent = mlData.backendStatus || '--';
                document.getElementById('ml-active-models').textContent = mlData.activeModels || '--';
            } else {
                mlEl.textContent = mlData.error || '--';
                mlEl.className = `kpi-value status-${mlData.status}`;
            }

            // KPI 3: Staleness
            const staleEl = document.getElementById('stale-value');
            const staleData = metricsStore.staleness;
            if (staleData.value !== null) {
                staleEl.textContent = `${staleData.value}min`;
                staleEl.className = `kpi-value status-${staleData.status}`;
                const timestamp = staleData.timestamp ? new Date(staleData.timestamp).toLocaleTimeString('fr-FR') : '--';
                document.getElementById('stale-timestamp').textContent = timestamp;
            } else {
                staleEl.textContent = staleData.error || '--';
                staleEl.className = `kpi-value status-${staleData.status}`;
            }

            // KPI 4: VaR
            const varEl = document.getElementById('var-value');
            const varData = metricsStore.var;
            if (varData.value !== null) {
                varEl.textContent = `${varData.value.toFixed(2)}%`;
                varEl.className = `kpi-value status-${varData.status}`;
                document.getElementById('var-portfolio').textContent = varData.portfolioVar?.toFixed(3) || '--';
            } else {
                varEl.textContent = varData.error || '--';
                varEl.className = `kpi-value status-${varData.status}`;
            }

            // Alertes
            const criticalAlerts = [];
            if (metricsStore.staleness.status === 'critical' && metricsStore.staleness.value > 30) {
                criticalAlerts.push(`Donn√©es stales depuis ${metricsStore.staleness.value}min`);
            }
            if (metricsStore.var.status === 'critical' && metricsStore.var.value > 4) {
                criticalAlerts.push(`VaR95 critique: ${metricsStore.var.value.toFixed(2)}%`);
            }

            const alertBanner = document.getElementById('alert-banner');
            if (criticalAlerts.length > 0) {
                document.getElementById('alert-message').textContent = criticalAlerts.join(' | ');
                alertBanner.classList.add('show');
            } else {
                alertBanner.classList.remove('show');
            }

            // Timestamp global
            document.getElementById('global-timestamp').textContent = now.toLocaleTimeString('fr-FR');
        }

        // Refresh de toutes les m√©triques
        async function refreshAllMetrics() {
            const refreshBtn = document.getElementById('refresh-btn');
            refreshBtn.disabled = true;
            refreshBtn.textContent = '‚è≥ Refresh...';

            try {
                await Promise.all([
                    measureLatency(),
                    checkMLErrors(),
                    checkStaleness(),
                    checkVaR()
                ]);

                updateDisplay();
            } catch (error) {
                console.error('Refresh failed:', error);
            } finally {
                refreshBtn.disabled = false;
                refreshBtn.textContent = 'üîÑ Refresh';
            }
        }

        // Export global
        window.refreshAllMetrics = refreshAllMetrics;

        // Initialisation
        document.addEventListener('DOMContentLoaded', () => {
            refreshAllMetrics();

            // Auto-refresh toutes les 30 secondes
            refreshInterval = setInterval(refreshAllMetrics, 30000);
        });

        // Cleanup
        window.addEventListener('beforeunload', () => {
            if (refreshInterval) clearInterval(refreshInterval);
        });
    </script>
</body>
</html>