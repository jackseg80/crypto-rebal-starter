<!DOCTYPE html>
<html>
<head>
    <title>Debug Allocation V2</title>
</head>
<body>
    <h1>Debugging Allocation Engine V2</h1>
    <pre id="output"></pre>

    <script type="module">
        import { calculateHierarchicalAllocation } from './core/allocation-engine.js';

        const output = document.getElementById('output');

        function log(message) {
            output.textContent += message + '\n';
            console.log(message);
        }

        async function runTest() {
            log('üß™ Starting allocation engine debug test...');

            const context = {
                cycleScore: 100,  // Bullish phase
                onchainScore: 36,
                riskScore: 47,
                contradiction: 0.48,
                risk_budget: { target_stables_pct: 41 },
                execution: { cap_pct_per_iter: 7 }
            };

            const mockPositions = [
                { symbol: 'BTC', value_usd: 1000 },
                { symbol: 'ETH', value_usd: 800 },
                { symbol: 'SOL', value_usd: 300 },
                { symbol: 'USDC', value_usd: 1500 },
                { symbol: 'LINK', value_usd: 200 }
            ];

            log('\nüìä Test Context:');
            log(`Cycle Score: ${context.cycleScore} (should trigger bullish phase)`);
            log(`Mock Positions: ${mockPositions.map(p => `${p.symbol}=$${p.value_usd}`).join(', ')}`);

            try {
                const result = await calculateHierarchicalAllocation(context, mockPositions, { enableV2: true });

                log('\n‚úÖ Allocation Result:');
                if (result) {
                    log(`Version: ${result.version}`);
                    log(`Phase: ${result.metadata.phase}`);
                    log(`Total check: ${JSON.stringify(result.metadata.total_check)}`);

                    log('\nüìã Final Allocation:');
                    Object.entries(result.allocation).forEach(([asset, weight]) => {
                        const pct = (weight * 100).toFixed(2);
                        log(`  ${asset}: ${pct}% ${isNaN(weight) ? '‚ö†Ô∏è NaN!' : ''}`);
                    });

                    // Check SOL floor specifically
                    const solAlloc = result.allocation.SOL || 0;
                    log(`\nüîç SOL Floor Check:`);
                    log(`  SOL allocation: ${(solAlloc * 100).toFixed(2)}%`);
                    log(`  Expected floor (bullish): ‚â•6%`);
                    log(`  Floor applied: ${solAlloc >= 0.06 ? '‚úÖ YES' : '‚ùå NO'}`);

                    // Check for NaN values
                    const nanAssets = Object.entries(result.allocation).filter(([, weight]) => isNaN(weight));
                    if (nanAssets.length > 0) {
                        log(`\n‚ùå NaN Values Found:`);
                        nanAssets.forEach(([asset]) => log(`  ${asset}: NaN`));
                    } else {
                        log(`\n‚úÖ No NaN values found`);
                    }

                } else {
                    log('‚ùå Allocation engine returned null');
                }

            } catch (error) {
                log(`‚ùå Error: ${error.message}`);
                log(`Stack: ${error.stack}`);
            }
        }

        // Run test when page loads
        runTest();
    </script>
</body>
</html>