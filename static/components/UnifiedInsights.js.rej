diff a/static/components/UnifiedInsights.js b/static/components/UnifiedInsights.js	(rejected hunks)
@@ -333,6 +333,8 @@ export async function renderUnifiedInsights(containerId = 'unified-root') {
             // Utiliser la mÃªme logique de cap que les badges (avec sÃ©curitÃ© stale)
             // Note: Import dynamique ne peut pas Ãªtre await ici, fallback sur policy direct
             const cap = policy && typeof policy.cap_daily === 'number' ? Math.round(policy.cap_daily * 100) : null;
+            const capDailyPct = policy && typeof policy.cap_daily === 'number' ? policy.cap_daily * 100 : null;
+            const isTightCap = policy && (policy.mode === 'Freeze' || (typeof policy.cap_daily === 'number' && policy.cap_daily <= 0.02));
             const source = u.decision_source || 'SMART';
             const backendStatus = store.get('ui.apiStatus.backend');
 
@@ -342,6 +344,10 @@ export async function renderUnifiedInsights(containerId = 'unified-root') {
             if (hh) badges.push(`Updated ${hh}`);
             if (ci != null) badges.push(`Contrad ${ci}%`);
             if (cap != null) badges.push(`Cap ${cap}%`);
+            if (isTightCap) {
+              const tightLabel = capDailyPct != null ? ` (Â±${Math.round(capDailyPct)}%)` : '';
+              badges.push(`ðŸ§Š Freeze/Cap serrÃ©${tightLabel}`);
+            }
 
             // NOUVEAU: Phase Engine status
             const phaseEngineMode = localStorage.getItem('PHASE_ENGINE_ENABLED') || 'shadow';
@@ -808,7 +814,20 @@ export async function renderUnifiedInsights(containerId = 'unified-root') {
       const riskBudget = u.risk_budget || {};
       const execution = u.execution || {};
       const stablesTheorique = riskBudget.target_stables_pct || null;
-      const estimatedIters = execution.estimated_iters_to_target || 'N/A';
+      let estimatedIters = execution.estimated_iters_to_target || 'N/A';
+      if (visible.length > 0 && typeof mode.cap === 'number') {
+        if (mode.cap <= 0) {
+          estimatedIters = 'âˆž';
+        } else {
+          const maxDelta = visible.reduce((max, entry) => {
+            const current = typeof entry.cur === 'number' ? entry.cur : 0;
+            const target = typeof entry.tgt === 'number' ? entry.tgt : 0;
+            const diff = Math.abs(target - current);
+            return diff > max ? diff : max;
+          }, 0);
+          estimatedIters = maxDelta > 0 ? Math.max(1, Math.ceil(maxDelta / mode.cap)) : 0;
+        }
+      }
 
       // TÃ‚CHE 4 - Verrous anti-rÃ©gression (dev uniquement) avant rendu
       if (typeof window !== 'undefined' && window.location?.hostname === 'localhost') {
