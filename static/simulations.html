<!DOCTYPE html>
<html lang="fr">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Simulateur de Rebalancing - Crypto Rebalancer</title>
  <link rel="stylesheet" href="shared-theme.css">
  <link rel="stylesheet" href="theme-compat.css">
  <script src="debug-logger.js"></script>
  <script src="global-config.js"></script>
  <script src="appearance.js"></script>
  <script type="module" src="components/nav.js"></script>
  <script type="module">
    import { initDeepLinks } from './components/deep-links.js';
    // Ancres pour simulations.html : #controls #results #inspector
    initDeepLinks({
      'controls': 'Contrôles',
      'results': 'Résultats',
      'inspector': 'Inspecteur'
    });
  </script>
  <style>
    :root {
      --sim-controls-width: 400px;
    }

    .wrap {
      max-width: min(1400px, 96vw);
      margin: 0 auto;
      padding: var(--space-lg);
    }
    .sim-layout {
      display: grid;
      grid-template-columns: minmax(0, 1.65fr) minmax(0, 1.35fr);
      gap: var(--space-lg);
      align-items: start;
    }

    .sim-panel {
      background: var(--theme-surface);
      border: 1px solid var(--theme-border);
      border-radius: var(--radius-lg);
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    .controls-flyout {
      position: fixed;
      top: 120px;
      left: 0;
      width: min(var(--sim-controls-width, 400px), 92vw);
      max-height: calc(100vh - 140px);
      padding: var(--space-lg);
      background: color-mix(in srgb, var(--theme-surface) 88%, transparent 12%);
      border: 1px solid color-mix(in srgb, var(--theme-border) 45%, transparent);
      border-radius: 0 var(--radius-xl) var(--radius-xl) 0;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.25);
      backdrop-filter: blur(10px);
      display: flex;
      flex-direction: column;
      gap: var(--space-md);
      transform: translateX(calc(-100% + 48px));
      transition: transform 0.25s ease, opacity 0.25s ease;
      opacity: 0.5;
      z-index: 25;
    }

    .controls-flyout:hover,
    .controls-flyout:focus-within,
    .controls-flyout.is-pinned {
      transform: translateX(0);
      opacity: 1;
    }

    .controls-flyout:is(:hover, :focus-within) .flyout-handle,
    .controls-flyout.is-pinned .flyout-handle {
      opacity: 0;
    }

    .controls-flyout .flyout-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: var(--space-md);
    }

    .controls-flyout h2 {
      margin: 0;
      font-size: 1.1rem;
    }

    .controls-flyout .flyout-actions {
      display: flex;
      gap: var(--space-xs);
    }

    .controls-flyout .pin-btn {
      font-size: 0.85rem;
      padding: 0.35rem 0.75rem;
      transition: background 0.2s ease, color 0.2s ease, border-color 0.2s ease;
    }

    .controls-flyout .pin-btn[aria-pressed="true"] {
      background: var(--brand-primary);
      color: white;
      border-color: var(--brand-primary);
    }

    .controls-flyout .flyout-content {
      overflow-y: auto;
      padding-right: var(--space-sm);
      margin-right: calc(-1 * var(--space-sm));
      max-height: calc(100% - 2.5rem);
    }

    .controls-flyout .flyout-content::-webkit-scrollbar {
      width: 6px;
    }

    .controls-flyout .flyout-content::-webkit-scrollbar-thumb {
      background: color-mix(in srgb, var(--brand-primary) 55%, transparent);
      border-radius: 999px;
    }

    .flyout-handle {
      position: absolute;
      right: -48px;
      top: 50%;
      transform: translateY(-50%);
      background: var(--brand-primary);
      color: white;
      padding: var(--space-sm) var(--space-xs);
      border-radius: 0 var(--radius-lg) var(--radius-lg) 0;
      font-size: 0.75rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      writing-mode: vertical-rl;
      text-orientation: mixed;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
      pointer-events: none;
      opacity: 0.85;
      transition: opacity 0.2s ease;
    }

    .controls-flyout:hover .flyout-handle,
    .controls-flyout:focus-within .flyout-handle {
      opacity: 0;
    }

    .sim-panel-inspector .results-content {
      max-height: none;
      overflow-y: auto;
    }

    .sim-panel-inspector {
      min-height: 100%;
    }
    .sim-panel-inspector .results-content {
      max-height: none;
      overflow-y: auto;
    }

    .sim-panel-inspector {
      min-height: 100%;
    }

    .sim-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: var(--space-lg) var(--space-lg) var(--space-md) var(--space-lg);
      border-bottom: 1px solid var(--theme-border);
      background: var(--theme-bg);
    }

    .source-controls {
      display: flex;
      gap: var(--space-sm);
      align-items: center;
    }

    .mode-toggle {
      display: flex;
      background: var(--theme-bg);
      border: 1px solid var(--theme-border);
      border-radius: var(--radius-sm);
      overflow: hidden;
    }

    .mode-toggle button {
      padding: 0.5rem 1rem;
      border: none;
      background: transparent;
      color: var(--theme-text-muted);
      cursor: pointer;
      transition: all 0.2s;
    }

    .mode-toggle button.active {
      background: var(--brand-primary);
      color: white;
    }

    .mode-toggle button:hover:not(.active) {
      background: var(--theme-surface);
      color: var(--theme-text);
    }

    .results-content {
      padding: var(--space-lg);
      flex: 1;
      overflow-y: auto;
    }

    .results-grid {
      display: grid;
      gap: var(--space-lg);
    }

    .result-card {
      background: var(--theme-bg);
      border: 1px solid var(--theme-border);
      border-radius: var(--radius-md);
      padding: var(--space-md);
    }

    .result-card h4 {
      margin: 0 0 var(--space-sm) 0;
      color: var(--theme-text);
      font-size: 1rem;
      font-weight: 600;
    }

    .di-gauge {
      text-align: center;
      padding: var(--space-lg);
    }

    .di-value {
      font-size: 3rem;
      font-weight: 800;
      color: var(--brand-primary);
      margin: var(--space-sm) 0;
    }

    .di-source {
      display: inline-block;
      padding: 0.3rem 0.6rem;
      background: var(--theme-surface);
      border: 1px solid var(--theme-border);
      border-radius: var(--radius-sm);
      font-size: 0.8rem;
      color: var(--theme-text-muted);
      font-weight: 500;
    }

    .di-preset {
      margin-top: var(--space-sm);
      font-size: 0.85rem;
      color: var(--theme-text-muted);
    }

    .budget-bars {
      display: flex;
      gap: var(--space-md);
      margin: var(--space-md) 0;
    }

    .budget-bar {
      flex: 1;
      text-align: center;
    }

    .budget-bar-fill {
      height: 80px;
      border-radius: var(--radius-sm);
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-weight: 600;
      margin-bottom: var(--space-xs);
    }

    .stables-bar {
      background: linear-gradient(135deg, #10b981, #059669);
    }

    .risky-bar {
      background: linear-gradient(135deg, #f59e0b, #d97706);
    }

    .allocation-chart {
      min-height: 200px;
      background: var(--theme-surface);
      border-radius: var(--radius-sm);
      padding: var(--space-md);
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--theme-text-muted);
    }

    .orders-list {
      max-height: 200px;
      overflow-y: auto;
    }

    .order-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: var(--space-sm);
      border-bottom: 1px solid var(--theme-border);
    }

    .order-item:last-child {
      border-bottom: none;
    }

    .order-action {
      font-weight: 600;
    }

    .order-action.buy {
      color: var(--success);
    }

    .order-action.sell {
      color: var(--danger);
    }

    .loading-spinner {
      display: none;
      text-align: center;
      padding: var(--space-xl);
      color: var(--theme-text-muted);
    }

    .loading-spinner.active {
      display: block;
    }

    .spinner {
      display: inline-block;
      width: 2rem;
      height: 2rem;
      border: 3px solid var(--theme-border);
      border-radius: 50%;
      border-top-color: var(--brand-primary);
      animation: spin 1s ease-in-out infinite;
      margin-bottom: var(--space-sm);
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }

    .error-state {
      display: none;
      text-align: center;
      padding: var(--space-xl);
      color: var(--danger);
    }

    .error-state.active {
      display: block;
    }

    .empty-state {
      text-align: center;
      padding: var(--space-xl) var(--space-md);
      color: var(--theme-text-muted);
    }

    .empty-icon {
      font-size: 3rem;
      margin-bottom: var(--space-md);
    }

    /* Responsive */
    @media (max-width: 1200px) {
      .sim-layout {
        grid-template-columns: minmax(0, 1.4fr) minmax(0, 1.1fr);
        gap: var(--space-md);
      }

      .controls-flyout {
        width: min(360px, 85vw);
      }
    }

    @media (max-width: 1024px) {
      .controls-flyout {
        position: static;
        transform: none;
        opacity: 1;
        width: 100%;
        max-height: none;
        border-radius: var(--radius-lg);
        box-shadow: none;
        backdrop-filter: none;
        margin-bottom: var(--space-lg);
      }

      .controls-flyout .flyout-handle {
        display: none;
      }

      .controls-flyout .flyout-content {
        margin-right: 0;
        padding-right: 0;
      }
    }

    @media (max-width: 968px) {
      .sim-layout {
        grid-template-columns: 1fr;
        grid-template-rows: auto auto;
        gap: var(--space-lg);
      }

      .wrap {
        padding: var(--space-md);
      }
    }

    @media (max-width: 640px) {
      .sim-header {
        flex-direction: column;
        gap: var(--space-md);
        align-items: stretch;
      }

      .source-controls {
        flex-direction: column;
        gap: var(--space-sm);
      }

      .budget-bars {
        flex-direction: column;
      }
    }

    /* Styles pour les barres de progression */
    .progress-bar {
      width: 100%;
      height: 8px;
      background: var(--theme-border);
      border-radius: 4px;
      overflow: hidden;
      margin: var(--space-xs) 0;
    }

    .progress-fill {
      height: 100%;
      background: var(--brand-primary);
      border-radius: 4px;
      transition: width 0.3s ease;
    }

    /* Animation d'entrée */
    .result-card {
      animation: slideInUp 0.3s ease-out;
    }

    @keyframes slideInUp {
      from {
        opacity: 0;
        transform: translateY(20px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    /* Statut badges */
    .status-badge {
      display: inline-block;
      padding: 0.25rem 0.5rem;
      border-radius: var(--radius-sm);
      font-size: 0.75rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .status-badge.success {
      background: color-mix(in oklab, var(--success) 20%, transparent);
      color: var(--success);
      border: 1px solid var(--success);
    }

    .status-badge.warning {
      background: color-mix(in oklab, var(--warning) 20%, transparent);
      color: var(--warning);
      border: 1px solid var(--warning);
    }

    .status-badge.danger {
      background: color-mix(in oklab, var(--danger) 20%, transparent);
      color: var(--danger);
      border: 1px solid var(--danger);
    }

    .status-badge.info {
      background: color-mix(in oklab, var(--brand-primary) 20%, transparent);
      color: var(--brand-primary);
      border: 1px solid var(--brand-primary);
    }
  </style>
</head>

<body>
  <div class="wrap">
    <!-- En-tête principal -->
    <div class="sim-header">
      <div>
        <h1>🎭 Simulateur de Rebalancing</h1>
        <p style="color: var(--theme-text-muted); margin: 0;">
          Testez le pipeline complet en temps réel sans écriture backend
        </p>
      </div>

      <div class="source-controls">
        <div class="mode-toggle">
          <button id="mode-live" class="active">📊 Live</button>
          <button id="mode-simulation">🎭 Simulation</button>
        </div>

        <div style="display: flex; align-items: center; gap: 8px;">
          <label for="sim-source-select" style="font-size: 0.9rem; color: var(--theme-text-muted);">Source:</label>
          <select id="sim-source-select" style="padding: 6px 10px; border-radius: 6px; border: 1px solid var(--theme-border); background: var(--theme-surface); color: var(--theme-text); font-size: 0.9rem;">
            <option value="">Charger...</option>
          </select>
          <button id="test-source-btn" class="btn secondary" style="padding: 6px 12px; font-size: 0.85rem;">🧪 Test</button>
        </div>

        <div style="display: flex; align-items: center; gap: 8px; margin-top: 8px;">
          <label for="cycle-preset-select" style="font-size: 0.9rem; color: var(--theme-text-muted);">🎭 Scénario:</label>
          <select id="cycle-preset-select" style="padding: 6px 10px; border-radius: 6px; border: 1px solid var(--theme-border); background: var(--theme-surface); color: var(--theme-text); font-size: 0.9rem; flex: 1;">
            <option value="">Charger les presets...</option>
          </select>
          <button id="apply-preset-btn" class="btn primary" style="padding: 6px 12px; font-size: 0.85rem;">▶️ Appliquer</button>
        </div>
      </div>
    </div>

    <!-- Contrôles flottants -->
    <div id="controls" class="controls-flyout" role="complementary" aria-label="Contrôles de simulation" tabindex="-1">
      <div class="flyout-handle">🎛️ Contrôles</div>
      <div class="flyout-header">
        <h2>🎛️ Contrôles</h2>
        <div class="flyout-actions">
          <button id="controls-pin-btn" class="btn secondary pin-btn" type="button" aria-pressed="false" title="Épingler le panneau">
            📌 Épingler
          </button>
        </div>
      </div>
      <div class="flyout-content">
        <div id="sim-controls" class="controls-content">
          <!-- Contrôles générés par SimControls.js -->
        </div>
      </div>
    </div>

    <!-- Disposition principale -->
    <div class="sim-layout">
      <!-- Résultats -->
      <div id="results" class="sim-panel">
        <div class="sim-header">
          <h3>📊 Résultats de Simulation</h3>
          <div style="display: flex; align-items: center; gap: var(--space-md);">
            <div id="simulation-status">
              <span class="status-badge info">Prêt</span>
            </div>
            <div id="badges-sim"></div>
          </div>
        </div>
        <div class="results-content">
          <!-- États -->
          <div id="loading-state" class="loading-spinner">
            <div class="spinner"></div>
            <p>Simulation en cours...</p>
          </div>

          <div id="error-state" class="error-state">
            <div style="font-size: 2rem;">⚠️</div>
            <h4>Erreur de Simulation</h4>
            <p id="error-message">Une erreur s'est produite</p>
            <button id="retry-btn" class="btn secondary">🔄 Réessayer</button>
          </div>

          <div id="empty-state" class="empty-state">
            <div class="empty-icon">🎭</div>
            <h4>Simulateur Prêt</h4>
            <p>Ajustez les contrôles pour lancer la simulation</p>
          </div>

          <!-- Résultats -->
          <div id="results-grid" class="results-grid" style="display: none;">
            <!-- Decision Index -->
            <div class="result-card">
              <h4>🎯 Decision Index</h4>
              <div class="di-gauge">
                <div id="sim-di-gauge" class="di-value">--</div>
                <div id="sim-di-source-badge" class="di-source">Source: --</div>
                <div style="margin-top: var(--space-sm); font-size: 0.9rem; color: var(--theme-text-muted);">
                  Confiance: <span id="sim-di-confidence">--</span>%
                </div>
                <div id="sim-selected-preset" class="di-preset">Preset: Custom</div>
              </div>
            </div>

            <!-- Risk Budget -->
            <div class="result-card">
              <h4>💰 Risk Budget</h4>
              <div class="budget-bars">
                <div class="budget-bar">
                  <div id="sim-stables-bar" class="budget-bar-fill stables-bar">
                    <span id="sim-stables-pct">--%</span>
                  </div>
                  <div style="font-size: 0.9rem; color: var(--theme-text-muted);">Stables</div>
                </div>
                <div class="budget-bar">
                  <div id="sim-risky-bar" class="budget-bar-fill risky-bar">
                    <span id="sim-risky-pct">--%</span>
                  </div>
                  <div style="font-size: 0.9rem; color: var(--theme-text-muted);">Risky</div>
                </div>
              </div>
              <div style="text-align: center; font-size: 0.8rem; color: var(--theme-text-muted);">
                Courbe: <span id="sim-risk-curve">--</span> |
                Clamps: <span id="sim-risk-clamps">--</span>
              </div>
            </div>

            <!-- Allocation Targets -->
            <div class="result-card">
              <h4>🎯 Allocation par Groupes</h4>
              <div id="sim-allocation-chart" class="allocation-chart">
                Chargement de l'allocation...
              </div>
            </div>

            <!-- Plan d'Exécution -->
            <div class="result-card">
              <h4>⚡ Plan d'Exécution</h4>
              <div style="margin-bottom: var(--space-md);">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: var(--space-sm);">
                  <span>Delta Total:</span>
                  <span id="sim-total-delta" style="font-family: monospace; font-weight: 600;">--%</span>
                </div>
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: var(--space-sm);">
                  <span>Seuil:</span>
                  <span id="sim-exec-threshold" style="font-family: monospace;">--%</span>
                </div>
                <div style="display: flex; justify-content: space-between; align-items: center;">
                  <span>Statut:</span>
                  <span id="sim-exec-status" class="status-badge">--</span>
                </div>
              </div>
              <div id="sim-orders-list" class="orders-list">
                <!-- Ordres générés dynamiquement -->
              </div>
            </div>

            <!-- Résumé NL -->
            <div class="result-card">
              <h4>📝 Résumé</h4>
              <div id="sim-summary-nl" style="line-height: 1.6; color: var(--theme-text);">
                Résumé en langage naturel...
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Inspecteur -->
      <div id="inspector" class="sim-panel sim-panel-inspector">
        <div class="sim-header">
          <h3>🔍 Inspecteur</h3>
        </div>
        <div id="sim-inspector" class="results-content">
          <!-- Inspecteur généré par SimInspector.js -->
        </div>
      </div>
    </div>

  </div>

  <!-- Scripts -->
  <script type="module">
    import { SimControls } from './components/SimControls.js';
    import { SimInspector } from './components/SimInspector.js';
    import * as SimEngine from './modules/simulation-engine.js';

    // Sélecteurs & policy
    import { selectContradictionPct, selectContradiction01, selectCapPercent } from './selectors/governance.js';
    import { classifyContradiction } from './governance/contradiction-policy.js';

    // Badges UI
    import { renderBadges } from './components/Badges.js';

    // CSV parsing functions (from dashboard.html)
    function parseCSVBalancesAuto(csvText, { thresholdUSD = 1.0 } = {}) {
      if (typeof window.parseCSVBalances === 'function') {
        return window.parseCSVBalances(csvText);
      }
      return parseCSVBalancesLocal(csvText, { thresholdUSD });
    }

    function parseCSVBalancesLocal(csvText, { thresholdUSD = 1.0 } = {}) {
      const cleanedText = csvText.replace(/^\ufeff/, '');
      const lines = cleanedText.split(/\r?\n/);
      const balances = [];
      const minThreshold = (window.globalConfig && window.globalConfig.get('min_usd_threshold')) || thresholdUSD || 1.0;

      for (let i = 1; i < lines.length; i++) {
        const line = lines[i].trim();
        if (!line) continue;

        try {
          const columns = parseCSVLineLocal(line);
          if (columns.length >= 5) {
            const ticker = columns[0];
            const norm = s => parseFloat(String(s).replace(/[,\u00A0]/g, ''));
            const amount = norm(columns[3]);
            const valueUSD = norm(columns[4]);

            if (ticker && !isNaN(amount) && !isNaN(valueUSD) && valueUSD >= minThreshold) {
              balances.push({
                symbol: ticker.toUpperCase(),
                balance: amount,
                value_usd: valueUSD
              });
            }
          }
        } catch (error) {
          console.warn('Erreur parsing ligne CSV:', error.message);
        }
      }

      return balances;
    }

    function parseCSVLineLocal(line) {
      const cols = [];
      let current = '';
      let inQuotes = false;

      for (let i = 0; i < line.length; i++) {
        const char = line[i];
        if (char === '"') {
          inQuotes = !inQuotes;
        } else if (char === ',' && !inQuotes) {
          cols.push(current.trim());
          current = '';
        } else {
          current += char;
        }
      }
      cols.push(current.trim());
      return cols;
    }

    // Fallback functions for missing modules
    function smoothContradiction(value, prevValue, config, state) {
      return { value01: value, level: 'medium', persistCount: 0 };
    }

    function getEffectiveContradiction01(opts) {
      return {
        value01: opts.state?.governance?.contradiction_index ?? 0.5,
        stale: false,
        useBaseWeights: false
      };
    }

    function calculateAdaptiveWeights(base, state) {
      return base;
    }

    function applyContradictionCaps(policy, state) {
      return policy;
    }

    // État local de smoothing (persistance) + config par défaut
    let smoothState = { prevLevel: undefined, prevValue: undefined, persistCount: 0 };
    const SMOOTHING_CFG = { ema_alpha: 0.25, deadband: 2, persistence: 3 }; // deadband en %
    const STALE_TTL_MIN = 30;

    // État global de l'application
    let appState = {
      mode: 'live', // 'live' ou 'simulation'
      sourceId: null, // Sera initialisé depuis globalConfig
      controls: null,
      inspector: null,
      lastSimulation: null,
      isRunning: false
    };

    // Fonction pour récupérer la source active depuis globalConfig
    function getActiveSource() {
      return window.globalConfig?.get('data_source') || 'stub_balanced';
    }

    // Debounce pour éviter d'inonder le moteur
    let controlsUpdateTimeout = null;

    // Charger les sources disponibles depuis l'API
    async function loadAvailableSources() {
      try {
        const apiBase = window.globalConfig?.get('api_base_url') || window.location.origin;
        const response = await fetch(`${apiBase}/api/users/sources`);

        if (!response.ok) {
          console.warn('Failed to load sources');
          return;
        }

        const data = await response.json();
        const select = document.getElementById('sim-source-select');

        if (!select) return;

        // Peupler le select
        select.innerHTML = '';
        (data.sources || []).forEach(source => {
          const option = document.createElement('option');
          option.value = source.key;
          option.textContent = source.label;
          select.appendChild(option);
        });

        // Sélectionner la source active
        const activeSource = getActiveSource();
        select.value = activeSource;

        console.log('🎭 SIM: Loaded sources:', data.sources?.length || 0, '| Active:', activeSource);
      } catch (error) {
        console.error('Failed to load sources:', error);
      }
    }

    // Tester la source sélectionnée
    async function testSelectedSource() {
      const select = document.getElementById('sim-source-select');
      const source = select?.value || getActiveSource();
      const userId = localStorage.getItem('activeUser') || 'demo';

      console.log(`🧪 Testing source: ${source} for user: ${userId}`);

      try {
        // ✅ USE UNIFIED loadBalanceData() which handles user_id correctly via X-User header
        // Temporarily set data_source to test the selected source
        const originalSource = window.globalConfig.get('data_source');
        window.globalConfig.set('data_source', source);

        const balanceResult = await window.loadBalanceData(true); // forceRefresh=true

        // Restore original source
        window.globalConfig.set('data_source', originalSource);

        if (!balanceResult || !balanceResult.success) {
          throw new Error('Failed to load balance data');
        }

        console.log('🧪 Balance result:', balanceResult);

        // Parse balances (same logic as dashboard.html)
        let balances;
        if (balanceResult.csvText) {
          // CSV source
          const minThreshold = (window.globalConfig && window.globalConfig.get('min_usd_threshold')) || 1.0;
          balances = parseCSVBalancesAuto(balanceResult.csvText, { thresholdUSD: minThreshold });
        } else if (balanceResult.data && Array.isArray(balanceResult.data.items)) {
          // API source
          balances = balanceResult.data.items;
        } else {
          throw new Error('Invalid data format');
        }

        const sourceUsed = balanceResult.source || source;

        if (balances.length > 0) {
          const totalValue = balances.reduce((sum, item) => {
            return sum + (item.value_usd || item.valueUsd || item.total_usd || 0);
          }, 0);

          alert(`✅ Source "${sourceUsed}" OK\n\n` +
                `${balances.length} assets trouvés\n` +
                `Valeur totale: $${totalValue.toFixed(2)}\n` +
                `User: ${userId}`);
        } else {
          alert(`⚠️ Source "${sourceUsed}" accessible mais vide\n\n` +
                `Aucun asset trouvé.\n` +
                `Vérifiez que la source contient des données pour l'utilisateur ${userId}.`);
        }
      } catch (error) {
        console.error('🧪 Test source failed:', error);
        alert(`❌ Erreur test source "${source}":\n${error.message}`);
      }
    }

    // Charger les presets de phases de cycle
    let cyclePresets = null;
    async function loadCyclePresets() {
      try {
        const response = await fetch('/static/presets/cycle_phase_presets.json');
        const data = await response.json();
        cyclePresets = data;

        const select = document.getElementById('cycle-preset-select');
        if (!select) return;

        // Vider et repeupler
        select.innerHTML = '<option value="">💼 Données Actuelles (baseline)</option>';

        data.presets.forEach(preset => {
          if (preset.id !== 'current') { // Skip "current" car c'est le défaut
            const option = document.createElement('option');
            option.value = preset.id;
            option.textContent = preset.name;
            option.title = preset.description;
            select.appendChild(option);
          }
        });

        console.log(`🎭 SIM: Loaded ${data.presets.length} cycle presets`);
      } catch (error) {
        console.error('🎭 SIM: Failed to load cycle presets:', error);
      }
    }

    // Appliquer un preset de phase
    async function applyPreset() {
      const select = document.getElementById('cycle-preset-select');
      const presetId = select?.value;

      if (!presetId) {
        // Pas de preset sélectionné = mode Live normal
        await loadLiveData();
        return;
      }

      if (!cyclePresets) {
        alert('❌ Les presets ne sont pas chargés');
        return;
      }

      const preset = cyclePresets.presets.find(p => p.id === presetId);
      if (!preset) {
        alert(`❌ Preset "${presetId}" introuvable`);
        return;
      }

      console.log(`🎭 SIM: Applying preset "${preset.name}"`, preset.overrides);

      // TODO: Implémenter l'application du preset avec overrides
      // Pour l'instant, afficher un aperçu
      alert(`🎭 Preset "${preset.name}"\n\n` +
            `${preset.description}\n\n` +
            `Overrides:\n` +
            `• Cycle Score: ${preset.overrides.cycle_score}\n` +
            `• Onchain Score: ${preset.overrides.onchain_score}\n` +
            `• Risk Score: ${preset.overrides.risk_score}\n` +
            `• Contradiction: ${preset.overrides.contradiction_pct}%\n` +
            `• Risk Appetite: ${preset.overrides.risk_appetite}\n\n` +
            `Résultats attendus:\n` +
            `• DI: ${preset.expected.di_range}\n` +
            `• Stables: ${preset.expected.stables_target}\n\n` +
            `⚠️ Implémentation complète à venir...`);
    }

    // Initialisation
    document.addEventListener('DOMContentLoaded', async () => {
      console.log('🎭 SIM: Simulator page initialized');

      try {
        await loadAvailableSources();
        await loadCyclePresets(); // Charger les presets
        await initializeSimulator();
        attachEventListeners();
        setInitialState();
      } catch (error) {
        console.error('🎭 SIM: Initialization failed:', error);
        showError('Échec de l\'initialisation du simulateur: ' + error.message);
      }
    });

    async function initializeSimulator() {
      // Initialiser les composants
      appState.controls = new SimControls('sim-controls', onControlsUpdate);
      appState.inspector = new SimInspector('sim-inspector');

      // Initialiser le moteur de simulation
      const initResult = await SimEngine.initSimulation({ sourceId: appState.sourceId });
      if (!initResult.success) {
        throw new Error(initResult.error);
      }

      console.log('🎭 SIM: Simulator components initialized');
    }

    function setControlsPinned(pinned) {
      const controlsPanel = document.getElementById('controls');
      const pinButton = document.getElementById('controls-pin-btn');

      if (!controlsPanel || !pinButton) {
        return;
      }

      controlsPanel.classList.toggle('is-pinned', pinned);
      pinButton.setAttribute('aria-pressed', String(pinned));
      pinButton.textContent = pinned ? '📌 Épinglé' : '📌 Épingler';
    }

    function attachEventListeners() {
      const pinButton = document.getElementById('controls-pin-btn');
      setControlsPinned(false);

      // Mode toggle
      document.getElementById('mode-live')?.addEventListener('click', () => {
        switchMode('live');
      });

      document.getElementById('mode-simulation')?.addEventListener('click', () => {
        switchMode('simulation');
      });

      // Source selector
      document.getElementById('sim-source-select')?.addEventListener('change', (e) => {
        const newSource = e.target.value;
        console.log('🎭 SIM: Source changed to:', newSource);
        // Mettre à jour globalConfig pour cohérence
        if (window.globalConfig) {
          window.globalConfig.set('data_source', newSource);
        }
        // Recharger si en mode Live
        if (appState.mode === 'live') {
          loadLiveData();
        }
      });

      // Test source button
      document.getElementById('test-source-btn')?.addEventListener('click', testSelectedSource);

      // Apply preset button
      document.getElementById('apply-preset-btn')?.addEventListener('click', applyPreset);

      pinButton?.addEventListener('click', () => {
        const controlsPanel = document.getElementById('controls');
        const isPinned = controlsPanel?.classList.contains('is-pinned');
        setControlsPinned(!isPinned);
      });

      // Retry button
      document.getElementById('retry-btn')?.addEventListener('click', () => {
        if (appState.lastSimulation) {
          runSimulation(appState.lastSimulation);
        }
      });

      // URL hash pour restaurer état
      window.addEventListener('hashchange', () => {
        restoreStateFromHash();
        if (window.location.hash === '#controls') {
          setControlsPinned(true);
          document.getElementById('controls')?.focus({ preventScroll: true });
        }
      });
    }

    function setInitialState() {
      // Vérifier URL hash
      const hashState = SimEngine.stateFromUrlHash();
      if (hashState) {
        appState.controls.setState(hashState);
        switchMode('simulation');
      }

      // État initial empty
      showEmptyState();

      if (window.location.hash === '#controls') {
        setControlsPinned(true);
        document.getElementById('controls')?.focus({ preventScroll: true });
      }
    }

    function switchMode(mode) {
      appState.mode = mode;

      // UI updates
      document.getElementById('mode-live')?.classList.toggle('active', mode === 'live');
      document.getElementById('mode-simulation')?.classList.toggle('active', mode === 'simulation');

      // Mettre à jour le statut
      const statusEl = document.getElementById('simulation-status');
      if (statusEl) {
        const badge = statusEl.querySelector('.status-badge');
        if (mode === 'live') {
          badge.textContent = 'Mode Live';
          badge.className = 'status-badge success';
        } else {
          badge.textContent = 'Mode Simulation';
          badge.className = 'status-badge info';
        }
      }

      console.log('🎭 SIM: Mode switched to:', mode);

      // Si on passe en mode simulation et qu'on a des contrôles, lancer simulation
      if (mode === 'simulation' && appState.controls) {
        const state = appState.controls.getState();
        onControlsUpdate(state);
      }

      // Si on passe en mode live, charger les vraies données depuis Analytics
      if (mode === 'live') {
        loadLiveData();
      }
    }

    async function onControlsUpdate(controlsState) {
      if (appState.mode !== 'simulation' || appState.isRunning) {
        return;
      }

      // Debounce pour éviter d'inonder le moteur quand l'utilisateur bouge un slider rapidement
      if (controlsUpdateTimeout) {
        clearTimeout(controlsUpdateTimeout);
      }

      controlsUpdateTimeout = setTimeout(async () => {
        console.log('🎭 SIM: Controls updated, running simulation');
        appState.lastSimulation = controlsState;

        // Mettre à jour URL hash
        const hash = SimEngine.stateToUrlHash(controlsState);
        if (hash !== window.location.hash) {
          history.replaceState(null, null, hash);
        }

        await runSimulation(controlsState);
      }, 250); // 250ms debounce
    }

    async function runSimulation(controlsState) {
      if (appState.isRunning) return;

      appState.isRunning = true;
      showLoadingState();

      try {
        // Lancer la simulation complète
        const result = await SimEngine.simulateFullPipeline(controlsState);
        console.log('🎭 SIM: Simulation completed:', result);

        // Afficher les résultats
        displayResults(result);
        appState.inspector.updateInspector(result);

        showResultsState();

      } catch (error) {
        console.error('🎭 SIM: Simulation failed:', error);
        showError('Erreur de simulation: ' + error.message);
      } finally {
        appState.isRunning = false;
      }
    }

    async function loadLiveData() {
      if (appState.isRunning) return;

      appState.isRunning = true;
      showLoadingState();

      try {
        const apiBase = window.globalConfig?.get('api_base_url') || window.location.origin;

        // Charger les données réelles depuis les endpoints existants
        console.log('🎭 SIM: Loading live data from Analytics...');

        const activeSource = getActiveSource();
        const userId = localStorage.getItem('activeUser') || 'demo';
        console.log('🎭 SIM: Using data source:', activeSource, '| User:', userId);

        // ✅ USE UNIFIED loadBalanceData() like dashboard.html (lines 1130-1148)
        console.log('🎭 SIM: Calling window.loadBalanceData() with forceRefresh...');
        const balanceResult = await window.loadBalanceData(true); // forceRefresh=true

        if (!balanceResult || !balanceResult.success) {
          throw new Error('Failed to load balance data via loadBalanceData()');
        }

        console.log('🎭 SIM: Balance result received:', {
          hasData: !!balanceResult.data,
          hasCsvText: !!balanceResult.csvText,
          source: balanceResult.source
        });

        // Parse balances (same as dashboard.html lines 1150-1166)
        let balances;
        if (balanceResult.csvText) {
          // CSV source
          const minThreshold = (window.globalConfig && window.globalConfig.get('min_usd_threshold')) || 1.0;
          balances = parseCSVBalancesAuto(balanceResult.csvText, { thresholdUSD: minThreshold });
        } else if (balanceResult.data && Array.isArray(balanceResult.data.items)) {
          // API source
          balances = balanceResult.data.items.map(item => ({
            symbol: item.symbol,
            balance: item.balance,
            value_usd: item.value_usd
          }));
        } else {
          throw new Error('Invalid balance data format');
        }

        const totalValue = balances.reduce((sum, it) => sum + (parseFloat(it.value_usd) || 0), 0);
        const assetCount = balances.length;
        console.log(`🎭 SIM: Parsed ${assetCount} assets, total: $${totalValue.toFixed(2)}`);

        // Create balancesData structure
        const balancesData = {
          items: balances,
          source_used: balanceResult.source,
          total_count: assetCount
        };

        // 1. Portfolio metrics (contient DI, performance, etc.)
        const metricsResponse = await fetch(`${apiBase}/portfolio/metrics?source=${activeSource}&user_id=${userId}`);
        if (!metricsResponse.ok) {
          throw new Error(`Portfolio metrics failed: ${metricsResponse.status}`);
        }
        const metricsData = await metricsResponse.json();

        // 2. Calculer les VRAIES allocations actuelles du wallet (comme analytics-unified.html)
        console.log('🎭 SIM: Calculating real current allocations from balances...');
        const { groupAssetsByClassification } = await import('./shared-asset-groups.js');
        const groupedData = groupAssetsByClassification(balances);

        // Convertir en format attendu: allocations actuelles en %
        const currentAllocations = {};
        groupedData.forEach(group => {
          const percentage = (group.value / totalValue) * 100;
          currentAllocations[group.label] = percentage;
        });

        console.log('🎭 SIM: Real current allocations calculated:', {
          allocations: currentAllocations,
          totalValue,
          groupsCount: groupedData.length
        });

        // 3. Calculer les targets théoriques depuis les métriques
        const theoreticalTargets = metricsData.targets || {};

        console.log('🎭 SIM: Theoretical targets from metrics:', theoreticalTargets);

        // 4. INITIALISER LE STORE avant d'appeler getUnifiedState() (CRITIQUE!)
        console.log('🎭 SIM: Initializing store with complete data...');

        // Créer window.store s'il n'existe pas
        if (!window.store) {
          window.store = {
            data: {},
            set(key, value) {
              this.data[key] = value;
            },
            get(key) {
              return this.data[key];
            }
          };
        }

        // Injecter balances dans le store (requis par getUnifiedState)
        window.store.set('wallet.balances', balances);
        window.store.set('wallet.total', totalValue);
        console.log('🎭 SIM: Store initialized with wallet data:', {
          balances: balances.length,
          total: totalValue
        });

        // Charger les scores dans le store (cycle, onchain, risk)
        try {
          // Cycle score
          const { getCurrentCycleMonths, cycleScoreFromMonths, getCyclePhase } = await import('./modules/cycle-navigator.js');
          const c = getCurrentCycleMonths();
          const cycleScore = Math.round(cycleScoreFromMonths(c.months));
          const cyclePhase = getCyclePhase(c.months);
          window.store.set('cycle.months', c.months);
          window.store.set('cycle.score', cycleScore);
          window.store.set('cycle.phase', cyclePhase);
          console.log('🎭 SIM: Cycle data loaded:', { score: cycleScore, phase: cyclePhase });

          // Onchain score (simplifié pour l'instant)
          // TODO: Charger les vrais indicateurs onchain
          window.store.set('scores.onchain', 72); // Valeur par défaut
          console.log('🎭 SIM: Onchain score set to default: 72');

          // Risk score
          window.store.set('scores.risk', 34); // Valeur par défaut
          console.log('🎭 SIM: Risk score set to default: 34');

        } catch (e) {
          console.warn('🎭 SIM: Failed to load scores:', e.message);
        }

        // 5. Utiliser le SYSTÈME UNIFIÉ pour obtenir les VRAIES données (comme analytics-unified.html)
        console.log('🎭 SIM: Loading unified state from Analytics system...');
        let unifiedState = null;
        try {
          const { getUnifiedState } = await import('./core/unified-insights-v2.js');
          unifiedState = await getUnifiedState();
          console.log('🎭 SIM: Unified state loaded:', {
            decisionScore: unifiedState?.decision?.score,
            contradiction: unifiedState?.governance?.contradiction_index,
            riskBudget: unifiedState?.risk?.budget?.target_stables_pct,
            hasTargets: !!unifiedState?.targets_by_group
          });
        } catch (e) {
          console.warn('🎭 SIM: Failed to load unified state, using fallback:', e.message);
        }

        // 6. Construire un résultat avec les données du système unifié (si disponible)
        const decisionIndex = unifiedState?.decision?.score ?? 50;
        const contradictionIndex = unifiedState?.governance?.contradiction_index ?? 0.5;
        const confidence = unifiedState?.decision?.confidence ?? 0.8;
        const targetStables = unifiedState?.risk?.budget?.target_stables_pct ?? (metricsData.performance?.risk_budget || 30);

        const liveResult = {
          di: {
            di: Math.round(decisionIndex),
            source: unifiedState ? 'unified_insights_v2' : 'live_analytics',
            confidence: confidence
          },
          riskBudget: {
            target_stables_pct: targetStables,
            curve: unifiedState?.risk?.budget?.methodology || 'live-data',
            clamps: {
              min_stables: unifiedState?.risk?.budget?.min_stables_pct || 10,
              max_stables: unifiedState?.risk?.budget?.max_stables_pct || 60
            }
          },
          // ALLOCATIONS ACTUELLES RÉELLES (depuis wallet groupé)
          currentAllocations: currentAllocations,
          // TARGETS THÉORIQUES (depuis unified state ou analytics)
          cappedTargets: unifiedState?.targets_by_group || theoreticalTargets,
          orders: {
            orders: [],
            summary: {
              totalDelta: 0,
              globalThreshold: 2,
              shouldExecute: false,
              message: `Mode Live - ${balancesData.items?.length || 0} assets réels`
            }
          },
          explanation: {
            summaryNL: `📊 Données réelles depuis ${activeSource}\n\n` +
                       `Portfolio: ${balancesData.items?.length || 0} assets\n` +
                       `Valeur totale: $${totalValue.toFixed(2)}\n` +
                       `Performance 24h: ${metricsData.performance?.percentage_change?.toFixed(2) || '0'}%\n\n` +
                       `Decision Index: ${Math.round(decisionIndex)}/100 (${Math.round(confidence * 100)}%)\n` +
                       `Contradiction: ${Math.round(contradictionIndex * 100)}%\n` +
                       `Risk Budget: ${Math.round(targetStables)}% stables\n\n` +
                       `Allocations réelles:\n` +
                       Object.entries(currentAllocations)
                         .filter(([_, pct]) => pct > 0.5)
                         .map(([group, pct]) => `  • ${group}: ${pct.toFixed(1)}%`)
                         .join('\n')
          },
          presetInfo: {
            name: 'Live Data',
            desc: `Source: ${activeSource} | User: ${userId} | ${assetCount} assets | Unified: ${!!unifiedState}`
          },
          ui: {
            stateForEngine: {
              governance: {
                contradiction_index: contradictionIndex,
                contradiction_pct: Math.round(contradictionIndex * 100)
              },
              cycle: unifiedState?.cycle,
              onchain: unifiedState?.onchain,
              risk: unifiedState?.risk
            }
          },
          // Ajouter les données complètes pour debug
          _debug: {
            balances: balances,
            groupedData: groupedData,
            totalValue: totalValue,
            unifiedState: unifiedState
          }
        };

        console.log('🎭 SIM: Live data loaded:', liveResult);

        // Afficher les résultats
        displayResults(liveResult);
        appState.inspector.updateInspector(liveResult);
        showResultsState();

      } catch (error) {
        console.error('🎭 SIM: Live data loading failed:', error);
        showError('Erreur de chargement des données live: ' + error.message);
      } finally {
        appState.isRunning = false;
      }
    }

    function displayResults(result) {
      const { di, riskBudget, cappedTargets, currentAllocations, orders, explanation } = result;

      // Déterminer si on est en mode Live ou Simulation
      const isLiveMode = result?.presetInfo?.name === 'Live Data';

      // Affichage badges dans le header des résultats
      const stateForEngine = result?.ui?.stateForEngine ?? null;
      const capPercent = stateForEngine ? selectCapPercent(stateForEngine) : null;
      try {
        const badgeProps = {};
        if (capPercent != null) {
          badgeProps.cap = capPercent;
        }
        renderBadges(document.querySelector('#badges-sim'), {
          state: stateForEngine || {},
          ...badgeProps
        });
      } catch (e) {
        console.warn('Badges render skipped:', e?.message);
      }

      // Decision Index
      document.getElementById('sim-di-gauge').textContent = di.di;
      document.getElementById('sim-di-source-badge').textContent = `Source: ${di.source}`;
      document.getElementById('sim-di-confidence').textContent = Math.round(di.confidence * 100);
      const presetName = result?.presetInfo?.name || result?.context?.presetInfo?.name || 'Custom';
      const presetDesc = result?.presetInfo?.desc || result?.context?.presetInfo?.desc || '';
      const presetEl = document.getElementById('sim-selected-preset');
      if (presetEl) {
        presetEl.textContent = `${isLiveMode ? '📊 Live' : '🎭 Simulation'}: ${presetName}`;
        if (presetDesc) {
          presetEl.setAttribute('title', presetDesc);
        } else {
          presetEl.removeAttribute('title');
        }
      }

      // Risk Budget
      const stablesPct = Math.round(riskBudget.target_stables_pct);
      const riskyPct = 100 - stablesPct;

      document.getElementById('sim-stables-pct').textContent = `${stablesPct}%`;
      document.getElementById('sim-risky-pct').textContent = `${riskyPct}%`;
      document.getElementById('sim-risk-curve').textContent = riskBudget.curve;
      document.getElementById('sim-risk-clamps').textContent =
        `${riskBudget.clamps.min_stables}-${riskBudget.clamps.max_stables}%`;

      // Ajuster la largeur des barres
      document.getElementById('sim-stables-bar').style.width = `${stablesPct}%`;
      document.getElementById('sim-risky-bar').style.width = `${riskyPct}%`;

      // Allocation chart: afficher currentAllocations en mode Live, cappedTargets en mode Simulation
      const allocationsToDisplay = isLiveMode && currentAllocations ? currentAllocations : cappedTargets;
      displayAllocationChart(allocationsToDisplay, isLiveMode);

      // Execution plan
      document.getElementById('sim-total-delta').textContent = `${orders.summary.totalDelta}%`;
      document.getElementById('sim-exec-threshold').textContent = `${orders.summary.globalThreshold}%`;

      const statusEl = document.getElementById('sim-exec-status');
      if (orders.summary.shouldExecute) {
        statusEl.textContent = 'Exécuter';
        statusEl.className = 'status-badge success';
      } else {
        statusEl.textContent = 'Attendre';
        statusEl.className = 'status-badge warning';
      }

      // Orders list
      displayOrdersList(orders.orders);

      // Résumé NL
      document.getElementById('sim-summary-nl').textContent = explanation.summaryNL;
    }

    function displayAllocationChart(targets, isLiveMode = false) {
      const chartEl = document.getElementById('sim-allocation-chart');
      if (!chartEl || !targets) return;

      // Créer un chart simple avec des barres
      const sortedTargets = Object.entries(targets)
        .sort(([,a], [,b]) => b - a)
        .filter(([, value]) => value >= 0.1); // Filtrer les très petites valeurs

      const chartTitle = isLiveMode ? '📊 Allocations Actuelles (Wallet Réel)' : '🎯 Allocations Cibles (Simulation)';

      let html = `<div style="margin-bottom: 0.75rem; font-weight: 600; font-size: 0.95rem; color: var(--theme-text);">${chartTitle}</div>`;
      html += '<div style="display: flex; flex-direction: column; gap: 0.5rem;">';

      for (const [group, pct] of sortedTargets) {
        const width = Math.max(2, (pct / Math.max(...Object.values(targets))) * 100);
        const color = getGroupColor(group);

        html += `
          <div style="display: flex; align-items: center; gap: 0.5rem; font-size: 0.85rem;">
            <div style="width: 100px; text-align: right; color: var(--theme-text-muted); overflow: hidden; text-overflow: ellipsis;" title="${group}">${group}:</div>
            <div style="flex: 1; background: var(--theme-border); height: 20px; border-radius: 10px; overflow: hidden;">
              <div style="width: ${width}%; height: 100%; background: ${color}; transition: width 0.3s ease;"></div>
            </div>
            <div style="width: 50px; text-align: right; font-family: monospace; font-weight: 600;">${pct.toFixed(1)}%</div>
          </div>
        `;
      }

      html += '</div>';
      chartEl.innerHTML = html;
    }

    function getGroupColor(group) {
      const colors = {
        'Stablecoins': '#10b981',
        'BTC': '#f59e0b',
        'ETH': '#3b82f6',
        'SOL': '#8b5cf6',
        'L1/L0 majors': '#06b6d4',
        'L2/Scaling': '#84cc16',
        'DeFi': '#ec4899',
        'AI/Data': '#f97316',
        'Gaming/NFT': '#ef4444',
        'Memecoins': '#6366f1',
        'Others': '#6b7280'
      };
      return colors[group] || '#9ca3af';
    }

    function displayOrdersList(orders) {
      const listEl = document.getElementById('sim-orders-list');
      if (!listEl) return;

      if (!orders || orders.length === 0) {
        listEl.innerHTML = '<div style="text-align: center; color: var(--theme-text-muted); padding: var(--space-md);">Aucun ordre généré</div>';
        return;
      }

      let html = '';
      orders.forEach(order => {
        const actionClass = order.action.toLowerCase();
        const priorityIcon = order.priority === 'HIGH' ? '🔥' : '📋';

        html += `
          <div class="order-item">
            <div>
              <span class="order-action ${actionClass}">${order.action}</span>
              <span style="margin-left: 0.5rem;">${order.group}</span>
            </div>
            <div style="text-align: right;">
              <div style="font-family: monospace; font-weight: 600;">${order.deltaPct > 0 ? '+' : ''}${order.deltaPct}%</div>
              <div style="font-size: 0.8rem; color: var(--theme-text-muted);">${priorityIcon} ${order.estimatedLot}€</div>
            </div>
          </div>
        `;
      });

      listEl.innerHTML = html;
    }

    async function reinitializeWithNewSource() {
      console.log('🎭 SIM: Reinitializing with new source:', appState.sourceId);

      showLoadingState();

      try {
        const initResult = await SimEngine.initSimulation({ sourceId: appState.sourceId });
        if (!initResult.success) {
          throw new Error(initResult.error);
        }

        // Relancer simulation si en mode simulation
        if (appState.mode === 'simulation' && appState.controls) {
          const state = appState.controls.getState();
          await runSimulation(state);
        } else {
          showEmptyState();
        }

      } catch (error) {
        console.error('🎭 SIM: Reinitialization failed:', error);
        showError('Échec du changement de source: ' + error.message);
      }
    }

    function restoreStateFromHash() {
      const hashState = SimEngine.stateFromUrlHash();
      if (hashState && appState.controls) {
        appState.controls.setState(hashState);
        switchMode('simulation');
      }
    }

    // États d'affichage
    function showLoadingState() {
      document.getElementById('loading-state')?.classList.add('active');
      document.getElementById('error-state')?.classList.remove('active');
      document.getElementById('empty-state')?.style.setProperty('display', 'none');
      document.getElementById('results-grid')?.style.setProperty('display', 'none');
    }

    function showResultsState() {
      document.getElementById('loading-state')?.classList.remove('active');
      document.getElementById('error-state')?.classList.remove('active');
      document.getElementById('empty-state')?.style.setProperty('display', 'none');
      document.getElementById('results-grid')?.style.setProperty('display', 'grid');
    }

    function showEmptyState() {
      document.getElementById('loading-state')?.classList.remove('active');
      document.getElementById('error-state')?.classList.remove('active');
      document.getElementById('empty-state')?.style.setProperty('display', 'block');
      document.getElementById('results-grid')?.style.setProperty('display', 'none');
    }

    function showError(message) {
      document.getElementById('loading-state')?.classList.remove('active');
      document.getElementById('error-state')?.classList.add('active');
      document.getElementById('error-message').textContent = message;
      document.getElementById('empty-state')?.style.setProperty('display', 'none');
      document.getElementById('results-grid')?.style.setProperty('display', 'none');
    }

    // Export global pour debug
    window.simApp = {
      state: appState,
      engine: SimEngine,
      runSimulation,
      switchMode
    };
  </script>
</body>

</html>


