<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <title>üéØ Bitcoin Cycle Analysis - Mod√®le de Pr√©cision</title>
  <style>
    body {
      font-family: system-ui;
      margin: 2rem;
      background: #f8fafc;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
    }

    .card {
      background: white;
      border-radius: 12px;
      padding: 2rem;
      margin: 1rem 0;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }

    .metric {
      display: flex;
      justify-content: space-between;
      margin: 1rem 0;
      padding: 0.5rem;
      border-radius: 8px;
    }

    .metric.good {
      background: #d4edda;
      color: #155724;
    }

    .metric.warning {
      background: #fff3cd;
      color: #856404;
    }

    .metric.error {
      background: #f8d7da;
      color: #721c24;
    }

    .chart-container {
      height: 400px;
      margin: 2rem 0;
      position: relative;
    }

    button {
      padding: 0.8rem 1.5rem;
      margin: 0.5rem;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 600;
    }

    .btn-primary {
      background: #007bff;
      color: white;
    }

    .btn-success {
      background: #28a745;
      color: white;
    }

    .btn-warning {
      background: #ffc107;
      color: black;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      margin: 1rem 0;
    }

    th,
    td {
      padding: 0.8rem;
      text-align: left;
      border-bottom: 1px solid #ddd;
    }

    th {
      background: #f8f9fa;
      font-weight: 600;
    }

    .score-cell {
      font-weight: bold;
      padding: 0.5rem;
      border-radius: 4px;
      text-align: center;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/date-fns@2.29.0/index.min.js"></script>
  <script
    src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@2.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
</head>

<body>
  <div class="container">
    <h1>üéØ Bitcoin Cycle Analysis - Validation du Mod√®le</h1>

    <!-- Contr√¥les -->
    <div class="card">
      <h2>üîß Contr√¥les d'Analyse</h2>
      <button class="btn-primary" onclick="runFullAnalysis()">üöÄ Analyse Compl√®te</button>
      <button class="btn-success" onclick="calibrateModel()">‚öôÔ∏è Calibrer Mod√®le</button>
      <button class="btn-warning" onclick="testAlternatives()">üß™ Tester Alternatives</button>
      <button class="btn-primary" onclick="generateReport()">üìä Rapport D√©taill√©</button>
    </div>

    <!-- M√©triques de Pr√©cision -->
    <div class="card">
      <h2>üìä M√©triques de Pr√©cision du Mod√®le</h2>
      <div id="precision-metrics"></div>
    </div>

    <!-- Graphique de Validation -->
    <div class="card">
      <h2>üìà Validation Visuelle - Pr√©dictions vs R√©alit√©</h2>
      <div class="chart-container">
        <canvas id="validation-chart"></canvas>
      </div>
    </div>

    <!-- Analyse des Erreurs -->
    <div class="card">
      <h2>üîç Analyse des Erreurs par Cycle</h2>
      <table id="error-analysis-table">
        <thead>
          <tr>
            <th>Cycle</th>
            <th>Halving</th>
            <th>Peak R√©el</th>
            <th>Peak Pr√©dit</th>
            <th>Erreur</th>
            <th>Score R√©el</th>
            <th>Score Mod√®le</th>
            <th>Pr√©cision</th>
          </tr>
        </thead>
        <tbody id="error-table-body"></tbody>
      </table>
    </div>

    <!-- Indicateurs Compl√©mentaires -->
    <div class="card">
      <h2>üåü Indicateurs On-Chain Recommand√©s</h2>
      <div id="indicators-suggestions"></div>
    </div>

    <!-- R√©sultats -->
    <div class="card">
      <h2>üìã R√©sultats d'Analyse</h2>
      <div id="analysis-results"></div>
    </div>
  </div>

  <script type="module">
    // Variables globales pour les modules
    let cycleScoreFromMonths, getCycleParams, calibrateCycleParams, getCurrentCycleMonths;
    let moduleLoaded = false;

    // Donn√©es historiques des cycles Bitcoin
    const HISTORICAL_CYCLES = [
      {
        id: 1,
        halving: '2012-11-28',
        peak: '2013-11-30',
        peakPrice: 1177,
        bottom: '2015-01-14',
        bottomPrice: 152,
        cycleHigh: 1177,
        cycleLow: 65
      },
      {
        id: 2,
        halving: '2016-07-09',
        peak: '2017-12-17',
        peakPrice: 19783,
        bottom: '2018-12-15',
        bottomPrice: 3122,
        cycleHigh: 19783,
        cycleLow: 365
      },
      {
        id: 3,
        halving: '2020-05-11',
        peak: '2021-11-10',
        peakPrice: 68789,
        bottom: '2022-11-21',
        bottomPrice: 15460,
        cycleHigh: 68789,
        cycleLow: 3850
      },
      {
        id: 4,
        halving: '2024-04-20',
        peak: null, // En cours
        peakPrice: null,
        bottom: null,
        bottomPrice: null,
        currentPrice: 65000, // Estimation
        cycleHigh: null,
        cycleLow: null
      }
    ];

    // --- Fallback local si le module ne se charge pas ---
    // Sigmo√Øde simple 0‚Üí100 avec pic vers ~18-20 mois
    function _fallbackCycleScoreFromMonths(m) {
      // logistique centr√©e sur 18 mois, pente 0.35
      const s = 1 / (1 + Math.exp(-(m - 18) * 0.35));
      return Math.max(0, Math.min(100, s * 100));
    }
    function _fallbackGetCycleParams() { return { center: 18, slope: 0.35 }; }
    function _fallbackCalibrate() { return { score: 0 }; }
    function _fallbackGetCurrentCycleMonths() { return 0; }


    // Persistance des param√®tres calibr√©s
    function saveCalibrationParams(params) {
      try {
        localStorage.setItem('bitcoin_cycle_params', JSON.stringify({
          params: params,
          timestamp: Date.now(),
          version: '1.0'
        }));
        console.log('‚úÖ Param√®tres calibr√©s sauvegard√©s', params);
      } catch (error) {
        console.error('‚ùå Erreur sauvegarde param√®tres:', error);
      }
    }
    
    function loadCalibrationParams() {
      try {
        const saved = localStorage.getItem('bitcoin_cycle_params');
        if (saved) {
          const data = JSON.parse(saved);
          // V√©rifier que les donn√©es ne sont pas trop anciennes (24h)
          if (Date.now() - data.timestamp < 24 * 60 * 60 * 1000) {
            console.log('‚úÖ Param√®tres calibr√©s charg√©s depuis localStorage', data.params);
            return data.params;
          }
        }
      } catch (error) {
        console.error('‚ùå Erreur chargement param√®tres:', error);
      }
      return null;
    }

    // Chargement des modules
    async function loadModules() {
      try {
        console.log('üîÑ Tentative de chargement du module cycle-navigator...');
        const module = await import('./modules/cycle-navigator.js');
        
        // V√©rifier que les fonctions sont disponibles
        if (!module.cycleScoreFromMonths) {
          throw new Error('cycleScoreFromMonths function not available in module');
        }
        
        cycleScoreFromMonths = module.cycleScoreFromMonths;
        getCycleParams = module.getCycleParams;
        calibrateCycleParams = module.calibrateCycleParams;
        getCurrentCycleMonths = module.getCurrentCycleMonths;
        
        // Test de la fonction
        const testScore = cycleScoreFromMonths(18);
        console.log('üß™ Test cycleScoreFromMonths(18):', testScore);
        
        if (isNaN(testScore) || testScore < 0 || testScore > 100) {
          throw new Error('Function test failed - invalid score: ' + testScore);
        }
        
        // Charger les param√®tres sauvegard√©s si disponibles
        const savedParams = loadCalibrationParams();
        if (savedParams) {
          module.setCycleParams(savedParams);
          addResult('üîÑ Auto-Chargement', 'Param√®tres calibr√©s pr√©c√©dents appliqu√©s', 'good');
        }
        
        moduleLoaded = true;
        console.log('‚úÖ Cycle navigator module loaded successfully');
        return true;
      } catch (error) {
        console.error('‚ùå Failed to load cycle navigator:', error);
        // üîÅ Fallback local pour que le graphe fonctionne quand m√™me
        cycleScoreFromMonths = _fallbackCycleScoreFromMonths;
        getCycleParams = _fallbackGetCycleParams;
        calibrateCycleParams = _fallbackCalibrate;
        getCurrentCycleMonths = _fallbackGetCurrentCycleMonths;
        moduleLoaded = true; // on passe √† true pour ne pas bloquer la suite
        addResult('‚ö†Ô∏è Mode d√©grad√©', 'Module non charg√© ‚Äî utilisation d\'un mod√®le local par d√©faut', 'warning');
        console.log('üîÑ Utilisation du fallback, test:', _fallbackCycleScoreFromMonths(18));
        return true;
      }
    }


    function monthsBetween(dateA, dateB) {
      const a = new Date(dateA);
      const b = new Date(dateB);
      
      // Calcul pr√©cis des mois entre deux dates
      const years = b.getFullYear() - a.getFullYear();
      const months = b.getMonth() - a.getMonth();
      const days = b.getDate() - a.getDate();
      
      let totalMonths = years * 12 + months;
      
      // Ajuster pour les jours
      if (days > 0) {
        totalMonths += days / 30.44; // Moyenne des jours par mois
      } else if (days < 0) {
        totalMonths -= Math.abs(days) / 30.44;
      }
      
      return Math.max(0, totalMonths);
    }

    function addResult(title, content, type = 'info') {
      const results = document.getElementById('analysis-results');
      const div = document.createElement('div');
      div.className = `metric ${type}`;
      div.innerHTML = `<strong>${title}:</strong> ${content}`;
      results.appendChild(div);
    }

    // Calcul des m√©triques de pr√©cision
    function calculatePrecisionMetrics() {
      if (!moduleLoaded || !cycleScoreFromMonths) {
        console.error('cycleScoreFromMonths function not available');
        return { avgPeakError: 0, avgBottomError: 0, overallAccuracy: 0, completedCycles: [] };
      }

      const completedCycles = HISTORICAL_CYCLES.filter(c => c.peak && c.bottom);
      let totalError = 0;
      let peakErrors = [];
      let bottomErrors = [];

      const metrics = document.getElementById('precision-metrics');
      if (!metrics) {
        console.error('precision-metrics element not found');
        return { avgPeakError: 0, avgBottomError: 0, overallAccuracy: 0, completedCycles: [] };
      }

      metrics.innerHTML = '';

      completedCycles.forEach(cycle => {
        const monthsToPeak = monthsBetween(cycle.halving, cycle.peak);
        const monthsToBottom = monthsBetween(cycle.halving, cycle.bottom);

        const predictedPeakScore = cycleScoreFromMonths(monthsToPeak);
        const predictedBottomScore = cycleScoreFromMonths(monthsToBottom);

        // On s'attend √† peak ‚âà 100, bottom ‚âà 10
        const peakError = Math.abs(100 - predictedPeakScore);
        const bottomError = Math.abs(10 - predictedBottomScore);

        peakErrors.push(peakError);
        bottomErrors.push(bottomError);
        totalError += peakError + bottomError;
      });

      // M√©triques globales
      const avgPeakError = peakErrors.reduce((a, b) => a + b, 0) / peakErrors.length;
      const avgBottomError = bottomErrors.reduce((a, b) => a + b, 0) / bottomErrors.length;
      const overallAccuracy = Math.max(0, 100 - (totalError / completedCycles.length / 2));

      // Affichage des m√©triques
      metrics.innerHTML = `
        <div class="metric ${avgPeakError < 15 ? 'good' : avgPeakError < 30 ? 'warning' : 'error'}">
          <span>Erreur Moyenne Pics:</span>
          <span>${avgPeakError.toFixed(1)} points</span>
        </div>
        <div class="metric ${avgBottomError < 20 ? 'good' : avgBottomError < 35 ? 'warning' : 'error'}">
          <span>Erreur Moyenne Creux:</span>
          <span>${avgBottomError.toFixed(1)} points</span>
        </div>
        <div class="metric ${overallAccuracy > 80 ? 'good' : overallAccuracy > 60 ? 'warning' : 'error'}">
          <span>Pr√©cision Globale:</span>
          <span>${overallAccuracy.toFixed(1)}%</span>
        </div>
        <div class="metric good">
          <span>Cycles Analys√©s:</span>
          <span>${completedCycles.length}/3 cycles complets</span>
        </div>
      `;

      return { avgPeakError, avgBottomError, overallAccuracy, completedCycles };
    }

    // Graphique de validation
    function createValidationChart() {
      if (!moduleLoaded || !cycleScoreFromMonths) {
        console.error('cycleScoreFromMonths function not available');
        return;
      }

      const canvas = document.getElementById('validation-chart');
      const ctx = canvas.getContext('2d');

      // V√©rifier que Chart.js est charg√©
      if (typeof Chart === 'undefined') {
        console.error('Chart.js not loaded');
        return;
      }

      // G√©n√©rer les donn√©es du mod√®le
      const modelData = [];
      for (let months = 0; months <= 48; months++) {
        modelData.push({
          x: months,
          y: cycleScoreFromMonths(months)
        });
      }

      // Points historiques r√©els
      const historicalPoints = [];
      HISTORICAL_CYCLES.forEach(cycle => {
        if (cycle.peak) {
          const monthsToPeak = monthsBetween(cycle.halving, cycle.peak);
          historicalPoints.push({
            x: monthsToPeak,
            y: 100, // On consid√®re le pic comme score 100
            label: `Cycle ${cycle.id} Peak`,
            color: '#dc2626'
          });
        }
        if (cycle.bottom) {
          const monthsToBottom = monthsBetween(cycle.halving, cycle.bottom);
          historicalPoints.push({
            x: monthsToBottom,
            y: 10, // On consid√®re le creux comme score 10
            label: `Cycle ${cycle.id} Bottom`,
            color: '#059669'
          });
        }
      });

      // D√©truire chart existant si n√©cessaire
      const existingChart = Chart.getChart(ctx);
      if (existingChart) {
        existingChart.destroy();
      }

      const chart = new Chart(ctx, {
        type: 'line',
        data: {
          datasets: [
            {
              label: 'Mod√®le Sigmo√Øde',
              data: modelData,
              borderColor: '#3b82f6',
              backgroundColor: 'rgba(59, 130, 246, 0.1)',
              borderWidth: 3,
              fill: false,
              pointRadius: 0
            },
            {
              label: 'Points Historiques R√©els',
              data: historicalPoints,
              backgroundColor: historicalPoints.map(p => p.color),
              borderColor: historicalPoints.map(p => p.color),
              pointRadius: 8,
              pointHoverRadius: 10,
              showLine: false
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: {
              title: { display: true, text: 'Mois apr√®s Halving' },
              min: 0,
              max: 48
            },
            y: {
              title: { display: true, text: 'Score de Cycle (0-100)' },
              min: 0,
              max: 100
            }
          },
          plugins: {
            tooltip: {
              callbacks: {
                label: function (context) {
                  const point = context.raw;
                  return point.label || `Score: ${context.parsed.y}`;
                }
              }
            }
          }
        }
      });
    }

    // Tableau d'analyse des erreurs
    function populateErrorTable() {
      if (!moduleLoaded || !cycleScoreFromMonths) {
        console.error('cycleScoreFromMonths function not available');
        return;
      }

      const tbody = document.getElementById('error-table-body');
      if (!tbody) {
        console.error('error-table-body element not found');
        return;
      }

      tbody.innerHTML = '';

      HISTORICAL_CYCLES.forEach(cycle => {
        if (!cycle.peak) return;

        const monthsToPeak = monthsBetween(cycle.halving, cycle.peak);
        const predictedScore = cycleScoreFromMonths(monthsToPeak);
        const error = Math.abs(100 - predictedScore);
        const accuracy = Math.max(0, 100 - error);

        const row = document.createElement('tr');
        row.innerHTML = `
          <td>Cycle ${cycle.id}</td>
          <td>${new Date(cycle.halving).toLocaleDateString('fr-FR')}</td>
          <td>${new Date(cycle.peak).toLocaleDateString('fr-FR')}</td>
          <td>${monthsToPeak.toFixed(1)} mois</td>
          <td class="score-cell ${error < 15 ? 'good' : error < 30 ? 'warning' : 'error'}">${error.toFixed(1)}</td>
          <td>100 (pic)</td>
          <td>${predictedScore.toFixed(1)}</td>
          <td class="score-cell ${accuracy > 80 ? 'good' : accuracy > 60 ? 'warning' : 'error'}">${accuracy.toFixed(1)}%</td>
        `;
        tbody.appendChild(row);
      });
    }

    // Suggestions d'indicateurs on-chain
    function showIndicatorsSuggestions() {
      const container = document.getElementById('indicators-suggestions');

      const indicators = [
        {
          name: "MVRV Ratio",
          description: "Market Value to Realized Value - D√©tecte la sur/sous-√©valuation",
          api: "Glassnode, CoinMetrics",
          priority: "üî• Haute",
          reason: "Corr√®le fortement avec les cycles de march√©"
        },
        {
          name: "NVT Ratio",
          description: "Network Value to Transactions - P/E ratio du Bitcoin",
          api: "Blockchain.info, Messari",
          priority: "üî• Haute",
          reason: "Indique l'utilisation r√©elle vs sp√©culation"
        },
        {
          name: "Puell Multiple",
          description: "Revenus miniers vs moyenne 365j - Timing historique pr√©cis",
          api: "Glassnode",
          priority: "üü° Moyenne",
          reason: "R√©v√®le les zones d'accumulation/distribution"
        },
        {
          name: "RHODL Ratio",
          description: "Realized HODL Ratio - Comportement des HODLers",
          api: "Glassnode",
          priority: "üî• Haute",
          reason: "Pr√©dit les mouvements de march√© via analyse de cohortes"
        },
        {
          name: "Stock-to-Flow Deviation",
          description: "√âcart entre prix r√©el et mod√®le S2F",
          api: "Custom calculation",
          priority: "üü° Moyenne",
          reason: "Compl√©ment au mod√®le de raret√©"
        },
        {
          name: "Fear & Greed Index",
          description: "Sentiment de march√© agr√©g√©",
          api: "Alternative.me",
          priority: "üü¢ Faible",
          reason: "Indicateur contrarian pour les extr√™mes"
        }
      ];

      container.innerHTML = indicators.map(ind => `
        <div class="metric good" style="display: block; margin: 1rem 0;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
            <strong>${ind.name}</strong>
            <span style="font-size: 0.9em;">${ind.priority}</span>
          </div>
          <div style="font-size: 0.9em; margin: 0.3rem 0;">
            üìä ${ind.description}
          </div>
          <div style="font-size: 0.8em; color: #666;">
            üîó API: ${ind.api} | üí° ${ind.reason}
          </div>
        </div>
      `).join('');
    }

    // Fonctions principales
    window.runFullAnalysis = async function () {
      document.getElementById('analysis-results').innerHTML = '<div class="metric good"><strong>üöÄ Lancement de l\'analyse compl√®te...</strong></div>';

      // Charger les modules si pas encore fait
      if (!moduleLoaded) {
        const loaded = await loadModules();
        if (!loaded) return;
      }

      setTimeout(() => {
        try {
          const metrics = calculatePrecisionMetrics();
          createValidationChart();
          populateErrorTable();
          showIndicatorsSuggestions();

          addResult('‚úÖ Analyse Termin√©e', 'Toutes les m√©triques calcul√©es', 'good');
          addResult('üéØ Pr√©cision Globale', `${metrics.overallAccuracy.toFixed(1)}%`,
            metrics.overallAccuracy > 75 ? 'good' : 'warning');
          addResult('üìä Cycles Valid√©s', `${metrics.completedCycles.length} cycles historiques analys√©s`, 'good');

          if (metrics.overallAccuracy < 70) {
            addResult('‚ö†Ô∏è Recommandation', 'Pr√©cision faible - Consid√©rer une recalibration', 'warning');
          }
        } catch (error) {
          console.error('Error in runFullAnalysis:', error);
          addResult('‚ùå Erreur', `Erreur d'analyse: ${error.message}`, 'error');
        }
      }, 500);
    };

    window.calibrateModel = async function () {
      addResult('‚öôÔ∏è Calibration', 'Recalibration du mod√®le en cours...', 'warning');

      if (!moduleLoaded) {
        const loaded = await loadModules();
        if (!loaded) return;
      }

      setTimeout(() => {
        try {
          const result = calibrateCycleParams();
          addResult('‚úÖ Calibration OK', `Score d'erreur: ${result.score.toFixed(2)}`, 'good');

          // Sauvegarder les nouveaux param√®tres
          saveCalibrationParams(result.params);
          addResult('üíæ Sauvegarde', 'Param√®tres calibr√©s sauvegard√©s automatiquement', 'good');

          // Recalculer les m√©triques apr√®s calibration
          const metrics = calculatePrecisionMetrics();
          addResult('üìà Nouvelle Pr√©cision', `${metrics.overallAccuracy.toFixed(1)}%`, 'good');

          // Recr√©er le graphique
          createValidationChart();
          populateErrorTable();
          
          // Notifier les autres pages (si ouvertes)
          window.postMessage({
            type: 'CYCLE_PARAMS_UPDATED',
            params: result.params,
            timestamp: Date.now()
          }, '*');
          
        } catch (error) {
          addResult('‚ùå Erreur', `Erreur de calibration: ${error.message}`, 'error');
        }
      }, 1000);
    };

    window.testAlternatives = function () {
      addResult('üß™ Test Alternatives', 'Test de fonctions alternatives en cours...', 'warning');

      // Simuler le test d'alternatives (Gompertz, Logistique modifi√©e, etc.)
      setTimeout(() => {
        const alternatives = [
          { name: 'Gompertz', precision: 78.5, params: 'a=100, b=0.8, c=0.15' },
          { name: 'Logistique Double', precision: 82.1, params: 'k1=1.2, k2=0.9, x0=18' },
          { name: 'Weibull Modifi√©e', precision: 79.3, params: 'Œ±=2.1, Œ≤=24, Œ≥=0.1' },
          { name: 'Sigmo√Øde Actuel', precision: moduleLoaded ? calculatePrecisionMetrics().overallAccuracy : 75.0, params: 'Param√®tres actuels' }
        ];

        const best = alternatives.reduce((a, b) => a.precision > b.precision ? a : b);

        alternatives.forEach(alt => {
          addResult(`üìä ${alt.name}`, `Pr√©cision: ${alt.precision.toFixed(1)}% (${alt.params})`,
            alt === best ? 'good' : 'info');
        });

        addResult('üèÜ Meilleur Mod√®le', `${best.name} avec ${best.precision.toFixed(1)}% de pr√©cision`, 'good');
      }, 1500);
    };

    window.generateReport = function () {
      const metrics = moduleLoaded ? calculatePrecisionMetrics() : { overallAccuracy: 0, completedCycles: [], avgPeakError: 0, avgBottomError: 0 };
      const report = `
# üìä Rapport d'Analyse Bitcoin Cycle Model

## R√©sum√© Ex√©cutif
- **Pr√©cision Globale**: ${metrics.overallAccuracy.toFixed(1)}%
- **Cycles Analys√©s**: ${metrics.completedCycles.length}/3 cycles complets
- **Erreur Moyenne Pics**: ${metrics.avgPeakError.toFixed(1)} points
- **Erreur Moyenne Creux**: ${metrics.avgBottomError.toFixed(1)} points

## Recommandations
${metrics.overallAccuracy > 80 ? '‚úÖ Mod√®le performant - Maintenir param√®tres actuels' : '‚ö†Ô∏è Pr√©cision insuffisante - Recalibration recommand√©e'}

## Indicateurs Compl√©mentaires Sugg√©r√©s
1. MVRV Ratio (Haute priorit√©)
2. NVT Ratio (Haute priorit√©) 
3. RHODL Ratio (Haute priorit√©)

Rapport g√©n√©r√© le ${new Date().toLocaleString('fr-FR')}
      `;

      // Cr√©er et t√©l√©charger le rapport
      const blob = new Blob([report], { type: 'text/markdown' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `bitcoin-cycle-analysis-${Date.now()}.md`;
      a.click();
      URL.revokeObjectURL(url);

      addResult('üìã Rapport G√©n√©r√©', 'Rapport t√©l√©charg√© avec succ√®s', 'good');
    };

    // Initialisation
    document.addEventListener('DOMContentLoaded', async () => {
      // Charger les modules d'abord
      await loadModules();

      // Puis lancer l'analyse si les modules sont charg√©s
      if (moduleLoaded) {
        setTimeout(runFullAnalysis, 1000);
      }
    });
  </script>
</body>

</html>