<!DOCTYPE html>
<html lang="fr">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Unified AI Dashboard - Crypto Rebalancer</title>
  <link rel="stylesheet" href="shared-theme.css">
  <link rel="stylesheet" href="theme-compat.css">
  <script type="module" src="components/nav.js"></script>

  <script src="debug-logger.js"></script>
  <script src="performance-optimizer.js"></script>
  <script src="global-config.js"></script>
  <script src="appearance.js"></script>
  
  <!-- Chart.js for advanced visualizations -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
  
  <style>
    /* Masque l'ancien en-t√™te statique, remplac√© par nav.js */
    body > header { display: none; }
    * {
      box-sizing: border-box
    }

    body {
      margin: 0;
      background: var(--theme-background);
      color: var(--theme-text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif
    }

    header {
      position: sticky;
      top: 0;
      background: var(--theme-surface-elevated);
      backdrop-filter: blur(6px);
      border-bottom: 1px solid var(--theme-border);
      z-index: 10
    }

    .wrap {
      max-width: 95vw;
      margin: 0 auto;
      padding: 16px
    }

    h1 {
      margin: 0 0 8px 0;
      font-size: 24px;
      font-weight: 800
    }

    h2 {
      margin: 0 0 12px 0;
      font-size: 18px;
      font-weight: 600
    }

    h3 {
      margin: 0 0 8px 0;
      font-size: 16px;
      font-weight: 600
    }

    .nav {
      display: flex;
      gap: 12px;
      margin: 12px 0;
      flex-wrap: wrap
    }

    .nav a {
      padding: 8px 16px;
      border-radius: 8px;
      text-decoration: none;
      color: var(--theme-text-muted);
      border: 1px solid var(--theme-border);
      transition: all 0.2s
    }

    .nav a.active,
    .nav a:hover {
      background: var(--brand-primary);
      color: white;
      border-color: var(--brand-primary)
    }

    .dashboard-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
      gap: 20px;
      margin: 20px 0
    }

    .card {
      background: var(--theme-surface);
      border: 1px solid var(--theme-border);
      border-radius: var(--radius-lg);
      padding: var(--space-xl);
      margin-bottom: var(--space-lg)
    }

    .card.success {
      border-color: var(--success);
      background: var(--success-bg)
    }

    .card.warning {
      border-color: var(--warning);
      background: var(--warning-bg)
    }

    .card.error {
      border-color: var(--error);
      background: var(--error-bg)
    }

    .status-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 12px;
      margin: 16px 0
    }

    .status-item {
      padding: 12px;
      background: var(--theme-surface-muted);
      border-radius: 8px;
      text-align: center;
      border: 1px solid var(--theme-border)
    }

    .status-value {
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 4px
    }

    .status-label {
      font-size: 12px;
      color: var(--theme-text-muted)
    }

    .btn {
      padding: 8px 16px;
      border: 1px solid var(--theme-border);
      background: var(--theme-surface);
      color: var(--theme-text);
      border-radius: 6px;
      cursor: pointer;
      text-decoration: none;
      display: inline-block;
      margin: 4px;
      transition: all 0.2s
    }

    .btn.primary {
      background: var(--brand-primary);
      color: white;
      border-color: var(--brand-primary)
    }

    .btn.secondary {
      background: var(--theme-surface-muted)
    }

    .btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1)
    }

    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none
    }

    .loading {
      text-align: center;
      padding: 40px;
      color: var(--theme-text-muted)
    }

    .prediction-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 12px;
      margin: 16px 0
    }

    .prediction-item {
      padding: 16px;
      background: var(--theme-surface-muted);
      border-radius: 8px;
      border: 1px solid var(--theme-border)
    }

    .prediction-symbol {
      font-weight: 600;
      font-size: 14px;
      margin-bottom: 8px;
      color: var(--brand-primary)
    }

    .prediction-value {
      font-size: 18px;
      font-weight: 700;
      margin-bottom: 4px
    }

    .prediction-confidence {
      font-size: 12px;
      color: var(--theme-text-muted)
    }

    .chart-container {
      position: relative;
      height: 300px;
      margin: 20px 0
    }

    .data-source-indicator {
      position: absolute;
      top: 16px;
      right: 16px;
      padding: 4px 8px;
      background: var(--theme-surface-elevated);
      border: 1px solid var(--theme-border);
      border-radius: 4px;
      font-size: 12px;
      color: var(--theme-text-muted)
    }

    .model-status-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 12px;
      margin: 16px 0
    }

    .model-status {
      padding: 12px;
      background: var(--theme-surface-muted);
      border-radius: 8px;
      border: 1px solid var(--theme-border);
      text-align: center
    }

    .model-status.ready {
      border-color: var(--success);
      background: var(--success-bg)
    }

    .model-status.training {
      border-color: var(--warning);
      background: var(--warning-bg)
    }

    .model-status.failed {
      border-color: var(--error);
      background: var(--error-bg)
    }

    .actions-bar {
      display: flex;
      gap: 12px;
      margin: 16px 0;
      flex-wrap: wrap;
      align-items: center
    }

    .alert {
      padding: 12px;
      border-radius: 8px;
      margin: 8px 0;
      border: 1px solid transparent
    }

    .alert.info {
      background: var(--info-bg);
      border-color: var(--info);
      color: var(--info)
    }

    .alert.warning {
      background: var(--warning-bg);
      border-color: var(--warning);
      color: var(--warning)
    }

    .alert.error {
      background: var(--error-bg);
      border-color: var(--error);
      color: var(--error)
    }

    .ensemble-prediction {
      background: linear-gradient(135deg, var(--brand-primary), var(--brand-secondary));
      color: white;
      border: none;
      padding: 20px;
      border-radius: 12px;
      text-align: center;
      margin: 16px 0
    }

    .ensemble-title {
      font-size: 16px;
      font-weight: 600;
      margin-bottom: 8px
    }

    .ensemble-recommendation {
      font-size: 18px;
      font-weight: 700;
      margin-bottom: 8px
    }

    .ensemble-confidence {
      font-size: 14px;
      opacity: 0.9
    }

    @media (max-width: 768px) {
      .dashboard-grid {
        grid-template-columns: 1fr;
        gap: 16px
      }
      
      .nav {
        justify-content: center
      }
      
      .actions-bar {
        flex-direction: column;
        align-items: stretch
      }
    }
  </style>
</head>

<body>
  <header>
    <div class="wrap">
      <h1>ü§ñ Unified AI Dashboard</h1>
      <div class="nav">
        <a href="dashboard.html">Dashboard</a>
        <a href="risk-dashboard.html">Risk Analysis</a>
        <a href="rebalance.html">Rebalancing</a>
        <a href="ai-unified-dashboard.html" class="active">AI Unified</a>
        <a href="settings.html">Settings</a>
      </div>
    </div>
  </header>

  <main class="wrap">
    <!-- Data Source Indicator -->
    <div class="data-source-indicator" id="dataSourceIndicator">
      Data Source: Loading...
    </div>

    <!-- System Status Overview -->
    <div class="card" id="systemStatus">
      <h2>üöÄ ML System Status</h2>
      <div class="status-grid">
        <div class="status-item">
          <div class="status-value" id="modelsReady">-</div>
          <div class="status-label">Models Ready</div>
        </div>
        <div class="status-item">
          <div class="status-value" id="dataSource">-</div>
          <div class="status-label">Data Source</div>
        </div>
        <div class="status-item">
          <div class="status-value" id="systemHealth">-</div>
          <div class="status-label">System Health</div>
        </div>
        <div class="status-item">
          <div class="status-value" id="lastUpdate">-</div>
          <div class="status-label">Last Update</div>
        </div>
      </div>

      <div class="actions-bar">
        <button class="btn primary" onclick="initializeMLSystem()">üîÑ Initialize System</button>
        <button class="btn secondary" onclick="retrainModels()">‚ö° Retrain Models</button>
        <button class="btn secondary" onclick="refreshPredictions()">üìä Refresh Predictions</button>
        <button class="btn secondary" onclick="clearCaches()">üóëÔ∏è Clear Caches</button>
      </div>
    </div>

    <!-- Ensemble Predictions -->
    <div class="ensemble-prediction" id="ensemblePrediction" style="display: none;">
      <div class="ensemble-title">üéØ Ensemble Prediction</div>
      <div class="ensemble-recommendation" id="ensembleRecommendation">Loading...</div>
      <div class="ensemble-confidence" id="ensembleConfidence">Confidence: --%</div>
    </div>

    <!-- Model Status Grid -->
    <div class="card">
      <h2>üß† Model Status</h2>
      <div class="model-status-grid" id="modelStatusGrid">
        <div class="loading">Loading model status...</div>
      </div>
    </div>

    <!-- Dashboard Grid -->
    <div class="dashboard-grid">
      
      <!-- Volatility Predictions -->
      <div class="card">
        <h3>üìà Volatility Predictions</h3>
        <div class="prediction-grid" id="volatilityPredictions">
          <div class="loading">Loading volatility predictions...</div>
        </div>
        <div class="chart-container">
          <canvas id="volatilityChart"></canvas>
        </div>
      </div>

      <!-- Sentiment Analysis -->
      <div class="card">
        <h3>üí≠ Market Sentiment</h3>
        <div class="prediction-grid" id="sentimentAnalysis">
          <div class="loading">Loading sentiment analysis...</div>
        </div>
        <div class="chart-container">
          <canvas id="sentimentChart"></canvas>
        </div>
      </div>

      <!-- Regime Detection -->
      <div class="card">
        <h3>üéØ Market Regime</h3>
        <div id="regimePrediction" class="loading">Loading regime detection...</div>
        <div class="chart-container">
          <canvas id="regimeChart"></canvas>
        </div>
      </div>

      <!-- Correlation Analysis -->
      <div class="card">
        <h3>üîó Asset Correlations</h3>
        <div id="correlationMatrix" class="loading">Loading correlation analysis...</div>
        <div class="chart-container">
          <canvas id="correlationChart"></canvas>
        </div>
      </div>

    </div>

    <!-- Alerts and Notifications -->
    <div id="alertsContainer"></div>

    <!-- Debug Information -->
    <div class="card" id="debugInfo" style="display: none;">
      <h3>üîç Debug Information</h3>
      <pre id="debugOutput">No debug data available</pre>
      <div class="actions-bar">
        <button class="btn secondary" onclick="toggleDebug()">Toggle Debug</button>
        <button class="btn secondary" onclick="exportDebugData()">Export Debug Data</button>
      </div>
    </div>

  </main>

  <script>
    // Global variables
    let mlSystemStatus = null;
    let currentPredictions = null;
    let debugMode = false;
    let charts = {};
    
    // Initialize dashboard
    document.addEventListener('DOMContentLoaded', async function() {
      try {
        await loadGlobalConfig();
        await initializeDashboard();
        
        // Set up periodic updates
        setInterval(refreshStatus, 30000); // Every 30 seconds
        setInterval(refreshPredictions, 300000); // Every 5 minutes
        
        // Monitor configuration changes from other tabs/pages
        setInterval(async () => {
          const currentConfig = globalConfig.getAll();
          if (!window.lastSyncedConfig || window.lastSyncedConfig.data_source !== currentConfig.data_source) {
            debugLog('Configuration change detected, syncing with backend...');
            await loadGlobalConfig();
            window.lastSyncedConfig = currentConfig;
          }
        }, 5000); // Check every 5 seconds
        
      } catch (error) {
        console.error('Dashboard initialization failed:', error);
        showAlert('Failed to initialize AI dashboard', 'error');
      }
    });
    
    async function loadGlobalConfig() {
      // Load global configuration and apply data source setting
      try {
        // Use the existing globalConfig instance
        const config = globalConfig.getAll();
        
        // Send configuration to backend for synchronization
        try {
          const response = await fetch(`${config.api_base_url}/api/config/data-source`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              data_source: config.data_source
            })
          });
          
          if (response.ok) {
            const result = await response.json();
            debugLog(`Configuration synchronized with backend: ${result.data_source}`);
          }
        } catch (syncError) {
          console.warn('Failed to sync config with backend:', syncError);
        }
        
        // Update data source indicator
        const dataSourceElem = document.getElementById('dataSourceIndicator');
        const sourceLabels = {
          'stub': 'üß™ Test Data',
          'cointracking': 'üìÅ CSV Files',
          'cointracking_api': 'üåê CoinTracking API'
        };
        
        dataSourceElem.textContent = `Data Source: ${sourceLabels[config.data_source] || config.data_source}`;
        
        // Store settings for later use
        window.globalSettings = config;
        
      } catch (error) {
        console.error('Failed to load configuration:', error);
        document.getElementById('dataSourceIndicator').textContent = 'Data Source: Unknown';
        // Set fallback settings
        window.globalSettings = { api_base_url: 'http://127.0.0.1:8000' };
      }
    }
    
    async function initializeDashboard() {
      showAlert('Initializing AI dashboard...', 'info');
      
      try {
        // Load ML system status first
        await refreshStatus();
        
        // Load predictions if system is ready
        if (mlSystemStatus && mlSystemStatus.system_health?.overall_status === 'healthy') {
          await refreshPredictions();
        } else {
          showAlert('ML system not ready. Click "Initialize System" to set up models.', 'warning');
        }
        
      } catch (error) {
        console.error('Dashboard initialization error:', error);
        showAlert('Dashboard initialization completed with warnings', 'warning');
      }
    }
    
    async function refreshStatus() {
      try {
        debugLog('Refreshing ML system status...');
        
        const response = await fetch(`${globalSettings.api_base_url}/api/ml/unified/status`);
        
        if (response.ok) {
          const data = await response.json();
          mlSystemStatus = data.ml_system_status;
          updateSystemStatusUI(mlSystemStatus);
          updateModelStatusGrid(mlSystemStatus.models);
        } else {
          console.error('Failed to fetch ML status:', response.status);
          showAlert('Failed to fetch ML system status', 'error');
        }
        
      } catch (error) {
        console.error('Error refreshing status:', error);
        showAlert('Connection error while checking status', 'error');
      }
    }
    
    async function refreshPredictions() {
      try {
        debugLog('Refreshing ML predictions...');
        
        const response = await fetch(`${globalSettings.api_base_url}/api/ml/unified/predictions`);
        
        if (response.ok) {
          const data = await response.json();
          currentPredictions = data.predictions;
          updatePredictionsUI(currentPredictions);
          updateChartsWithPredictions(currentPredictions);
        } else {
          console.error('Failed to fetch predictions:', response.status);
          showAlert('Failed to fetch ML predictions', 'warning');
        }
        
      } catch (error) {
        console.error('Error refreshing predictions:', error);
        showAlert('Connection error while fetching predictions', 'error');
      }
    }
    
    function updateSystemStatusUI(status) {
      if (!status) return;
      
      // Update status indicators
      document.getElementById('modelsReady').textContent = 
        `${status.system_health?.models_ready || 0}/${status.system_health?.total_models || 0}`;
      
      document.getElementById('dataSource').textContent = status.data_source_config || 'Unknown';
      
      const healthElem = document.getElementById('systemHealth');
      const healthStatus = status.system_health?.overall_status || 'unknown';
      healthElem.textContent = healthStatus.toUpperCase();
      
      // Color code health status
      healthElem.style.color = healthStatus === 'healthy' ? 'var(--success)' : 
                              healthStatus === 'degraded' ? 'var(--warning)' : 'var(--error)';
      
      document.getElementById('lastUpdate').textContent = 
        new Date(status.timestamp).toLocaleTimeString();
    }
    
    function updateModelStatusGrid(models) {
      const container = document.getElementById('modelStatusGrid');
      
      if (!models) {
        container.innerHTML = '<div class="loading">No model data available</div>';
        return;
      }
      
      container.innerHTML = '';
      
      for (const [modelName, modelInfo] of Object.entries(models)) {
        const statusDiv = document.createElement('div');
        statusDiv.className = `model-status ${modelInfo.status}`;
        
        const statusIcon = modelInfo.status === 'ready' ? '‚úÖ' : 
                          modelInfo.status === 'training' ? '‚è≥' : 
                          modelInfo.status === 'failed' ? '‚ùå' : '‚ö™';
        
        statusDiv.innerHTML = `
          <div style="font-weight: 600; margin-bottom: 4px;">
            ${statusIcon} ${modelName.toUpperCase()}
          </div>
          <div style="font-size: 12px; color: var(--theme-text-muted);">
            ${modelInfo.status}
          </div>
          ${modelInfo.last_training ? `
            <div style="font-size: 10px; color: var(--theme-text-muted); margin-top: 4px;">
              Last: ${new Date(modelInfo.last_training).toLocaleDateString()}
            </div>
          ` : ''}
        `;
        
        container.appendChild(statusDiv);
      }
    }
    
    function updatePredictionsUI(predictions) {
      if (!predictions) return;
      
      // Update ensemble prediction
      if (predictions.ensemble) {
        const ensembleDiv = document.getElementById('ensemblePrediction');
        const recommendation = predictions.ensemble.recommended_action || 'maintain';
        const confidence = Math.round((predictions.confidence_scores?.overall || 0) * 100);
        
        document.getElementById('ensembleRecommendation').textContent = 
          recommendation.replace(/_/g, ' ').toUpperCase();
        document.getElementById('ensembleConfidence').textContent = 
          `Confidence: ${confidence}%`;
        
        ensembleDiv.style.display = 'block';
      }
      
      // Update individual model predictions
      updateVolatilityPredictions(predictions.models?.volatility);
      updateSentimentAnalysis(predictions.models?.sentiment);
      updateRegimePrediction(predictions.models?.regime);
      updateCorrelationMatrix(predictions.models?.correlation);
      
      // Show any alerts
      if (predictions.alerts && predictions.alerts.length > 0) {
        predictions.alerts.forEach(alert => {
          showAlert(alert, 'warning');
        });
      }
    }
    
    function updateVolatilityPredictions(volatilityData) {
      const container = document.getElementById('volatilityPredictions');
      
      if (!volatilityData) {
        container.innerHTML = '<div class="loading">No volatility predictions available</div>';
        return;
      }
      
      container.innerHTML = '';
      
      for (const [symbol, predictions] of Object.entries(volatilityData)) {
        for (const [horizon, pred] of Object.entries(predictions)) {
          const predDiv = document.createElement('div');
          predDiv.className = 'prediction-item';
          
          const volatilityPct = Math.round((pred.volatility_forecast || 0) * 100);
          const confidence = Math.round((pred.confidence || 0) * 100);
          
          predDiv.innerHTML = `
            <div class="prediction-symbol">${symbol} (${horizon})</div>
            <div class="prediction-value">${volatilityPct}%</div>
            <div class="prediction-confidence">Confidence: ${confidence}%</div>
          `;
          
          container.appendChild(predDiv);
        }
      }
    }
    
    function updateSentimentAnalysis(sentimentData) {
      const container = document.getElementById('sentimentAnalysis');
      
      if (!sentimentData) {
        container.innerHTML = '<div class="loading">No sentiment data available</div>';
        return;
      }
      
      container.innerHTML = '';
      
      for (const [symbol, sentiment] of Object.entries(sentimentData)) {
        const sentDiv = document.createElement('div');
        sentDiv.className = 'prediction-item';
        
        const score = Math.round((sentiment.sentiment_score || 0) * 100);
        const scoreColor = score > 60 ? 'var(--success)' : score < 40 ? 'var(--error)' : 'var(--warning)';
        
        sentDiv.innerHTML = `
          <div class="prediction-symbol">${symbol}</div>
          <div class="prediction-value" style="color: ${scoreColor}">${score}/100</div>
          <div class="prediction-confidence">${sentiment.news_sentiment || 'neutral'}</div>
        `;
        
        container.appendChild(sentDiv);
      }
    }
    
    function updateRegimePrediction(regimeData) {
      const container = document.getElementById('regimePrediction');
      
      if (!regimeData) {
        container.innerHTML = '<div class="loading">No regime prediction available</div>';
        return;
      }
      
      const regime = regimeData.current_regime || 'unknown';
      const probability = Math.round((regimeData.regime_probability || 0) * 100);
      const stability = Math.round((regimeData.regime_stability || 0) * 100);
      
      const regimeEmojis = {
        bull_market: 'üêÇ',
        bear_market: 'üêª',
        accumulation: 'üìà',
        distribution: 'üìâ',
        sideways: '‚ÜîÔ∏è'
      };
      
      container.innerHTML = `
        <div style="text-align: center; padding: 20px;">
          <div style="font-size: 48px; margin-bottom: 12px;">
            ${regimeEmojis[regime] || '‚ùì'}
          </div>
          <div style="font-size: 18px; font-weight: 600; margin-bottom: 8px;">
            ${regime.replace(/_/g, ' ').toUpperCase()}
          </div>
          <div style="font-size: 14px; color: var(--theme-text-muted);">
            Probability: ${probability}% | Stability: ${stability}%
          </div>
          ${regimeData.expected_duration_days ? `
            <div style="font-size: 12px; color: var(--theme-text-muted); margin-top: 8px;">
              Expected Duration: ${regimeData.expected_duration_days} days
            </div>
          ` : ''}
        </div>
      `;
    }
    
    function updateCorrelationMatrix(correlationData) {
      const container = document.getElementById('correlationMatrix');
      
      if (!correlationData) {
        container.innerHTML = '<div class="loading">No correlation data available</div>';
        return;
      }
      
      container.innerHTML = '';
      
      // Create simple correlation display
      for (const [pair, corr] of Object.entries(correlationData)) {
        const corrDiv = document.createElement('div');
        corrDiv.className = 'prediction-item';
        
        const corrValue = Math.round((corr.current_correlation || 0) * 100);
        const trend = corr.correlation_trend || 'stable';
        const trendEmoji = trend === 'increasing' ? 'üìà' : trend === 'decreasing' ? 'üìâ' : '‚û°Ô∏è';
        
        corrDiv.innerHTML = `
          <div class="prediction-symbol">${pair}</div>
          <div class="prediction-value">${corrValue}%</div>
          <div class="prediction-confidence">${trendEmoji} ${trend}</div>
        `;
        
        container.appendChild(corrDiv);
      }
    }
    
    function updateChartsWithPredictions(predictions) {
      // This would create/update Chart.js visualizations
      // For now, we'll keep it simple and just log
      debugLog('Chart update not implemented yet', predictions);
    }
    
    async function initializeMLSystem() {
      showAlert('Initializing ML system...', 'info');
      
      try {
        const response = await fetch(`${globalSettings.api_base_url}/api/ml/initialize`, {
          method: 'POST'
        });
        
        if (response.ok) {
          const data = await response.json();
          showAlert('ML system initialization started in background', 'info');
          
          // Refresh status after a short delay
          setTimeout(refreshStatus, 5000);
        } else {
          const error = await response.json();
          showAlert(`Failed to initialize ML system: ${error.detail}`, 'error');
        }
        
      } catch (error) {
        console.error('Error initializing ML system:', error);
        showAlert('Connection error during initialization', 'error');
      }
    }
    
    async function retrainModels() {
      if (!confirm('This will retrain all ML models and may take several minutes. Continue?')) {
        return;
      }
      
      showAlert('Starting model retraining...', 'info');
      
      try {
        const response = await fetch(`${globalSettings.api_base_url}/api/ml/unified/retrain`, {
          method: 'POST'
        });
        
        if (response.ok) {
          const data = await response.json();
          showAlert('Model retraining started in background', 'info');
          
          // Refresh status periodically during retraining
          const recheckInterval = setInterval(async () => {
            await refreshStatus();
            if (mlSystemStatus?.system_health?.overall_status === 'healthy') {
              clearInterval(recheckInterval);
              showAlert('Model retraining completed successfully', 'info');
              await refreshPredictions();
            }
          }, 10000);
          
          // Stop checking after 30 minutes
          setTimeout(() => clearInterval(recheckInterval), 1800000);
          
        } else {
          const error = await response.json();
          showAlert(`Failed to start retraining: ${error.detail}`, 'error');
        }
        
      } catch (error) {
        console.error('Error retraining models:', error);
        showAlert('Connection error during retraining', 'error');
      }
    }
    
    async function clearCaches() {
      if (!confirm('This will clear all ML caches. Continue?')) {
        return;
      }
      
      try {
        const response = await fetch(`${globalSettings.api_base_url}/api/ml/unified/clear-caches`, {
          method: 'DELETE'
        });
        
        if (response.ok) {
          const data = await response.json();
          showAlert('ML caches cleared successfully', 'info');
          await refreshStatus();
        } else {
          const error = await response.json();
          showAlert(`Failed to clear caches: ${error.detail}`, 'error');
        }
        
      } catch (error) {
        console.error('Error clearing caches:', error);
        showAlert('Connection error while clearing caches', 'error');
      }
    }
    
    function toggleDebug() {
      debugMode = !debugMode;
      const debugDiv = document.getElementById('debugInfo');
      debugDiv.style.display = debugMode ? 'block' : 'none';
      
      if (debugMode) {
        document.getElementById('debugOutput').textContent = 
          JSON.stringify({
            mlSystemStatus,
            currentPredictions
          }, null, 2);
      }
    }
    
    function exportDebugData() {
      const debugData = {
        timestamp: new Date().toISOString(),
        mlSystemStatus,
        currentPredictions,
        globalConfig: globalSettings
      };
      
      const blob = new Blob([JSON.stringify(debugData, null, 2)], {
        type: 'application/json'
      });
      
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `ai-dashboard-debug-${new Date().toISOString().slice(0, 10)}.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }
    
    function showAlert(message, type = 'info') {
      const container = document.getElementById('alertsContainer');
      const alert = document.createElement('div');
      alert.className = `alert ${type}`;
      alert.textContent = message;
      
      container.appendChild(alert);
      
      // Remove alert after 5 seconds
      setTimeout(() => {
        if (alert.parentNode) {
          alert.parentNode.removeChild(alert);
        }
      }, 5000);
    }
    
    function debugLog(...args) {
      if (debugMode) {
        console.log('[AI Dashboard]', ...args);
      }
    }
  </script>
</body>

</html>
