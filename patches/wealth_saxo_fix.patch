--- a/api/wealth_endpoints.py
+++ b/api/wealth_endpoints.py
@@
-from fastapi import APIRouter, Depends, Query
+from fastapi import APIRouter, Depends, Query
+import logging
+from typing import List
+from adapters import saxo_adapter, crypto_adapter, banks_adapter
+
+logger = logging.getLogger(__name__)
 
 router = APIRouter(prefix="/api/wealth", tags=["wealth"])
 
@@
-@router.get("/modules")
-def list_modules():
-    # ancien code: ne renvoyait que ce qui était déjà branché
-    return ["crypto"]
+@router.get("/modules")
+def list_modules(user: str = "default") -> List[str]:
+    """
+    Expose les modules disponibles. On considère 'disponible' si :
+    - l'adapter existe ET (des fichiers sont présents OU l'adapter se déclare disponible)
+    - on inclut 'crypto' par défaut si le pipeline est branché
+    """
+    mods: List[str] = []
+    try:
+        # Crypto: généralement toujours disponible si pipeline existant
+        if getattr(crypto_adapter, "is_available", None):
+            if crypto_adapter.is_available(user):
+                mods.append("crypto")
+        else:
+            mods.append("crypto")
+    except Exception as e:
+        logger.warning("[wealth] crypto availability check failed: %s", e)
+    try:
+        if getattr(saxo_adapter, "is_available", None) and saxo_adapter.is_available(user):
+            mods.append("saxo")
+    except Exception as e:
+        logger.info("[wealth] saxo not available: %s", e)
+    try:
+        if getattr(banks_adapter, "is_available", None) and banks_adapter.is_available(user):
+            mods.append("banks")
+    except Exception as e:
+        logger.info("[wealth] banks not available: %s", e)
+    return mods
 
@@
-@router.get("/{module}/prices")
-def get_prices(module: str, ids: str = Query(default=""), granularity: str = Query(default="daily")):
-    id_list = [s for s in ids.split(",") if s]
-    return pricing_service.get_prices(id_list, granularity=granularity)
+@router.get("/{module}/prices")
+def get_prices(module: str, ids: str = Query(default=""), granularity: str = Query(default="daily"), user: str = "default"):
+    """
+    Accepte soit des instrument_id, soit des symbols (ex: BTC, ETH) pour le module 'crypto'.
+    On résout symbol -> instrument_id via l'index des instruments.
+    """
+    raw_ids = [s.strip() for s in ids.split(",") if s.strip()]
+    id_list = raw_ids[:]
+    if module.lower() == "crypto" and raw_ids:
+        try:
+            instruments = crypto_adapter.list_instruments(user)
+            sym_to_id = { (ins["symbol"] or "").upper(): ins["id"] for ins in instruments if "symbol" in ins and "id" in ins }
+            mapped = [ sym_to_id.get(tok.upper(), tok) for tok in raw_ids ]
+            id_list = mapped
+        except Exception as e:
+            logger.info("[wealth] symbol->id resolution skipped (crypto): %s", e)
+    return pricing_service.get_prices(id_list, granularity=granularity)
