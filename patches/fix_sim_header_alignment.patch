diff --git a/static/modules/simulation-engine.js b/static/modules/simulation-engine.js
index e503577..6727fbe 100644
--- a/static/modules/simulation-engine.js
+++ b/static/modules/simulation-engine.js
@@ -36,9 +36,8 @@ async function loadContradictionModules() {
 }
 
 // Fallbacks simples pour les modules
-const store = {
+const fallbackStore = {
   get: (path) => {
-    // Simuler des valeurs par d√©faut
     if (path === 'scores.onchain') return 50;
     if (path === 'scores.risk') return 50;
     if (path === 'scores.blended') return 50;
@@ -51,10 +50,50 @@ const store = {
   snapshot: () => ({
     scores: { onchain: 50, risk: 50, blended: 50, cycle: 50 },
     wallet: { balances: [], total: 0 },
-    cycle: { months: 18, phase: 'expansion', score: 50 }
+    cycle: { months: 18, phase: 'expansion', score: 50 },
+    governance: null
   })
 };
 
+function resolveGlobalStore() {
+  if (typeof window !== 'undefined') {
+    if (window.store) return window.store;
+    if (window.__store) return window.__store;
+    if (window.riskStore) return window.riskStore;
+  }
+  if (typeof globalThis !== 'undefined' && globalThis.store) {
+    return globalThis.store;
+  }
+  return null;
+}
+
+const store = {
+  get(path) {
+    const globalStore = resolveGlobalStore();
+    if (globalStore && typeof globalStore.get === 'function') {
+      const value = globalStore.get(path);
+      if (value !== undefined && value !== null) {
+        return value;
+      }
+    }
+    return fallbackStore.get(path);
+  },
+  set(path, value) {
+    const globalStore = resolveGlobalStore();
+    if (globalStore && typeof globalStore.set === 'function') {
+      return globalStore.set(path, value);
+    }
+    return fallbackStore.set(path, value);
+  },
+  snapshot() {
+    const globalStore = resolveGlobalStore();
+    if (globalStore && typeof globalStore.snapshot === 'function') {
+      return globalStore.snapshot();
+    }
+    return fallbackStore.snapshot();
+  }
+};
+
 const getRegimeDisplayData = () => null;
 const analyzeContradictorySignals = () => [];
 const estimateCyclePosition = () => ({ months: 18, score: 50, phase: 'expansion' });
@@ -302,6 +341,7 @@ export async function initSimulation({ sourceId }) {
  * Charge le snapshot depuis la source (m√™me logique qu'Analytics Unified)
  */
 async function loadSourceSnapshot(sourceId) {
+  const storeSnapshot = typeof store.snapshot === 'function' ? store.snapshot() : null;
   // R√©utiliser la logique de chargement d'analytics-unified.html
   if (typeof window.loadBalanceData === 'function') {
     try {
@@ -323,7 +363,8 @@ async function loadSourceSnapshot(sourceId) {
             months: store.get('cycle.months'),
             phase: store.get('cycle.phase'),
             score: store.get('cycle.score')
-          }
+          },
+          governance: storeSnapshot ? storeSnapshot.governance : null
         };
       }
     } catch (error) {
@@ -332,7 +373,6 @@ async function loadSourceSnapshot(sourceId) {
   }
 
   // Fallback: utiliser le store actuel ou donn√©es simul√©es
-  const storeSnapshot = store.snapshot();
   return {
     wallet: storeSnapshot.wallet || {
       balances: [
@@ -351,7 +391,8 @@ async function loadSourceSnapshot(sourceId) {
       cycle: 50
     },
     regime: storeSnapshot.market?.regime,
-    cycle: storeSnapshot.cycle || { months: 18, phase: 'expansion', score: 50 }
+    cycle: storeSnapshot.cycle || { months: 18, phase: 'expansion', score: 50 },
+    governance: storeSnapshot ? storeSnapshot.governance : null
   };
 }
 
@@ -1059,7 +1100,8 @@ export async function simulateFullPipeline(uiOverrides = {}) {
     simulationState.smoothState.persistCount = sm.persistCount;
 
     // Construire √©tat unifi√© pour engine + donn√©es governance utiles
-    const governanceSource = simulationState.sourceData?.governance ?? {};
+    const globalStoreSnapshot = store.snapshot();
+    const governanceSource = (globalStoreSnapshot && globalStoreSnapshot.governance) ? globalStoreSnapshot.governance : (simulationState.sourceData?.governance ?? {});
 
     const takeNumber = (...values) => {
       for (const value of values) {
diff --git a/static/selectors/governance.js b/static/selectors/governance.js
index 62af10c..e611023 100644
--- a/static/selectors/governance.js
+++ b/static/selectors/governance.js
@@ -113,6 +113,30 @@ export function selectCapPercent(state) {
   return null;
 }
 
+export function selectFreshness(state) {
+  try {
+    const iso = state?.ml_signals_timestamp;
+    const ttlRaw = state?.governance?.active_policy?.signals_ttl_seconds;
+    const ttlSeconds = Number.isFinite(ttlRaw) ? ttlRaw : 1800;
+
+    if (!iso) {
+      return { stale: true, updatedAtIso: null, ageSec: null };
+    }
+
+    const parsed = Date.parse(iso);
+    if (Number.isNaN(parsed)) {
+      return { stale: true, updatedAtIso: iso, ageSec: null };
+    }
+
+    const ageSec = Math.max(0, Math.floor((Date.now() - parsed) / 1000));
+    return { stale: ageSec > ttlSeconds, updatedAtIso: iso, ageSec };
+  } catch (error) {
+    console.debug('selectFreshness failed', error);
+    return { stale: true, updatedAtIso: null, ageSec: null };
+  }
+}
+
+
 /**
  * S√©lecteur pour le cap effectif (garde-fous 5%/8%, alert override, puis policy>engine)
  * @param {Object} state - √âtat unifi√©
diff --git a/static/simulations.html b/static/simulations.html
index 3aefb0f..0e3b6dd 100644
--- a/static/simulations.html
+++ b/static/simulations.html
@@ -307,6 +307,40 @@
       overflow-y: auto;
     }
 
+    .caps-triggered {
+      margin-top: var(--space-sm);
+      padding: calc(var(--space-sm) * 0.75);
+      background: color-mix(in srgb, var(--warning) 18%, transparent);
+      border: 1px solid color-mix(in srgb, var(--warning) 35%, transparent);
+      border-radius: var(--radius-md, 8px);
+      font-size: 0.85rem;
+      color: var(--theme-text);
+    }
+
+    .caps-triggered-summary {
+      font-weight: 600;
+      display: flex;
+      align-items: center;
+      gap: var(--space-xs);
+      margin-bottom: var(--space-xs);
+    }
+
+    .caps-triggered ul {
+      margin: 0;
+      padding-left: 1.1rem;
+      display: grid;
+      gap: 0.35rem;
+    }
+
+    .caps-triggered li {
+      list-style: disc;
+      color: var(--theme-text-muted);
+    }
+
+    .caps-triggered li strong {
+      color: var(--theme-text);
+    }
+
     .order-item {
       display: flex;
       justify-content: space-between;
@@ -657,6 +691,7 @@
                   <span id="sim-exec-status" class="status-badge">--</span>
                 </div>
               </div>
+              <div id="sim-caps-triggered" class="caps-triggered" aria-live="polite"></div>
               <div id="sim-orders-list" class="orders-list">
                 <!-- Ordres g√©n√©r√©s dynamiquement -->
               </div>
@@ -691,10 +726,10 @@
     import { SimControls } from './components/SimControls.js';
     import { SimInspector } from './components/SimInspector.js';
     import * as SimEngine from './modules/simulation-engine.js';
+    import { store as governanceStore } from './core/risk-dashboard-store.js';
 
     // S√©lecteurs & policy
-    import { selectContradictionPct, selectContradiction01, selectCapPercent } from './selectors/governance.js';
-    import { classifyContradiction } from './governance/contradiction-policy.js';
+    import { selectCapPercent, selectFreshness } from './selectors/governance.js';
 
     // Badges UI
     import { renderBadges } from './components/Badges.js';
@@ -753,6 +788,12 @@
     });
 
     async function initializeSimulator() {
+      try {
+        await governanceStore.syncGovernanceState();
+      } catch (error) {
+        console.warn('üé≠ SIM: governance sync failed', error);
+      }
+
       // Initialiser les composants
       appState.controls = new SimControls('sim-controls', onControlsUpdate);
       appState.inspector = new SimInspector('sim-inspector');
@@ -917,24 +958,71 @@
     }
 
     function displayResults(result) {
-      const { di, riskBudget, cappedTargets, orders, explanation } = result;
+      const { di, riskBudget, cappedTargets, capsTriggered = [], orders, explanation } = result;
 
       // Affichage badges dans le header des r√©sultats
       const stateForEngine = result?.ui?.stateForEngine ?? null;
+      const timestampCandidates = [
+        stateForEngine?.ml_signals_timestamp,
+        stateForEngine?.governance?.ml_signals_timestamp,
+        stateForEngine?.governance?.updated_at,
+        result?.context?.governance?.ml_signals_timestamp,
+        result?.context?.governance?.updated_at
+      ].filter(Boolean);
+      const canonicalTimestamp = timestampCandidates.length > 0 ? timestampCandidates[0] : null;
+      const freshnessInput = stateForEngine
+        ? { ...stateForEngine, ml_signals_timestamp: canonicalTimestamp ?? stateForEngine.ml_signals_timestamp ?? null }
+        : { ml_signals_timestamp: canonicalTimestamp ?? null, governance: result?.context?.governance ?? null };
+      const { stale, updatedAtIso } = selectFreshness(freshnessInput);
+      const resolvedUpdatedIso = updatedAtIso || canonicalTimestamp || null;
       const capPercent = stateForEngine ? selectCapPercent(stateForEngine) : null;
+      const contradictionRaw = stateForEngine?.governance?.contradiction_index ??
+        stateForEngine?.contradiction_index ??
+        result?.context?.governance?.contradiction_index ?? null;
+      let contradictionPctOverride = null;
+      if (typeof contradictionRaw === 'number' && Number.isFinite(contradictionRaw)) {
+        const normalized = contradictionRaw > 1 ? contradictionRaw / 100 : contradictionRaw;
+        const clamped = Math.max(0, Math.min(1, normalized));
+        contradictionPctOverride = Math.round(clamped * 100);
+      }
       try {
-        const badgeProps = {};
-        if (capPercent != null) {
-          badgeProps.cap = capPercent;
+        const badgeContainer = document.querySelector('#badges-sim');
+        if (badgeContainer) {
+          const badgeProps = { status: stale ? 'stale' : 'healthy' };
+          if (resolvedUpdatedIso) {
+            badgeProps.updated = resolvedUpdatedIso;
+          }
+          if (Number.isFinite(capPercent)) {
+            badgeProps.cap = capPercent;
+          }
+          if (Number.isFinite(contradictionPctOverride)) {
+            badgeProps.contradiction = contradictionPctOverride;
+          }
+          const hasWindow = typeof window !== 'undefined';
+          let previousState;
+          let stateOverridden = false;
+          if (hasWindow && stateForEngine) {
+            previousState = window.state;
+            window.state = {
+              ...stateForEngine,
+              ml_signals_timestamp: canonicalTimestamp ?? stateForEngine.ml_signals_timestamp ?? null
+            };
+            stateOverridden = true;
+          }
+          try {
+            renderBadges(badgeContainer, badgeProps);
+          } finally {
+            if (hasWindow && stateOverridden) {
+              window.state = previousState;
+            }
+          }
         }
-        renderBadges(document.querySelector('#badges-sim'), {
-          state: stateForEngine || {},
-          ...badgeProps
-        });
       } catch (e) {
         console.warn('Badges render skipped:', e?.message);
       }
 
+      updateCapsTriggered(capsTriggered);
+
       // Decision Index
       document.getElementById('sim-di-gauge').textContent = di.di;
       document.getElementById('sim-di-source-badge').textContent = `Source: ${di.source}`;
@@ -988,6 +1076,36 @@
       document.getElementById('sim-summary-nl').textContent = explanation.summaryNL;
     }
 
+    function updateCapsTriggered(entries) {
+      const container = document.getElementById('sim-caps-triggered');
+      if (!container) return;
+
+      if (!Array.isArray(entries) || entries.length === 0) {
+        container.innerHTML = '<div class="caps-triggered-summary">Caps triggered: <strong>0</strong></div>';
+        return;
+      }
+
+      const items = entries.map(entry => {
+        if (!entry || typeof entry !== 'object') {
+          return '<li><strong>--</strong></li>';
+        }
+        const { group, cap, excess } = entry;
+        const hasCap = typeof cap === 'number' && Number.isFinite(cap);
+        const hasExcess = typeof excess === 'number' && Number.isFinite(excess);
+        const before = hasCap && hasExcess ? cap + excess : null;
+        const beforeText = before != null ? before.toFixed(1) : '--';
+        const afterText = hasCap ? cap.toFixed(1) : '--';
+        const capText = hasCap ? cap.toFixed(1) : '--';
+        const label = group || '--';
+        return `<li><strong>${label}</strong>: ${beforeText}% -> ${afterText}% (cap ${capText}%)</li>`;
+      }).join('');
+
+      container.innerHTML = `
+        <div class="caps-triggered-summary">Caps triggered: <strong>${entries.length}</strong></div>
+        <ul>${items}</ul>
+      `;
+    }
+
     function displayAllocationChart(targets) {
       const chartEl = document.getElementById('sim-allocation-chart');
       if (!chartEl || !targets) return;
